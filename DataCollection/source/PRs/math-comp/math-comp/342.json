{"author":"ggonthier","number":342,"diff_summary":[{"file":".gitlab-ci.yml","status":"M","additions":113,"deletions":15},{"file":"CHANGELOG.md","status":"M","additions":113,"deletions":15},{"file":"mathcomp/character/classfun.v","status":"M","additions":113,"deletions":15},{"file":"mathcomp/field/galois.v","status":"M","additions":113,"deletions":15},{"file":"mathcomp/ssreflect/seq.v","status":"M","additions":113,"deletions":15},{"file":"mathcomp/ssreflect/ssrbool.v","status":"M","additions":113,"deletions":15},{"file":"mathcomp/ssreflect/ssreflect.v","status":"M","additions":113,"deletions":15},{"file":"mathcomp/ssreflect/ssrnotations.v","status":"M","additions":113,"deletions":15}],"state":"merged","open_date":"2019-05-05T16:33:14Z","update_date":"2019-05-06T16:04:48Z","discussion":[{"author":"ggonthier","date":"2019-05-06T07:23:52Z","comment":"@gares: will try, but as this is a Coq < 8.9 only error it may be a diminishing return effort. I suspect it has to do with the ssr view abstraction code not purging delayed unification constraints before reabstracting evars, and Coq delaying the `return` predicate constraints for all `match`es in those old versions. It'll take me a while to check, as I'm not set up right now to debug with Coq 8.7.\r\n"},{"author":"gares","date":"2019-05-06T07:41:18Z","comment":"Oh, btw the code dealing with views was mostly rewritten in the new tactic monad in 8.9 to support the new intro patterns including the tactic one, so it may be the case that it changed behavior in a subtle way. If you say the new behavior is better or even just ok, then It may not be worth spending much time on it (8.10beta is to be released this week)."},{"author":"ggonthier","date":"2019-05-06T13:31:15Z","comment":"Ok, @gares, I somewhat tracked down the issue. It is specific to coq v8.7, so on the one hand it could go away as we drop 8.7 support. On the other hand, it's _not_ something that was fixed by the SSReflect view code refactoring as that was only in 8.9, and the characteristics of the issue are fairly alarming, so it might still be worth looking into, to make sure the root cause has indeed been fixed.\r\n```\r\nRequire Import ssreflect.\r\nLemma foo U (l1 l2 : list U) : l1 = nil -> (l1 = nil -> l2 = nil) -> True. Proof. split. Qed.\r\nLemma bar T (t S : list T) : (t = nil -> S = nil) -> True.\r\nmove/(fun s1_0 ss21 => foo _ _ _ s1_0 ss21).\r\n```\r\ngenerates\r\n```\r\nError:\r\nLtac call to \"move (ssrmovearg) (ssrclauses)\" failed.\r\nIllegal application: \r\nThe term\r\n \"fun (s1_0 : t = nil) (ss21 : t = nil -> l = nil) => foo T t l s1_0 ss21\"\r\nof type \"t = nil -> (t = nil -> l = nil) -> True\"\r\ncannot be applied to the terms\r\n \"e\" : \"t = nil\"\r\n \"_top_assumption_\" : \"t = nil -> S = nil\"\r\nThe 2nd term has type \"t = nil -> S = nil\" which should be coercible to\r\n \"t = nil -> l = nil\".\r\n```\r\nThe most alarming is that this bug is _name-sensitive_; the error does not occur unless the name of the third parameter of `bar` _starts with an_ `S` !!! Also, replacing the abstract `T` with any fixed type makes the issue disappear. I'm quite at a loss as to what might cause such mischief.\r\nI've not raised an issue Coq-side because of this being tied to both an old Coq version and to an SSReflect feature, but you may want to do so if the bug turns out to be on the Coq side."},{"author":"ggonthier","date":"2019-05-06T15:49:51Z","comment":"Unless someone objects, I'll merge this as soon as CI completes, as this PR is holding up a more substantial revision of the `perm_eq` lemmas. It was split off to allow reusing the (misnamed, and little used) `perm_uniq` lemma name without requiring an overlay for `fourcolor`: the plan is to first deprecate (here) the old `perm_uniq`, then update `fourcolor`, submit the main `perm_eq` PR, and finally update all clients to the new lemma names."}],"review_discussion":[],"tags":[],"commits":[{"author":"ggonthier","committer":"ggonthier","hash":"b59653a5b377f91a21e8036bf0b5d98a35fc4963","message":"add `deprecate` helper notation; no `perm` in non-`perm_eq` lemma names\n\n- add notation support for lemma renaming PRs, helping clients adjust\nto the name change by emitting warning or raising errors when the old\nname is used. The default is to emit warnings, but clients can change\nthis to silence (if electing to delay migration) or errors (to help\nwith actual migration). Usage:\n  Notation old_id := (deprecate old_id new_id) (only parsing).\n—> Caveat 1: only prenex maximal implicit of `new_id` are preserved, so,\nas `Notation` does not support on-demand implicits, the latter should\nbe added explicitly as in `(deprecate old new _ _)`.\n—> Caveat 2: the warnings are emitted by a tactic-in-term, which\nis interpreted during type elaboration. As the SSReflect elaborator may\nre-infer type in arguments multiple times (notably, views and arguments\nto `apply` and `rewrite`), clients may see duplicate warnings.\n- use the `deprecate` facility to introduce the first part of the\nrefactoring of `seq` permutation lemmas : only lemmas concerning\n`perm_eq` should have `perm` as a component of their name.\n- document local additions in `ssreflect.v` and `ssrbool.v`\n- add 8.8 `odd-order` regression\n- the explicit beta-redex idiom use in the `perm_uniq` and\n`leq_min_perm` aliases avoids a strange name-sensitive bug of view\ninterpretation in Coq 8.7.","date":"2019-05-06T14:16:24Z"}]}