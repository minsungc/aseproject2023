{"author":"CohenCyril","number":211,"diff_summary":[{"file":"CHANGELOG_UNRELEASED.md","status":"A","additions":367,"deletions":27},{"file":"mathcomp/Make","status":"A","additions":367,"deletions":27},{"file":"mathcomp/Make.test-suite","status":"A","additions":367,"deletions":27},{"file":"mathcomp/algebra/fraction.v","status":"A","additions":367,"deletions":27},{"file":"mathcomp/algebra/ssrnum.v","status":"A","additions":367,"deletions":27},{"file":"mathcomp/ssreflect/Make","status":"A","additions":367,"deletions":27},{"file":"mathcomp/ssreflect/all_ssreflect.v","status":"A","additions":367,"deletions":27},{"file":"mathcomp/ssreflect/ssrAC.v","status":"A","additions":367,"deletions":27},{"file":"mathcomp/test_suite/test_ssrAC.v","status":"A","additions":367,"deletions":27}],"state":"merged","open_date":"2018-07-29T14:27:09Z","update_date":"2020-04-07T17:36:49Z","discussion":[{"author":"CohenCyril","date":"2018-07-30T21:17:13Z","comment":"Hi @pi8027! I have had this small dev pending for a while, and after listening to your talk I revived it.\r\nThe difference with you work is the fact that the shapes of the terms have to be provided by hand, and the comparison function is not using a merge sort but some kind of spaghetti sort instead.\r\nThere would be some ltac plumbery to do to compute the shapes from `LHS` and `RHS` in ltac and `apply: (AC shape_lhs shape_rhs).`"},{"author":"pi8027","date":"2018-07-31T05:15:51Z","comment":"@CohenCyril I discovered many clever techniques in your code! I am especially surprised that your \"spaghetti sort\" can be done in O(n log n). Thanks for sharing your work.\r\n\r\nHere I point out an issue I found (but I don't know how can we solve it...):\r\n- https://github.com/CohenCyril/math-comp/blob/aab7a3be907430c131f51c844686c56de24c8bcf/mathcomp/ssrtest/test_ssrAC.v#L5,\r\n  https://github.com/CohenCyril/math-comp/blob/aab7a3be907430c131f51c844686c56de24c8bcf/mathcomp/ssrtest/test_ssrAC.v#L9\r\n  Some `orb_comoid`s and `addn_comoid`s are left in the goal after rewriting."},{"author":"pi8027","date":"2018-07-31T05:45:57Z","comment":"- https://github.com/CohenCyril/math-comp/blob/aab7a3be907430c131f51c844686c56de24c8bcf/mathcomp/ssreflect/ssrAC.v#L210\r\n  `have: pat' = ord by reflexivity` can be replaced with `unify pat' ord` or `unify pat ord`. It would be a smarter way to invoke the convertibility test.\r\n- https://github.com/CohenCyril/math-comp/blob/aab7a3be907430c131f51c844686c56de24c8bcf/mathcomp/ssreflect/ssrAC.v#L213\r\n  In this context, `vm_compute; reflexivity` seems to be equivalent to `reflexivity`. (I don't know which one is efficient.)"},{"author":"CohenCyril","date":"2018-07-31T07:18:58Z","comment":"@pi8027 Thank you for your positive feedback! I am glad you found it interesting.\r\n\r\n> I am especially surprised that your \"spaghetti sort\" can be done in O(n log n). Thanks for sharing your work.\r\n\r\nI did not take the time to check (did you?) but I believe it is indeed O(n log n) in time and a call stack of size O(log n).\r\n\r\n> Some orb_comoids and addn_comoids are left in the goal after rewriting.\r\n\r\nThis is unavoidable when the rule is quantified over a monoid law, (indeed lemmas `Monoid.mulm1` ... leave similar overhead). The goal can be simplified using `/=`, and if you really do not want this, you may use the `op.[AC p s]` rule instead.\r\n\r\n> have: pat' = ord by reflexivity can be replaced with unify pat' ord or unify pat ord. It would be a smarter way to invoke the convertibility test.\r\n\r\nAFAIK, `unify x y` invokes unification, which in this case is not necessary because the terms must be ground, and it might be less efficient (wouldn't it?)\r\n\r\n> In this context, vm_compute; reflexivity seems to be equivalent to reflexivity. (I don't know which one is efficient.)\r\n\r\n`vm_compute; reflexivity` inserts a vm cast to make the computation using the VM instead of the abstract machine, so should be more efficient. I guess this whole `ltac: ()` notation could be replaced by `(isT <: _)`, but it would prevent me from producing a nice error message."},{"author":"CohenCyril","date":"2018-07-31T07:22:06Z","comment":"@maximedenes this is how I encountered the issue https://github.com/coq/coq/issues/8190"},{"author":"pi8027","date":"2018-08-01T03:13:37Z","comment":"@CohenCyril\r\n\r\n> I did not take the time to check (did you?) but I believe it is indeed O(n log n) in time and a call stack of size O(log n).\r\n\r\nProof. Let us suppose that a reordering `s: syntax` consists of m leaves and the largest leaf in `s` is n. It is easy to check that the height of `acc: env N` is always less than or equal to (log_2 n + 1) during the execution of `content s`. Each `set_pos 0%num Nsucc acc n` does only two things: [part 1: O(log n)] reconstructs a path in `acc` from the root to the node of position `n` and [part 2: O(log m)] increments the node value of position `n`. The whole sorting process `content s` repeats `set_pos ...` m times and can be done in O(m log(nm)). In this usage, well-formed reordering syntax holds the equation n = m (right?). So the sorting can be done in O(n log n) time complexity. ■\r\n\r\nHowever, `content` may consume the call stack linearly. I think that it can't be solved.\r\n\r\n> This is unavoidable when the rule is quantified over a monoid law, (indeed lemmas Monoid.mulm1 ... leave similar overhead). The goal can be simplified using /=, and if you really do not want this, you may use the op.[AC p s] rule instead.\r\n\r\nI understood it. Thank you.\r\n\r\n> vm_compute; reflexivity inserts a vm cast to make the computation using the VM instead of the abstract machine, so should be more efficient. I guess this whole ltac: () notation could be replaced by (isT <: _), but it would prevent me from producing a nice error message.\r\n\r\nI compared `reflexivity` and `vm_compute; reflexivity` in some examples. You were right!\r\n\r\n> AFAIK, unify x y invokes unification, which in this case is not necessary because the terms must be ground, and it might be less efficient (wouldn't it?)\r\n\r\nI compared two normalized ground terms by `unify` and `reflexivity`. The following example seems to indicate that the `unify` tactic is slightly better on efficiency.\r\n\r\n```\r\nRequire Import ssreflect Arith ZArith.\r\n\r\nGoal False.\r\nProof.\r\nlet x := constr: ((1000 ^ 2000)%Z) in\r\nlet y := constr: ((1000000 ^ 1000)%Z) in\r\nlet x' := eval vm_compute in x in\r\nlet y' := eval vm_compute in y in\r\n(time unify x' y');\r\n(time let _ := constr: (eq_refl _ : x' = y') in idtac);\r\n(time have _: x' = y' by reflexivity).\r\n(*\r\nTactic call ran for 0.007 secs (0.007u,0.s) (success)\r\nTactic call ran for 0.02 secs (0.019u,0.s) (success)\r\nTactic call ran for 0.179 secs (0.18u,0.s) (success)\r\n*)\r\nAbort.\r\n```"},{"author":"CohenCyril","date":"2018-08-01T08:02:01Z","comment":"@pi8027 \r\n> Proof [...] ■\r\n\r\nYeah I'm convinced by your proof.\r\n\r\n> However, `content` may consume the call stack linearly. I think that it can't be solved.\r\n\r\nI'd say both `content` and `set_pos` occupy O(log n) of the stack each, because there is one non tail recursive call in each.\r\nI replaced `set_pos` by a tail recursive alternative `set_pos_trec` (using Huet's zipper), so that only the non tail recursive calls of `content` consume the stack, and I think that is the best I can do.\r\n\r\n> I compared two normalized ground terms by `unify` and `reflexivity`. The following example seems to indicate that the `unify` tactic is slightly better on efficiency.\r\n\r\nI am surprised...\r\n"},{"author":"CohenCyril","date":"2018-08-01T08:31:25Z","comment":"> I'd say both content and set_pos occupy O(log n) of the stack each, because there is one non tail recursive call in each.\r\n\r\noh, but each continuation contains a tree of half of the size of the argument..."},{"author":"pi8027","date":"2018-08-01T09:52:13Z","comment":"@CohenCyril\r\n\r\n> I am surprised...\r\n\r\nIt is easy to check that `reflexivity` may instantiate existential variables like as `unify`. So I guess that `have _: x = y by reflexivity` and `unify x y` have the same behavior for any `x` and `y`. However, the former one does some additional tasks: trying to instantiate the goal and type checking of `erefl: x = y` (that includes convertibility test `x =? y`). Your neighbors would know whether my understanding is correct or not, and more details. :)"},{"author":"gares","date":"2018-08-01T13:51:38Z","comment":"The only comment I have right now is that, as for under, there is quite some ltac code.\r\n\r\nI think it is good to make a prototype and let people play with it, but at some point things should be rewritten in ML, so that one can just call `whd_all` rather than going trough notations and tactics-in-terms to perform some reduction on the given term."},{"author":"amahboubi","date":"2018-08-29T15:47:03Z","comment":"Hi, I think that it is great to have this code available, but I also think that it is not ready (yet) for merge. The roadmap is probably something to be discussed in the next dev working group. By the way, could you document the (names of the) constants that are the user's environment after a `Require Import ssr_AC`?"},{"author":"CohenCyril","date":"2018-09-05T08:44:29Z","comment":"Hi @amahboubi right now the following notations are exported:\r\n* `AC_check_pattern`, `AC_strategy`, `opACof law p s`, `opAC op p s`, `opACl op s` which are internal (but outside of the module `AC` for technical reason (namely too agressive name substitution in ltac in notation (not sure this is a bug though...)))\r\n* `op .[ 'ACof' p s ]`, `op .[ 'AC' p s ]`, `op .[ 'ACl' s ]`, `ACof p s`, `AC p s` and `ACl s` which are documented in the header (I realize now a scope is missing for non simple notations, this must be fixed).\r\n* `1` and `x * y` in scope `AC_scope` (shortened with `%AC` which is bound to the right arguments of the previous notations, so no explicit `%AC` is required). Also documented in the header (except for the scope).\r\n\r\nAnd all the exported constants are prefixed with module `AC`.\r\n\r\nDo you want me to add this to the header?"},{"author":"CohenCyril","date":"2019-11-27T18:01:03Z","comment":"This PR needs an assignee..."},{"author":"affeldt-aist","date":"2020-03-25T15:40:00Z","comment":"From the release managers for 1.11: does this PR really need propagation? Could it be merged as is and an issue be opened to propagate?"},{"author":"CohenCyril","date":"2020-03-25T15:52:03Z","comment":"I would be happy that this merged, but it has not been reviewed and it had no assignee... and I guess it is difficult to assess. It should at least be rebased, let me do that first..."},{"author":"CohenCyril","date":"2020-03-26T15:42:11Z","comment":"I rewrote some proof scripts using ssrAC, just for the example. Two are significantly shorter but were badly written in the first place.\r\nIt is very likely that this tool will essentially help during proof development, but that final refactoring of proofs will hopefully get rid of it... but I guess it is a useful  tool for that purpose.\r\n\r\nAs such, I will remove the \"needs: propagation\" label. If we change our minds we can reestablish it. I am also in favor of having this part of the beta, and withdraw it in the final release if necessary (as I said in my previous post)"},{"author":"gares","date":"2020-03-26T16:22:51Z","comment":"Some versions of Coq fail with message `The term \"2\" has type \"nat\" while it is expected to have type\r\n \"GRing.Ring.sort ?R1\"`.\r\n\r\nI personally don't care about 8.7..8.9 much, but if this PR is the *only* reason to drop compatibility with them, then I'm not in favor of merging it \"as it is\"."},{"author":"CohenCyril","date":"2020-03-26T17:34:17Z","comment":"> Some versions of Coq fail with message `The term \"2\" has type \"nat\" while it is expected to have type \"GRing.Ring.sort ?R1\"`.\r\n> \r\n> I personally don't care about 8.7..8.9 much, but if this PR is the _only_ reason to drop compatibility with them, then I'm not in favor of merging it \"as it is\".\r\n\r\nYou are right, we should not lose compatibility and the tests and the main file used to passe.\r\nI tried to rewrite some parts of the libraries but it seems I messed with scopes somehow, I will look into it by tomorrow noon."},{"author":"CohenCyril","date":"2020-04-06T10:26:27Z","comment":"@gares @affeldt-aist @ybertot should we integrate it?"},{"author":"ybertot","date":"2020-04-06T12:20:48Z","comment":"ping @gares"}],"review_discussion":[],"tags":[{"tag":"kind: enhancement","description":"Issue or PR about addition of features."}],"commits":[{"author":"CohenCyril","committer":"CohenCyril","hash":"a0d310fef7b4023793e74af103955e2dd8832faf","message":"Rewriting with AC (not modulo AC), using a small scale command.\n\nThis replaces opA, opC, opAC, opCA, ... and any combinations of them\n\n- Right now the rewrite relies on an rather efficient computation\n  of perm_eq using a \"spaghetti sort\" in O(n log n)\n- Wrongly formed AC statements send error messages showing the\n  discrepancy between LHS and RHS patterns.\n\n Usage :\n   rewrite [pattern](AC operator pattern-shape re-ordering)\n   rewrite [pattern](ACl operator re-ordering)\n\n - pattern is optional, as usual,\n - operator must have a canonical Monoid.com_law structure\n   (additions, multiplications, conjunction and disjunction do)\n - pattern-shape is expressed using the syntax\n      p := n | p * p'\n      where \"*\" is purely formal\n        and n > 0 is number of left associated symbols\n   examples of pattern shapes:\n   + 4 represents (n * m * p * q)\n   + (1*2) represents (n * (m * p))\n - re-ordering is expressed using the syntax\n     s := n | s * s'\n   where \"*\" is purely formal and n is the position in the LHS\n\n If the ACl variant is used, the pattern-shape defaults to the\n pattern fully associated to the left i.e. n i.e (x * y * ...)\n\n Examples of re-orderings:\n - ACl op ((0*1)*2) is the identity (and should fail to rewrite)\n - opAC == ACl op ((0*2)*1) == AC op 3 ((0*2)*1)\n - opCA == AC op (2*1) (0*1*2)\n - rewrite opCA -opA == rewrite (ACl op (0*(2*1))\n - opACA == AC (2*2) ((0*2)*(1*3))","date":"2020-04-06T10:40:23Z"},{"author":"CohenCyril","committer":"CohenCyril","hash":"a00523aee7c13fa5c2a2025ac2fe9412ad7ca5ee","message":"Some proof scripts made better using ssrAC.\n\n%AC annotation are for backward compatilibity with coq <= 8.9","date":"2020-04-06T10:40:23Z"}]}