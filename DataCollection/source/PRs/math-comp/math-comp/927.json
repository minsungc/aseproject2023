{"author":"pPomCo","number":927,"diff_summary":[{"file":"mathcomp/algebra/ssralg.v","status":"M","additions":737,"deletions":1},{"file":"mathcomp/algebra/ssrnum.v","status":"M","additions":737,"deletions":1},{"file":"mathcomp/ssreflect/bigop.v","status":"M","additions":737,"deletions":1},{"file":"mathcomp/ssreflect/eqtype.v","status":"M","additions":737,"deletions":1},{"file":"mathcomp/ssreflect/finfun.v","status":"M","additions":737,"deletions":1},{"file":"mathcomp/ssreflect/finset.v","status":"M","additions":737,"deletions":1},{"file":"mathcomp/ssreflect/fintype.v","status":"M","additions":737,"deletions":1},{"file":"mathcomp/ssreflect/order.v","status":"M","additions":737,"deletions":1}],"state":"closed","open_date":"2022-09-23T12:45:33Z","update_date":"2022-09-27T14:38:34Z","discussion":[{"author":"pPomCo","date":"2022-09-27T14:38:34Z","comment":"Thanks proux01 for your fast review.\r\nAs you suggest, I will propose smaller pull requests in order to split finType-related and algebra-related lemmas.\r\nAlso I will take into account all the useful comments you made for this PR.\r\n"}],"review_discussion":[{"author":"proux01","file":"mathcomp/algebra/ssralg.v","date":"2022-09-24T11:44:45Z","comment":"Could you explain what you find this useful for? It seems to me that\r\n```Coq\r\nrewrite (mulr_ll eq)\r\n```\r\ncould be done with\r\n```Coq\r\nrewrite [X in _ * X]eq\r\n```\r\nand\r\n```Coq\r\napply: mulr_ll\r\n```\r\ncould be done with\r\n```Coq\r\ncongr (_ * _)\r\n```\r\n"},{"author":"proux01","file":"mathcomp/algebra/ssralg.v","date":"2022-09-24T11:47:21Z","comment":"Can be generalized a bit:\r\n```suggestion\r\nLemma eqr_sum_div I r P (f : I -> F) c a : c != 0 ->\r\n  \\big[+%R/0]_(x <- r | P x) (f x / c) == a\r\n  = (\\big[+%R/0]_(x <- r | P x) f x == a * c).\r\nProof.\r\nby move=> ?; rewrite -mulr_suml -(divr1 a) eqr_div ?oner_eq0// mulr1 divr1.\r\nQed.\r\n```\r\n(the form `x <- r` is the most generic form of bigop, so this would also work for fintypes)."},{"author":"proux01","file":"mathcomp/algebra/ssrnum.v","date":"2022-09-24T11:48:09Z","comment":"```suggestion\r\nLemma ner01 : 0 != 1 :> R.\r\nProof. by rewrite eq_sym oner_eq0. Qed.\r\n```\r\nBut I wonder how useful this really is, considering the simplicity of the proof."},{"author":"proux01","file":"mathcomp/algebra/ssrnum.v","date":"2022-09-24T11:48:43Z","comment":"Isn't this subsumed by `ltr_spaddl`?"},{"author":"proux01","file":"mathcomp/algebra/ssrnum.v","date":"2022-09-24T11:50:37Z","comment":"Can be simplified a bit\r\n```suggestion\r\nLemma psumr_neq0 (I : eqType) (r : seq I) (P : pred I) (F : I -> R) :\r\n    (forall i, P i -> 0 <= F i) ->\r\n  (\\sum_(i <- r | P i) (F i) != 0) = (has (fun i => P i && (0 < F i)) r).\r\nProof.\r\nmove=> F_ge0; rewrite psumr_eq0// -has_predC; apply: eq_has => x /=.\r\nby case Px: (P x); rewrite //= lt_def F_ge0 ?andbT.\r\nQed.\r\n\r\nLemma psumr_neq0P (I : finType) (P : pred I) (F : I -> R) :\r\n     (forall i, P i -> 0 <= F i) -> \\sum_(i | P i) F i <> 0 ->\r\n  (exists i, P i && (0 < F i)).\r\nProof. by move=> ? /eqP; rewrite psumr_neq0// => /hasP[x _ ?]; exists x. Qed.\r\n```"},{"author":"proux01","file":"mathcomp/algebra/ssrnum.v","date":"2022-09-24T11:51:01Z","comment":"What's the difference with `addr_gte0` above?"},{"author":"proux01","file":"mathcomp/ssreflect/bigop.v","date":"2022-09-24T12:09:52Z","comment":"What's the difference with bigID?"},{"author":"proux01","file":"mathcomp/ssreflect/bigop.v","date":"2022-09-24T12:27:32Z","comment":"Have you considered using subType for that kind\tof things? (c.f. eqtype.v)"},{"author":"proux01","file":"mathcomp/ssreflect/eqtype.v","date":"2022-09-24T12:31:32Z","comment":"Could you explain your use case? What can you do with that that's not easily feasible with `eqP`?"},{"author":"proux01","file":"mathcomp/ssreflect/order.v","date":"2022-09-26T10:46:22Z","comment":"If I understand correctly, your goal is to build Monoid structures on min/max to be able to use all bigop lemmas on them. Your solution works well and this is probably the easiest one, hence the best choice for you. You are right that this min/max thing is a clear limitation of the library. However, I'm not sure we want to choose the path you propose here. Indeed, the drawback of defining new functions `omin` and `omax` is that you would have to reprove a bunch of lemmas about them. An alternative would be to declare an order structure on `option` (for instance making `none` greater that everything would make `Order.min` on this structure work as `omin`). Unfortunately this structure is not the same for `omin` and `omax` (`none` should be less than everything in that latter case) and working with different structures on the same type is rather painful. Thus we are pursuing the two following paths in the library:\r\n\r\n* generalize lemmas on monoid to semigroups or semigroups with an idempotent element (min and max being both idempotent for every element), this would allow to extend the Monoid hierarchy in the new port to hierarchy builder to use most bigop lemmas on min and max, there is an ongoing PR for that: https://github.com/math-comp/math-comp/pull/910\r\n* define an extended type with infinities, like in the `constructive_ereal.v` file in Analysis: https://github.com/math-comp/analysis/blob/master/theories/constructive_ereal.v Thus your `omin` and `omax` would just be `Order.min` and `Order.max` on this type, enabling to reuse all order lemmas. This work still needs to be integrated in MathComp proper.\r\n"},{"author":"pPomCo","file":"mathcomp/ssreflect/order.v","date":"2022-09-27T12:53:19Z","comment":"Thanks proux01 for your fast review.\r\nAs you suggest, I will propose smaller pull requests in order to split finType-related and algebra-related lemmas. \r\nAlso I will take into account all the useful comments you made for this PR. "},{"author":"pPomCo","file":"mathcomp/algebra/ssralg.v","date":"2022-09-27T13:03:07Z","comment":"Thanks for the syntax (and so it is useless)"},{"author":"pPomCo","file":"mathcomp/algebra/ssralg.v","date":"2022-09-27T13:03:12Z","comment":"Thanks"},{"author":"pPomCo","file":"mathcomp/algebra/ssrnum.v","date":"2022-09-27T13:04:52Z","comment":"Yes it is"},{"author":"pPomCo","file":"mathcomp/algebra/ssrnum.v","date":"2022-09-27T13:05:04Z","comment":"Thanks"},{"author":"pPomCo","file":"mathcomp/ssreflect/eqtype.v","date":"2022-09-27T13:07:06Z","comment":"I use it as an argument of Eqdep_dec.eq_proofs_unicity, for instance:\r\n`Eqdep_dec.eq_proofs_unicity (@eq_comparable_prop bool_eqType)`"},{"author":"proux01","file":"mathcomp/ssreflect/eqtype.v","date":"2022-09-27T13:50:21Z","comment":"Makes sense but then why don't you use `eqtype.eq_irrelevance` from MathComp rather than a lemma from the stdlib?"}],"tags":[],"commits":[{"author":"pPomCo","committer":"pPomCo","hash":"ef5383d41a5bcbf582d8a76b60906141b9d1c7bb","message":"Contrib","date":"2022-09-23T12:28:02Z"},{"author":"pPomCo","committer":"web-flow","hash":"77677eb2679caa5ed5be7204f2b2b3385c74d75a","message":"Merge branch 'math-comp:master' into contrib","date":"2022-09-23T12:29:19Z"}]}