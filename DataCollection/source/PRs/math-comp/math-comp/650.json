{"author":"pi8027","number":650,"diff_summary":[{"file":"CHANGELOG_UNRELEASED.md","status":"M","additions":220,"deletions":219},{"file":"mathcomp/ssreflect/fintype.v","status":"M","additions":220,"deletions":219},{"file":"mathcomp/ssreflect/path.v","status":"M","additions":220,"deletions":219}],"state":"merged","open_date":"2020-11-15T01:45:36Z","update_date":"2020-11-19T10:48:47Z","discussion":[{"author":"CohenCyril","date":"2020-11-18T00:39:01Z","comment":"@chdoc do you approve as well?"},{"author":"CohenCyril","date":"2020-11-18T11:58:26Z","comment":"Given the problem with ci-fscl-pcm, maybe `subseq_order_path` renaming can wait until we switch to Coq's deprecation mechanism?"},{"author":"pi8027","date":"2020-11-18T20:56:46Z","comment":"> Given the problem with ci-fscl-pcm, maybe `subseq_order_path` renaming can wait until we switch to Coq's deprecation mechanism?\r\n\r\nOne more placeholder was missing in the deprecation notation. Should be ok now."},{"author":"CohenCyril","date":"2020-11-19T09:03:03Z","comment":"@chdoc do you approve?"}],"review_discussion":[{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-16T05:41:31Z","comment":"Should this also be renamed to `subseq_path`? (Does `order` stand for transitivity here?)"},{"author":"chdoc","file":"mathcomp/ssreflect/path.v","date":"2020-11-16T10:41:51Z","comment":"```suggestion\r\nLemma sort_stable T (leT leT' : rel T) (s: seq T) : \r\n  total leT -> transitive leT -> transitive leT' -> sorted leT' s ->\r\n```"},{"author":"chdoc","file":"mathcomp/ssreflect/path.v","date":"2020-11-16T10:46:58Z","comment":"To me, this looks like the change to the `Stability` section is not yet ideal. Maybe the transfer from `rel T` to `rel nat` can be be factored out?"},{"author":"chdoc","file":"mathcomp/ssreflect/path.v","date":"2020-11-16T10:48:40Z","comment":"```suggestion\r\nhave leN_total: total (relpre (nth x s) leT) by move=> n m; apply: leT_total.\r\n```"},{"author":"chdoc","file":"mathcomp/ssreflect/path.v","date":"2020-11-16T10:48:56Z","comment":"```suggestion\r\nmove=> leT_total leT_tr leT'_tr sorted_s; case Ds: s => // [x s1].\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-16T20:09:38Z","comment":"I chose this ordering of arguments intentionally. Most sorting lemmas (except for `order_path_min` and `_in` lemmas for `eqType`s) take properties of relations before sequences. This PR also does not change the ordering of the arguments of `sort_stable`."},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-16T23:34:18Z","comment":"I noticed that transitivity of `leT` is not required (and not used actually) to prove `sort_stable`. Let me fix it."},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-17T00:57:29Z","comment":"The problem here is that `filter_sort` has to use `sort_stable` for a `seq nat` obtained by the `mkseq` technique and it does not allow us to factor out some intermediate steps of them using a `Section`. Anyway, I managed to prove this lemma with fewer `have` in the last revision. Do you still see any possible improvement?"},{"author":"chdoc","file":"mathcomp/ssreflect/path.v","date":"2020-11-17T09:57:28Z","comment":"I'm not sure what you mean. My ideas were along the lines of:\r\n```coq\r\nSection LeLex.\r\n\r\nVariables (T : Type) (leT : rel T) (x0 : T) (s : seq T).\r\n\r\nLet leN := relpre (nth x0 s) leT.\r\nDefinition le_lex := [rel n m | leN n m && (leN m n ==> (n < m))].\r\n\r\nLemma le_lex_trans : transitive leT -> transitive le_lex.\r\nProof.\r\nmove=> leT_tr. rewrite /le_lex /leN => ? ? ? /= /andP [xy xy'] /andP [yz yz'].\r\nrewrite (leT_tr _ _ _ xy yz); apply/implyP => zx; move: xy' yz'.\r\nby rewrite (leT_tr _ _ _ yz zx) (leT_tr _ _ _ zx xy); apply: ltn_trans.\r\nQed.\r\n\r\nLemma le_lex_irr : irreflexive le_lex. \r\nProof. by move=> x; rewrite /le_lex/leN/= ltnn implybF andbN. Qed.\r\n\r\nEnd LeLex.\r\n\r\nArguments le_lex_trans [T leT] x0 s.\r\n\r\nLemma filter_sort T (leT : rel T) :\r\n  total leT -> transitive leT ->\r\n  forall p s, filter p (sort leT s) = sort leT (filter p s).\r\nProof.\r\nmove=> leT_total leT_tr p s; case Ds: s => // [x s1].\r\nrewrite -{s1}Ds -(mkseq_nth x s) !(filter_map, sort_map); congr map.\r\nhave ? : total (relpre (nth x s) leT) by move=> n m; apply: leT_total.\r\nhave le_lex_tr := le_lex_trans x s leT_tr.\r\napply: (irr_sorted_eq le_lex_tr (le_lex_irr leT x s)). \r\n- exact/sorted_filter/sort_iota_stable. \r\n- exact/sort_stable/sorted_filter/iota_ltn_sorted/ltn_trans/ltn_trans.\r\n- by move=> ?; rewrite !(mem_filter, mem_sort).\r\nQed.\r\n```\r\nI'm not sure `le_lex` is a good global name, but I think the pattern of turning an order on `T` into an corresponding order on `nat` is quite generic. I'm surprised this is only needed once... "},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-17T16:47:44Z","comment":"@chdoc In your code above, `le_lex` is a combination of two things: 1. lexicographic ordering and 2. turning an order on elements of a sequence into a corresponding order on `nat` using `nth`. If I declare it globally, I would rather split it into these two parts and parameterize the former one to take two relations, but it would also make this proof script lengthy. So I would like to keep the current one for now.\r\n\r\nA possible solution to this issue would be using canonical structures to infer properties of relations, but this should be another PR."},{"author":"chdoc","file":"mathcomp/ssreflect/path.v","date":"2020-11-17T17:15:18Z","comment":"I wasn't suggesting that my comment is the final version, but I am strongly in favor of making the constructions explicit. You're also proving totality of the `relpre`+`nth` construction twice (I know, it's a one-liner). Maybe @CohenCyril has an opinion on this; his review is still outstanding. \r\n\r\nAlso, I'm not sure what's the connection to \"lexicographic ordering\", which I understand as the extension of an order from a type to sequences/words over that type, as done in dictionaries. But maybe that term is ambiguous. "},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-17T21:21:05Z","comment":"I agree with Kazuhiko, there is no further sensible refactoring that I can identify here.\r\nIt does not save space nor document things in better way to try and factor out `le_lex`.\r\n\r\n@pi8027, the only suggestion, which is obviously nitpicking, I have to make is: since the relation `le_lex` (local to the proof of `filter_sort`) is irreflexive it should be named `lt_lex` instead. (I know! the name was already wrong before)\r\n\r\n@chdoc, yes this is the lexicographic ordering on `nat * nat` with respective order relations `leN` and `ltn`, although the notion only appears and is formalized later on, in `order`...  it's ok to duplicate the proof of transitivity & irreflexivity of a (strict) lexicographic ordering for the sake of not bringing the whole of `order` in here and risking circular dependencies or huge refactorings...."},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-17T21:23:04Z","comment":"```suggestion\r\nLet lt_lex := [rel n m | leN n m && (leN m n ==> (n < m))].\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-17T21:23:10Z","comment":"```suggestion\r\n    sorted lt_lex s && perm_eq s (iota (size (flatten ss')) (size s)) &&\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-17T21:23:19Z","comment":"```suggestion\r\n  push_invariant (s1 :: ss) -> sorted lt_lex (merge_sort_pop leN s1 ss).\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-17T21:23:27Z","comment":"```suggestion\r\nLemma sort_iota_stable n : sorted lt_lex (sort leN (iota 0 n)).\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-17T21:23:52Z","comment":"```suggestion\r\npose lt_lex := [rel n m | leN n m && (leN m n ==> (n < m))].\r\nhave lt_lex_tr: transitive lt_lex.\r\n  rewrite /lt_lex /leN => ? ? ? /= /andP [xy xy'] /andP [yz yz'].\r\n  rewrite (leT_tr _ _ _ xy yz); apply/implyP => zx; move: xy' yz'.\r\n  by rewrite (leT_tr _ _ _ yz zx) (leT_tr _ _ _ zx xy); apply: ltn_trans.\r\nrewrite -{s1}Ds -(mkseq_nth x s) !(filter_map, sort_map); congr map.\r\napply/(@irr_sorted_eq _ lt_lex); rewrite /lt_lex /leN //=.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-18T00:38:20Z","comment":"I think so. I'm ok with the renaming."},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-18T01:24:37Z","comment":"> Also, I'm not sure what's the connection to \"lexicographic ordering\", which I understand as the extension of an order from a type to sequences/words over that type, as done in dictionaries. But maybe that term is ambiguous.\r\n\r\n> @chdoc, yes this is the lexicographic ordering on `nat * nat` with respective order relations `leN` and `ltn`, ...\r\n\r\nI meant that the following relation can be seen as (a generalization of) lexicographic ordering:\r\n```coq\r\nDefinition lexord (T : Type) (leT leT' : rel T) : rel T :=\r\n  [rel x y | leT x y && (leT y x ==> leT' x y)].\r\n```\r\nIn the case of that `T` is a product type and `leT` and `leT'` compare its first and second component respectively, `lexord` is the lexicographic ordering of products. Since order structures require `<=%O` to be antisymmetric, this generalization does not make sense in `order.v`."},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-18T04:48:54Z","comment":"Done."}],"tags":[{"tag":"kind: refactoring","description":"Issue or PR about a refactoring. (reorganizing the code, reusing theorems, simplifications...)"}],"commits":[{"author":"pi8027","committer":"pi8027","hash":"b3d31c4b66581c78ce23b7fc2e76b41a1a4adf60","message":"Refactor, reshuffle, and rename sorting lemmas in `path.v`\n\n- Lemmas `sorted_(lt|le)_nth` have been renamed to `sorted_(ltn|leq)_nth`.\n- Lemmas `(ltn|leq)_index` have been renamed to `sorted_(ltn|leq)_index` and\n  generalized for non-`eqType`s.\n- Lemmas `order_path_min`, `path_sortedE`, `subseq_order_path`, `subseq_sorted`,\n  `sorted_uniq`, `sorted_eq`, `irr_sorted_eq`, `sorted_(ltn|leq)_nth`, and\n  `sorted_(ltn|leq)_index` have been relocated since their proofs are\n  independent from `merge` and `sort`.\n- The stability proofs for `iota` sequences (`push_stable`, `pop_stable`, and\n  `sort_iota_stable`) have been simplified by sorting out their hypotheses and\n  by redefining `push_invariant` to include the `sorted` condition. Their main\n  result `sort_iota_stable`, formerly a local `Let` to prove `sort_stable`, has\n  been turned into a lemma.\n- Some stability proofs for general sequences (`sort_stable` and `filter_sort`)\n  have also been simplified, of which the former one uses the above\n  `sorted_ltn_nth` lemma for a non-`eqType`.","date":"2020-11-18T20:24:58Z"},{"author":"pi8027","committer":"pi8027","hash":"cdbb52e7c60883b0beee923fdd96baa3e80a1912","message":"Apply a suggestion from code review\n\nCo-authored-by: Christian Doczkal <christian.doczkal@inria.fr>","date":"2020-11-18T20:24:58Z"},{"author":"pi8027","committer":"pi8027","hash":"82db85f541dc9a47fd79b462a63b8b80a8468557","message":"Apply suggestions from code review\n\nCo-authored-by: Cyril Cohen <CohenCyril@users.noreply.github.com>","date":"2020-11-18T20:24:58Z"},{"author":"pi8027","committer":"pi8027","hash":"9e6c20b4bd5397539debee9fcb0853b6924ecfb9","message":"Rename `subseq_order_path` to `subseq_path`","date":"2020-11-18T20:53:45Z"}]}