{"author":"pi8027","number":358,"diff_summary":[{"file":"CHANGELOG_UNRELEASED.md","status":"M","additions":539,"deletions":115},{"file":"mathcomp/algebra/intdiv.v","status":"M","additions":539,"deletions":115},{"file":"mathcomp/ssreflect/path.v","status":"M","additions":539,"deletions":115},{"file":"mathcomp/ssreflect/seq.v","status":"M","additions":539,"deletions":115}],"state":"merged","open_date":"2019-06-13T09:15:57Z","update_date":"2019-10-25T07:46:35Z","discussion":[{"author":"CohenCyril","date":"2019-06-13T16:58:15Z","comment":"@pi8027 great PR! which I do not fully read yet... Just one bureaucratic comment so far:\r\n\r\n> * [ ]  merge dependency: #328\r\n\r\nSince #328 is not going to be merged without #358, I prefer that this PR substitutes #328 completely.\r\nPlease add \"closes #328\" to the original post and rebase all the commits on master (without caring about #328)."},{"author":"pi8027","date":"2019-06-14T12:26:19Z","comment":"@CohenCyril OK. I did it. I may need help on diffs coming from #328."},{"author":"pi8027","date":"2019-06-16T13:25:33Z","comment":"I have proved the following lemmas. `mask_sort'` and `subseq_sort'` can be derived as their corollaries.\r\n```coq\r\nsorted_sort\r\n     : forall (T : Type) (leT : rel T),\r\n       transitive leT -> forall s : seq T, sorted leT s -> sort leT s = s\r\nmask_sort\r\n     : forall (T : Type) (leT : rel T), total leT -> transitive leT ->\r\n       forall (s : seq T) (m : bitseq),\r\n       {m_s : bitseq | mask m_s (sort leT s) = sort leT (mask m s)}\r\nsubseq_sort\r\n     : forall (T : eqType) (leT : rel T),\r\n       total leT -> transitive leT -> {homo sort leT : t s / subseq t s}\r\n```"},{"author":"pi8027","date":"2019-06-19T11:21:41Z","comment":"I have finished all the improvements I could do now except for documentation."},{"author":"amahboubi","date":"2019-07-10T08:17:21Z","comment":"Hi @pi8027 , @CohenCyril, could you clarify the status of this PR today? Thanks in advance!"},{"author":"pi8027","date":"2019-07-10T12:56:20Z","comment":"@amahboubi @CohenCyril Currently, `sort_map_in` is not general enough and some hypothesis of it could be dropped; however, a generalized version seems to be difficult to prove. (see: https://github.com/math-comp/math-comp/pull/358#discussion_r294975535)\r\nSo I'd like to drop `sort_map_in` from this PR and add it later, if @CohenCyril cannot generalize it before long."},{"author":"amahboubi","date":"2019-07-10T13:02:06Z","comment":"Hello @pi8027, thanks for the feedback. Your plan looks sensible, please go ahead. However, it seems to me that your remark is orthogonal to CI failure, isn't it?"},{"author":"pi8027","date":"2019-07-10T19:18:14Z","comment":"Hello @amahboubi, I have removed `sort_map_in` and updated documentation. There is no CI failure now. So this PR is ready for review."},{"author":"pi8027","date":"2019-07-11T17:04:54Z","comment":"Lemmas `mask_sort'` and `subseq_sort'` could have better names."},{"author":"amahboubi","date":"2019-10-24T12:42:47Z","comment":"@pi8027 sorry for the lag: in the end do you want to change the names of  `mask_sort'` and `subseq_sort'` before we merge? @CohenCyril @anton-trunov @ggonthier do you see anything blocking the merge of this PR?"},{"author":"pi8027","date":"2019-10-24T13:42:35Z","comment":"@amahboubi I think `sorted_mask_sort` and `sorted_subseq_sort` would be better (but a bit redundant) because they are corollaries of `mask_sort` and `subseq_sort` where the case of masked sequence and subsequence are sorted. If no other names are suggested, I will rename them and rebase again."},{"author":"pi8027","date":"2019-10-24T21:26:07Z","comment":"Renamed & ready to merge."}],"review_discussion":[{"author":"anton-trunov","file":"mathcomp/ssreflect/path.v","date":"2019-06-13T12:17:29Z","comment":"Just a comment. Here is an alternative proof of `mem2E` lemma that does not use nested induction:\r\n\r\n```coq\r\nLemma mem2E s x y :\r\n  mem2 s x y = subseq (if x == y then [:: x] else [:: x; y]) s.\r\nProof.\r\nelim: s => [| h s]; first by case: ifP.\r\nrewrite mem2_cons => ->.\r\ndo ! rewrite !(fun_if subseq) !if_arg !sub1seq /= ?inE.\r\nby case: eqVneq => [-> |]; case: eqVneq.\r\nQed.\r\n```\r\n\r\nPlease feel free to use it or completely ignore it."},{"author":"anton-trunov","file":"mathcomp/solvable/abelian.v","date":"2019-06-13T13:34:58Z","comment":"```suggestion\r\ncase/andP=> _ /(order_path_min _) min_y.\r\n```\r\nFor uniformity with the rest of the patch."},{"author":"ggonthier","file":"mathcomp/solvable/abelian.v","date":"2019-06-13T14:54:30Z","comment":"Actually the proper fix is to make the implicits of `order_path_min` maximal, and _not_ modifying `abelian.v`, as I commented in #328"},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2019-06-14T11:58:12Z","comment":"Thank you so much! I have replaced the proof."},{"author":"anton-trunov","file":"mathcomp/ssreflect/path.v","date":"2019-06-14T12:03:53Z","comment":"I'm glad you liked it! Let me thank you for this great PR!"},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2019-06-14T12:13:54Z","comment":"Now I have a better conjecture to replace this but feel difficulties to prove it. :(\r\n```coq\r\nConjecture subseq_sort : {homo sort leT : t s / subseq t s}.\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2019-06-18T18:46:45Z","comment":"Section variables of `EqHomoPath` and `EqHomoSortSeq` are differently ordered, but can be the same and could have more uniformity. @CohenCyril Unless you did it intentionally, I would like to change it."},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2019-06-18T18:52:10Z","comment":"@CohenCyril Can you manage to prove this with fewer assumptions as I suggested in https://github.com/math-comp/math-comp/pull/328#discussion_r293323946?"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2019-06-19T08:42:51Z","comment":"@pi8027 yes please go ahead and let `f` be a section variable everywhere."},{"author":"pi8027","file":"mathcomp/solvable/abelian.v","date":"2019-06-19T11:17:14Z","comment":"I don't see the proper fix of this issue as @anton-trunov mentioned in https://github.com/math-comp/math-comp/pull/328#discussion_r293436129."},{"author":"ggonthier","file":"mathcomp/solvable/abelian.v","date":"2019-06-19T12:00:11Z","comment":"Indeed, you need to make the implicits of `order_path_min` both maximal _and prenex_, i.e., either make `transitive leT` an explicit rather than a section hypothesis (use `Implicit Type` if you don't want to repeat the statement/intro everywhere), or also make it a maximal implicit (which I don't recommend). The reason is that Coq doesn't alway insert maximal implicits; it requires all previous non-implicit arguments to be present.\r\n   An alternative solution would be to declare the section variable `T` as a `nonPropType`.\r\nI'll put a pointer in #328."}],"tags":[],"commits":[{"author":"ybertot","committer":"pi8027","hash":"9798c42f50d8a2ca905babe8fb7833e2420b89e7","message":"Modified the definition of sort to work on any type","date":"2019-10-24T16:51:21Z"},{"author":"CohenCyril","committer":"pi8027","hash":"e7fe888b2894e8ded7a24a85c2176b1d1fba53b6","message":"Other Generalizations, fixes and CHANGELOG entry","date":"2019-10-24T16:52:26Z"},{"author":"pi8027","committer":"pi8027","hash":"a426db7fae5b308d9fa0423f57f01335067a3c1e","message":"Avoid some eta-expansions","date":"2019-10-24T16:52:26Z"},{"author":"pi8027","committer":"pi8027","hash":"9952444a63dec63819dd0eb891ba4d178855eca6","message":"Add stability lemmas for `path.sort`\n\n- Inverse the comparison in `merge` and swap arguments of it everywhere.\n- Add `sort_rec1` and `sortE` to simplify inductive proofs on `sort`.\n- Add `seq.mask_filter`, `mem2E`, `path_mask`, `path_filter`, and `sorted_mask`.\n- Generalize `sorted_filter`, `homo_path_in`, `mono_path_in`, `homo_sorted_in`,\n  and `mono_sorted_in` to non-`eqType`s.\n- Add the following lemmas to state the stability of `path.merge` and `path.sort`.\n\nsorted_merge\n     : forall (T : Type) (leT : rel T),\n       transitive leT ->\n       forall s t : seq T, sorted leT (s ++ t) -> merge leT s t = s ++ t\n\nmerge_stable_path\n     : forall (T : Type) (leT leT' : rel T),\n       total leT ->\n       forall (x : T) (s1 s2 : seq T),\n       all (fun y : T => all (leT' y) s2) s1 ->\n       path [rel x0 y | leT x0 y && (leT y x0 ==> leT' x0 y)] x s1 ->\n       path [rel x0 y | leT x0 y && (leT y x0 ==> leT' x0 y)] x s2 ->\n       path [rel x0 y | leT x0 y && (leT y x0 ==> leT' x0 y)] x\n         (merge leT s1 s2)\n\nmerge_stable_sorted\n     : forall (T : Type) (leT leT' : rel T),\n       total leT ->\n       forall s1 s2 : seq T,\n       all (fun x : T => all (leT' x) s2) s1 ->\n       sorted [rel x y | leT x y && (leT y x ==> leT' x y)] s1 ->\n       sorted [rel x y | leT x y && (leT y x ==> leT' x y)] s2 ->\n       sorted [rel x y | leT x y && (leT y x ==> leT' x y)] (merge leT s1 s2)\n\nsorted_sort\n     : forall (T : Type) (leT : rel T),\n       transitive leT -> forall s : seq T, sorted leT s -> sort leT s = s\n\nsort_stable\n     : forall (T : Type) (leT leT' : rel T),\n       total leT -> transitive leT' ->\n       forall s : seq T,\n       sorted leT' s ->\n       sorted [rel x y | leT x y && (leT y x ==> leT' x y)] (sort leT s)\n\nfilter_sort\n     : forall (T : Type) (leT : rel T),\n       total leT -> transitive leT ->\n       forall (p : pred T) (s : seq T),\n       [seq x <- sort leT s | p x] = sort leT [seq x <- s | p x]\n\nmask_sort\n     : forall (T : Type) (leT : rel T),\n       total leT -> transitive leT ->\n       forall (s : seq T) (m : bitseq),\n       {m_s : bitseq | mask m_s (sort leT s) = sort leT (mask m s)}\n\nmask_sort'\n     : forall (T : Type) (leT : rel T),\n       total leT -> transitive leT ->\n       forall (s : seq T) (m : bitseq),\n       sorted leT (mask m s) ->\n       {m_s : bitseq | mask m_s (sort leT s) = mask m s}\n\nsubseq_sort\n     : forall (T : eqType) (leT : rel T),\n       total leT -> transitive leT -> {homo sort leT : t s / subseq t s}\n\nsubseq_sort'\n     : forall (T : eqType) (leT : rel T),\n       total leT -> transitive leT ->\n       forall t s : seq T, subseq t s -> sorted leT t -> subseq t (sort leT s)\n\nmem2_sort\n     : forall (T : eqType) (leT : rel T),\n       total leT -> transitive leT ->\n       forall (s : seq T) (x y : T),\n       leT x y -> mem2 s x y -> mem2 (sort leT s) x y","date":"2019-10-24T16:52:26Z"},{"author":"pi8027","committer":"pi8027","hash":"2d737d93dfaa929075885fc2f31fc8da491b670d","message":"Get the proper fix of `order_path_min` and remove `sort_map_in`","date":"2019-10-24T16:52:26Z"},{"author":"pi8027","committer":"pi8027","hash":"46b97156094cad886861e92278721dd7e9efde82","message":"Update documentation and CHANGELOG entries","date":"2019-10-24T16:53:10Z"}]}