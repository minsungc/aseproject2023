{"author":"pi8027","number":462,"diff_summary":[{"file":"mathcomp/ssreflect/order.v","status":"M","additions":79,"deletions":78}],"state":"closed","open_date":"2020-03-01T17:35:18Z","update_date":"2020-04-22T08:39:32Z","discussion":[{"author":"ggonthier","date":"2020-03-12T11:09:31Z","comment":"  This PR is meant to demonstrate that `Canonical Structures` can work with primitive records.\r\nThe demonstration is only partial because the `#[canonical(false)]` pragmas are syntax errors in all released versions of Coq - this could be easily remedied as these are non-essential optimisation of the `Canonical Projections` table. Also, this PR does not implement the intended application of the switch to primitive records - convertibility between order structures and their bidual.\r\n  Looking deeper into the matter, it seems that this works because the current version of Coq only partially implements eta-conversion for primitive records; it may not be prudent to sort relying on this.\r\n  Specifically, Coq implements eta-convertibility `p ~ (fst p, snd p)`, eta-expansion during unification (reduce `p ~ (a, b)` to `fst p ~ a`, `snd p ~ b`) but not pattern unification for records\r\n(solve `fst ?p ~ a` with `?p := (a, ?s)`). It's the latter that is at odds with `Canonical Structure` inference, since it is tantamount to _always_ resolving structures, as one would by declaring a default instance (as with, e.g., `Canonical Pack.`). This can result in unnatural behaviour and poor diagnostics for erroneous inputs, which are not tested by recompiling (error-free) libraries. It would also break more elaborate uses of `Canonical Structures` that rely on the failure of structure inference to force the expansion of tags or insert coercions (e.g., for `predType`).\r\n  Perhaps we can get some assurance that Coq will never implement unification patterns for records, but this seems unlikely. For one thing, this makes unification sensitive to eta-expansion: `?p ~ (0, 1)` succeeds, but `(fst ?p, snd ?p) ~ (0, 1)` reduces to `fst ?p ~ 0`, `snd ?p ~ 1`, which fail...\r\n  There are also differences in reduction strategy between classical and primitive records, namely that explicit `match` on records are iota-reduces eagerly, whereas primitive projections are not. The `xclass` idiom in packed classes relies on this to mitigate the exponential complexity of term comparison (the details are in the extensive log entry of the commit that introduces that idiom, but that's in the `CoqFinitGroup` svn repository, which has disappeared from `forge` - hopefully @gares still has a copy). The good news is that that particular idiom may no longer be needed if `class_of` objects are primitive records, because the type parameter of `class_of`, which is the cause of the divergent complexity, would be implicit.\r\n  Finally, the intended application does not seem all that compelling. In any concrete use of the order interface, the order structures will be explicit records that will be convertible to their bidual in all cases. This, the change would only improve facilitate writing library code for abstract orders. Further, there is a workaround even for this case, namely using primitive records for classes and some mixins, and parametrising the development that needs bidual convertibility on a manifest `Pack` of `Type` and `class_of` parameters, e.g.,\r\n  ``Context typeT classT (T := @Pack typeT classT).``\r\n  To summarize, perhaps the best course of action would be to switch to primitive records for `class_of` records only, _if_ this removes the need for `xclass`, but keep classical records for `Structures`, and use the idiom above if eta convertibility is needed.\r\n"},{"author":"pi8027","date":"2020-04-22T08:39:32Z","comment":"@ggonthier Thank you for the feedback. I finished what I planned here (`L^d^d = L`) in #464 by following your suggestions. I think that your comments are useful alongside my diff to understand the inference mechanism, in particular, the `xclass` idiom. So I close this PR and keep it for a record."},{"author":"CohenCyril","date":"2020-09-09T11:24:24Z","comment":"BTW, here is the designated commit log message:\r\n\r\n> Author: gonthier <gonthier@305884b8-be16-0410-aa53-a3be2363cef1>  2012-03-19 22:21:11\r\n>\r\n>     This revision was meant to be a local improvement to falgbra <-> galois, but\r\n>     it uncovered a major inefficiency of the processing of packed class declarations\r\n>     by the Coq kernel, which could only be mitigated by adjusting the packed class\r\n>     idiom.\r\n>       The problem arises from the interference of several questionable design\r\n>     choices in the Coq kernel, in particular the blind maximal sharing of\r\n>     \"reductions\" (which turn out to be full expansions here). The diagnosis was\r\n>     prompted by the anomalous behaviour of line 302 of galois.v, which took over 3\r\n>     minutes of user time to execute. This line attempts to use an eqP view on an\r\n>     assumption of the form root p x. This is convertible to p.[x] == 0, but the\r\n>     unfolding heuristic of Coq causes it to unfold the definition of (_ == _) in\r\n>     the eqP statement instead, only turning to Hy once it has reached a head normal\r\n>     form for the (_ == _), and thus having to unfold root p x to head normal form as\r\n>     well. Though unnecessary, by itself this should not be a problem, even though we\r\n>     are 9 levels deep in the hierarchy (eqType >-> fieldExtType). Things break down\r\n>     because the kernel cannot manage to compare the structurally identical terms\r\n>     that result from this expansion. These have the form\r\n>        let: Equality.Mixin op _ :=\r\n>          let: Choice.Class bc _ :=\r\n>            ....\r\n>            let: FieldExt.Class feb _ _ _ :=\r\n>              let: FieldExt.Pack _ fec _ := L return FieldExt.class_of L in fec\r\n>            in feb\r\n>            ...\r\n>          in bc\r\n>        in op.\r\n>     so the problem is not immediately obvious... until one recalls that\r\n>     non-dependent matches also carry explicit return type annotations. Thus the\r\n>     term is in fact\r\n>        let: Equality.Mixin op _  :=\r\n>          let: Choice.Class bc _\r\n>            ....\r\n>            let: FieldExt.Class feb _ _ _ :=\r\n>              let: FieldExt.Pack _ fec _ := L return FieldExt.class_of L in fec\r\n>            return Falgebra.class_of F0 (Phant F0) (FieldExt.sort L)\r\n>            in feb\r\n>            ...\r\n>          return Equality.class_of (Equality.sort Feq)) :=\r\n>          in bc\r\n>          return rel (Equality.sort Feq)\r\n>        in op.\r\n>     where Feq is the eqType structure that was passed explicitly to eq_op.\r\n>     Feq is the result of several type inference refinements, so is is not\r\n>     obtained directly as FieldExt.eqType F0 L, but rather as a composite\r\n>        Zmodule.eqType (Ring.zmodType\r\n>          (Lalgebra.ringType (Falgebra.vect_lalgType (FieldExt.FalgType L))))\r\n>     that evaluates ot the same normal form as FieldExt.eqType F0 L.\r\n>       If the comparison was based on this (slightly complicated) version of Feq\r\n>     there would be no problem. However, to arrive at the chain of lets above the\r\n>     Coq kernel has had to expand the definition of Feq -- and it then proceeds to\r\n>     share this expansion maximally across the entire expression. Feq is thus\r\n>     now a fairly large graph, where each of  Zmodule.eqType, Ring.zmodType, etc\r\n>     have been expanded, and the \"base\" coercions have been expanded: the class\r\n>     components are subterms of the top \"let:\" chain, e.g., the class component\r\n>     of Feq is the let: Choice.class ... subterm. As the kernel \"optimizes\" the\r\n>     comparison of Equality.sort (Equality.Pack <monster record>)\r\n>                    =  Equality.sort (Equality.Pack <monster record>)\r\n>     by not evaluating the projection and comparing all the <monster record>\r\n>     rather that just the sort field, does so by expanding the (shared) term graph\r\n>     into an (unshared) tree, and these type constraints occur everywhere inside the\r\n>     let: chain (including in the invisible lambda binders of the predicates and\r\n>     branch subterms), the diverging behavior is unsurprising.\r\n>       Note that it is the kernel that diverges here: evarconv unification has\r\n>     absolutely no problem here, because it uses a different heuristic which does\r\n>     not allow sharing to interfere with comparison; indeed, it backtracks over\r\n>     the reduction of the argument of a blocked match, effectively allowing the\r\n>     expansion to \"align\" on the topmost match, without having to expose the others.\r\n>       Our partial workaround to this conundrum is to replace, as much as possible,\r\n>     unexpanded projections like Equality.sort with exposed matches. This causes the\r\n>     kernel to evaluate the projection when it propagates an expanded value for the\r\n>     record, rather than going into the op-described tailspin. The workaround is\r\n>     only partial because some explicit constants must remain to let unification find\r\n>     canonical instances, e.g., the Choice.sort field of Choice.eqType, though\r\n>     fortunately (in this case) evaluation makes most of these vanish. Alas, the\r\n>     largest instance (the Equality.sort _)cannot be made to simplify in this way:\r\n>     it is needed for Canonical Structure unification of, say (x \\in pred1 y) with\r\n>     x and y in a finType, with ?x == ?y. The problem here is that evarconv unifies\r\n>     left to right in the Coq v5-7 term order, where the predicate came before the\r\n>     match (the called \"case\") statement, so it has to infer the eqType for ?x and ?y\r\n>     on the basis of the let: return type.\r\n>       In practice, this means that the packed class idiom gets two extra lines\r\n>      Let xT := let: Pack T _ _ := cT in T.\r\n>      Notation xclass := (class : class_of xT).\r\n>     and that the various canonical \"inheritance\" instances should now use\r\n>     an explicit cT value for the sort, xclass for the class, and xT for the tag,\r\n>     e.g.,\r\n>       Definition zmodType := @Zmodule.Pack cT xclass xT.\r\n>     The fix seems reasonably effective in spite of these shrotcomings: time for\r\n>     line 302 in galois drops from 167s to 1s user time, which is more acceptable\r\n>     (but still 2 to 3 orders of magnitude too slow!).\r\n>     \r\n>     Other changes in this revision:\r\n>       - \"Lagrange\" spelling corrected\r\n>       - the Falgebra interface now contains the UnitRing interface (as an Falgebra\r\n>         always has a unitRingType structure -- there is a lemma proving this).\r\n>       - based fieldExtType on Falgebra rather than Field, as this allows all mixins\r\n>         to be in Prop.\r\n>       - added construction of simple field extension from an irreducible polynomial,\r\n>         used it to remove the separability condition in the proof that splitting\r\n>         fields are normal.\r\n>     \r\n>     \r\n>     \r\n>     git-svn-id: svn+ssh://scm.gforge.inria.fr/svn/coqfinitgroup/trunk@3751 305884b8-be16-0410-aa53-a3be2363cef1"},{"author":"CohenCyril","date":"2020-09-09T11:37:14Z","comment":"https://gist.github.com/CohenCyril/c2c7d87c9677ea757a5b67d56a985fb8#file-this-revision-was-meant-to-be-a-local-improvement-to.patch"}],"review_discussion":[],"tags":[],"commits":[{"author":"pi8027","committer":"pi8027","hash":"d4c8b95689da23a8014658604325c911ab9430f3","message":"Using primitive records with packed classes in order.v","date":"2020-03-01T17:31:01Z"}]}