{"author":"CohenCyril","number":558,"diff_summary":[{"file":"CHANGELOG_UNRELEASED.md","status":"M","additions":58,"deletions":0},{"file":"mathcomp/ssreflect/seq.v","status":"M","additions":58,"deletions":0}],"state":"merged","open_date":"2020-09-01T11:20:43Z","update_date":"2020-09-03T13:52:43Z","discussion":[{"author":"CohenCyril","date":"2020-09-01T11:22:12Z","comment":"@gares, @pi8027, @strub can one of you assign themselves?"},{"author":"gares","date":"2020-09-01T11:51:39Z","comment":"It looks ok to me, but I'm not in love with the `are_` part of the name. Is it similar to something already existing?"},{"author":"chdoc","date":"2020-09-01T12:37:24Z","comment":"Also, is it useful to have `T : nonPropType` rather than `T : eqType` while requiring `r : rel T` to be a boolean relation? I mean, the proof of `are_allpairs_cons` is nifty, but I would have expected a simpler proof based in `are_allpairsP`. "},{"author":"CohenCyril","date":"2020-09-01T12:43:31Z","comment":"> Also, is it useful to have `T : nonPropType` rather than `T : eqType` while requiring `r : rel T` to be a boolean relation? I mean, the proof of `are_allpairs_cons` is nifty, but I would have expected a simpler proof based in `are_allpairsP`.\r\n\r\nIt may happen that a relation is decidable even on some non discrete types (e.g. a pair of an ordered type with a no discrete type), and I would like to preserve the full generality of the theorem on such occurences."},{"author":"CohenCyril","date":"2020-09-01T12:45:32Z","comment":"> It looks ok to me, but I'm not in love with the `are_` part of the name. Is it similar to something already existing?\r\n\r\nI went back and forth a lot in the naming: the working name was the ugly `all11` (hence the 80 character overflow caused by sed)...\r\nI am open to suggestions on the naming but I was pretty happy with this one being meaningful (\"Are all pairs satisfying r on s?\") and exposing the implementation using `allpairs` in the name itself.."},{"author":"CohenCyril","date":"2020-09-01T12:46:47Z","comment":"Actually I would have gone for `is` except `are` is grammatically more accurate (since it is about a relation, not a predicate)."},{"author":"chdoc","date":"2020-09-01T13:06:19Z","comment":"Well, the predicate states that \"all pairs of `s` are _in_ the relation `r`\" (using the usual mathematical speak of relations as sets/predicates). So how about `allpairs_in r s`? For this one even the partial application `allpairs_in r` seems reasonable to me. Unfortunately `in` is used differently elsewhere. "},{"author":"chdoc","date":"2020-09-01T13:58:46Z","comment":"In any event, `are_allpairs r s` is a proposition not a question. So even `allpairs_are r s` (\"all pairs _are_ r(-related)\") seems preferable to me."},{"author":"gares","date":"2020-09-01T14:07:38Z","comment":"> So even `allpairs_are r s` (\"all pairs _are_ r(-related)\") seems preferable to me.\r\n\r\n+1\r\n\r\nTo me the thing is messy because `allpairs` does not really build pairs but steals the name. If we had a `pairs` thing that builds the sequence of all pairs, we could use allpairs for your new concept, eg `allpairs r xs := all (fixup r) (pairs xs xs)`."},{"author":"chdoc","date":"2020-09-01T14:27:59Z","comment":"> To me the thing is messy because `allpairs` does not really build pairs but steals the name.\r\n\r\nWhile the string \"allpairs\" appears in a considerable number of of lemmas, the definition `allpairs` seems to be virtually unused, because `allpairs` is (almost) always inlined. The only lemma about `allpairs` in `ssreflect` and `algebra` appears to be `allpairs_tupleP`. :thinking: "},{"author":"CohenCyril","date":"2020-09-01T21:28:55Z","comment":"> > To me the thing is messy because `allpairs` does not really build pairs but steals the name.\r\n> \r\n> While the string \"allpairs\" appears in a considerable number of of lemmas, the definition `allpairs` seems to be virtually unused, because `allpairs` is (almost) always inlined. The only lemma about `allpairs` in `ssreflect` and `algebra` appears to be `allpairs_tupleP`.\r\n\r\n`allpairs` actually immediately unfolds to the idiom `[seq f x y | x <- s, y <- t x]` which gives its name to the lemmas, and it is a rather historic convention (the self-expanding definition is newer as far as I remember). Moreover it indeed does not form pairs but applies a function symbol `f` to them (and this function symbol can be dependent), sometimes it's a `pair`, sometimes a `sigT` and sometimes something else, so it makes it more flexible to let `f` variable.\r\n\r\nI'm all in favor of `allpairs_are`anyway!\r\n\r\n"},{"author":"gares","date":"2020-09-02T07:51:10Z","comment":"I saw that, allpairs maps a function overs all the pairs, which could be named, to me, map_allpairs. Anyway, I'm OK with the renaming proposed by @chdoc "},{"author":"CohenCyril","date":"2020-09-02T10:07:39Z","comment":"I fixed the names, made the proof shorter and more readable and introduced the `mkseqP` idiom."},{"author":"CohenCyril","date":"2020-09-02T11:48:13Z","comment":"I have a new name suggestion: how about `allrel`?\r\nPros:\r\n- stands for \"all related\"\r\n- has `rel` and `all` in the name (and no more)\r\n- shorter\r\n"},{"author":"chdoc","date":"2020-09-02T11:50:41Z","comment":"> I have a new name suggestion: how about `allrel`?\r\n\r\nI approve, in particular because it avoids the `_`, leading to nicer lemma names. "},{"author":"CohenCyril","date":"2020-09-03T13:13:21Z","comment":"@gares all good?"}],"review_discussion":[{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2020-09-01T12:25:08Z","comment":"I agree with @gares in not being happy with this name."},{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2020-09-01T12:27:42Z","comment":"The more natural generalization would probably be `_.+1` rather than `size xs`"},{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2020-09-01T12:28:59Z","comment":"This line has 83 characters, I suggest splitting it at the semicolon :grin: "},{"author":"gares","file":"mathcomp/ssreflect/seq.v","date":"2020-09-01T12:36:34Z","comment":"@CohenCyril probably took my vscode configuration..."},{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2020-09-02T11:33:06Z","comment":"Do you think that generating the `s = [::]` case, which reappears a as a subcase of the `s = mkseq f n` case, is preferable to requiring some `x0 : T`? If so, maybe replace `mkseq f n` with `mkseq f n.+1`, do avoid the case duplication?"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-09-02T11:39:19Z","comment":"Actually, no I'm not sure... and having `n` looks dangerous `(iota 0 n.+1)` might expand and the point of `mkseqP` was to abstract away these... Maybe I will switch to requiring `x0` here..."},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-09-02T11:47:51Z","comment":"@chdoc looks better now I think"},{"author":"chdoc","file":"CHANGELOG_UNRELEASED.md","date":"2020-09-02T12:09:10Z","comment":"which asserts _that_ / asserting _that_"}],"tags":[],"commits":[{"author":"CohenCyril","committer":"CohenCyril","hash":"b81aa92716bcd19fa364911f5efaf5d0155d9376","message":"Adding allrel predicate","date":"2020-09-03T12:16:33Z"}]}