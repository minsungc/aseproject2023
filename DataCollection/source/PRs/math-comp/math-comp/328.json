{"author":"ybertot","number":328,"diff_summary":[{"file":"CHANGELOG_UNRELEASED.md","status":"M","additions":281,"deletions":90},{"file":"mathcomp/algebra/intdiv.v","status":"M","additions":281,"deletions":90},{"file":"mathcomp/solvable/abelian.v","status":"M","additions":281,"deletions":90},{"file":"mathcomp/ssreflect/path.v","status":"M","additions":281,"deletions":90}],"state":"closed","open_date":"2019-04-12T15:10:08Z","update_date":"2019-10-25T07:46:35Z","discussion":[{"author":"CohenCyril","date":"2019-04-16T11:12:42Z","comment":"@ybertot can you squash everything in one single commit and force push.\r\nAlso, the CI was not triggered I am wondering why... perhaps force-pushing will trigger it again?"},{"author":"CohenCyril","date":"2019-04-16T11:55:59Z","comment":"The CI is runnnig on gitlab, but there is no display here... @erikmd would you know why?"},{"author":"ggonthier","date":"2019-04-16T12:50:34Z","comment":"I'm not sure I agree entirely with the basic motivation for this PR: there's little sense in a formal proof library, in providing algorithms stripped of their definitional properties, i.e., in this case providing a function that purports to sort a sequence but leave the user of the library to his own devices when it comes to show that the sorted sequence contains the same items as the initial one, and is not some arbitrary sorted sequence of the same length. The only plausible use case I can come up for this is reflection decision procedures, where sorting is used for performance or the result is checked after interpretation; I have a hard time believing that this would be useful for parametricity and extraction, in this particular case, because the quaint sorting algorithm defined here is hardly high-performance...\r\n   Thus because permutation is quite unwieldy to characterise without the `perm_eq` predicate and its theory, I'd just given up on defining sorting on non-`eqType` sequences. That said, there is a decent way out of this through parametricity: on can and _should_ prove the \"free\" parametric lemmas\r\n```\r\nmerge_map f s1 s2 : merge leT (map f s1) (map f s2) = map f (merge leTf s1 s2)\r\nsort_map f s : sort leT (map f s) = map f (sort leTf s)\r\nsorted_map f s : sorted leT (map f s) = sorted leTf s\r\n```\r\nwhere `leTf := [rel x y | leT (f x) (f y)].`\r\n   Then permutation can be characterised via the `mkseq_nth` lemma:\r\n```\r\nperm_iota_sort x0 leT s : {i_s | perm_eq i_s (iota 0 (size s)) & sort leT s = map (nth x0 s) i_s}\r\n```\r\nwhich is proved by taking `i_s := sort [rel i j | leT (nth x0 s i) (nth x0 s j)]`. This lemma can also be used\r\nto derive `size_sort` rather than prove it from scratch.\r\n"},{"author":"ggonthier","date":"2019-04-16T13:07:40Z","comment":"   While you are looking into `sort`, perhaps you could try to address stability. If you look closely you might notice that `merge` shuffles in a somewhat strange order, so as to ensure that `sort` is actually stable. It would make sense to exchange the arguments of `merge` to get a more natural definition, and actually _prove_ stability properties. I've put a plural because I can think of four ways of characterising stability, and think perhaps we should provide all:\r\n```\r\nHypothesis leT_tr : transitive leT.\r\nmem2_sort s x y : mem2 s x y -> leT x y -> mem2 (sort leT s) x y\r\nsubseq_sort t s : subseq t s -> sorted leT t -> subseq t (sort leT s).\r\nmask_sort m s : sorted leT (mask m s) -> {m_s | mask m_s (sort leT s) = mask m s}.\r\nsort_stable leT1 s : sorted leT1 s -> sorted [rel x y | leT x y && (leT y x ==> leT1 x y)] (sort leT s).\r\n```\r\nDo note that the first two require an `eqType` to be stated. I'd lean towards showing the second one first, then deriving the three others as either special cases and/or parametricity.\r\nAddendum: showing `sort_stable` requires `leT` being total (as it implies sort_sorted!), and `leT1` being transitive."},{"author":"CohenCyril","date":"2019-04-16T13:36:13Z","comment":"> I have a hard time believing that this would be useful for parametricity\r\n\r\nThe automatic parametricity translation of `sort` involves translations of `eqType`, making its statement very involved. The initial motivation of @ybertot was to make sure the algorithm does not rely on unnecessary structures. After I asked to extend the theory too, to some extent. That said, I see your point now.\r\n\r\nIf I understand correctly, you would be ok with the algorithms relying on `Type` but the theorems should all require a `eqType` and the user who wants to be on a bare `Type` would use `perm_iota_sort`...\r\n(PS: And we provide the same ones that I asked @ybertot to generalize, but using your trick when it gets ugly. BTW except for `size_sort` the generalizations were rather trivial...)\r\n\r\nBesides stability, I had also the intention to provide these:\r\n```coq\r\n(* on Type *)\r\nLemma homo_sorted f s : {homo f : x y / leT x y >-> leT' x y} ->\r\n  sorted leT s -> sorted leT' [seq f x | x <- s].\r\n\r\n(* on Type *)\r\nLemma mono_sorted f s : {mono f : x y / leT x y >-> leT' x y} ->\r\n  sorted leT' [seq f x | x <- s] = sorted leT s.\r\n\r\n(* on eqType *)\r\nLemma homo_sorted_in f s : {in s &, {homo f : x y / leT x y >-> leT' x y}} ->\r\n  sorted leT s -> sorted leT' [seq f x | x <- s].\r\n\r\n(* on eqType *)\r\nLemma mono_sorted_in f s : {in s &, {mono f : x y / leT x y >-> leT' x y}} ->\r\n  sorted leT' [seq f x | x <- s] = sorted leT s.\r\n\r\n(* on eqType *)\r\nLemma homo_sort_map_in f s : {in s &, {homo f : x y / leT x y >-> leT' x y}} ->\r\n  sort leT' [seq f x | x <- s] = [seq f x | x <- sort leT s].\r\n```\r\nafter @ybertot has finished. (And I believe the last one would indeed require stability to reduce the number of hypothesis, and your trick to get it on `Type` without the `in`)"},{"author":"CohenCyril","date":"2019-04-16T13:46:01Z","comment":"@ybertot please tell me if you want to go through with @ggonthier's recommendations or if you prefer that I do it. "},{"author":"ybertot","date":"2019-04-16T14:37:37Z","comment":"Sorry, I was in a meeting all afternoon."},{"author":"ybertot","date":"2019-04-16T18:45:23Z","comment":"I think sorted_map is not provable with this statement: counter example: `f x = 0`, `leT = leq`"},{"author":"ybertot","date":"2019-04-16T18:46:40Z","comment":"Sorry, not a counterexample."},{"author":"ybertot","date":"2019-04-17T06:15:09Z","comment":"This comment follows commit https://github.com/math-comp/math-comp/pull/328/commits/73dd3cae8098dc38be0dc999b067aab1a3fecffd\r\n\r\nThere is one unsatisfactory feature:  the definition leTf, which I took directly from @ggonthier's post (like all the rest) but should probably have a better name.\r\nI don't plan to work on the stability lemmas."},{"author":"CohenCyril","date":"2019-04-17T07:13:40Z","comment":"> There is one unsatisfactory feature: the definition leTf, which I took directly from @ggonthier's post (like all the rest) but should probably have a better name.\r\n\r\nI believe @ggonthier intended this definition to be local (i.e. either as a `Let` or as a `let`, or even a `leTf := ...` in the local context before `:` in the statement).\r\n\r\nI guess my reply was not clear, I would personally prefer `leT` and `leT'` together with `{homo f : x y / leT x y >-> leT' x y}` and the variant with `{mono f : x y / leT x y >-> leT' x y}` which cover the case of `leTf`...  and I need these general parmetricity theorem for some other development I am currently doing (e.g. to prove `[seq - x | x <- s]` is reverse sorted because `GRing.opp` is decreasing).\r\n\r\n\r\n\r\n> I don't plan to work on the stability lemmas.\r\n\r\nI can do it after this PR is merged"},{"author":"ggonthier","date":"2019-04-17T09:00:32Z","comment":"Short remarks:\r\n  - I indended leTf to be a `Let`, not a `Definition`, hence the short name (and no documentation requirement). If it were a definition it would have to be in `ssrbool` (relation preimage, alongside predicate preimage), but the latter is no longer part of MathComp.\r\n  - `order_path_min` should really have `x` and `s` as maximal implicits, as should most lemmas that can be used as views and have totally polymorphic arguments.\r\n  - The precondition for `path_min_sorted` could be stated with `all` rather than `{in ...}`; this would make it possible to prove the lemma in the non-`eqType` section, alongside `order_path_min`. You'll have to insert an instance of `apply/allP` where it is used however (once, in `intdiv`).\r\n  - @CohenCyril, you can add your homomorphism lemmas later, but I don't think they're a substitute  for `sort_map` and `sorted_map`, as they can't be used casually as rewrite rules."},{"author":"CohenCyril","date":"2019-04-17T09:11:03Z","comment":"> * @CohenCyril, you can add your homomorphism lemmas later, but I don't think they're a substitute  for `sort_map` and `sorted_map`, as they can't be used casually as rewrite rules.\r\n\r\nI agree that they cannot be a substitute, but from them one can deduce `sort_map` and `sorted_map` as special cases (of the `{mono ...}` lemmas).\r\n\r\n~EDIT: or vice versa... I guess~"},{"author":"CohenCyril","date":"2019-04-17T09:13:48Z","comment":"> * The precondition for `path_min_sorted` could be stated with `all` rather than `{in ...}`; this would make it possible to prove the lemma in the non-`eqType` section, alongside `order_path_min`. You'll have to insert an instance of `apply/allP` where it is used however (once, in `intdiv`).\r\n\r\n@ggonthier This would make the patch non backward compatible but desirable... should we have this theorem under a new name, or should we target 1.9.0 instead?"},{"author":"ggonthier","date":"2019-04-17T09:20:06Z","comment":"I suggest `path_min_sorted` and `order_path_min` should be kept together. Just generalising the latter is going to be backward incompatible (this PR has a patch in `abelian`!), but in a minor way. I thought this was for 1.9 anyway (it's not patching any bugs, right?)"},{"author":"CohenCyril","date":"2019-04-17T09:30:12Z","comment":"@ggonthier 1.8.1 may contain backward compatible addition...\r\nI did not notice that it broke `abelian.v` anyway!\r\nSo yes let's go nuts, do the full changes and target 1.9.0 instead.\r\nWas there a reason why `size_merge`'s RHS was `size (s1 ++ s2)` rather than `size s1 + size s2` or could we change that as well?"},{"author":"ggonthier","date":"2019-04-17T09:39:09Z","comment":"`lemma_overloading` seems broken as well... (though giving `path_order_min` maximal implicit may solve this.\r\nI'm not sure why I preferred not to simplify the RHS of `size_merge`, other than consistency with `perm_merge` and `merge_uniq`. One reason, though, would be to avoid unwanted simplification if `s2` is an explicit cons, and make it easier to use `map_cat` and similar."},{"author":"pi8027","date":"2019-04-23T12:19:41Z","comment":"@ybertot @CohenCyril \r\n\r\n>> I don't plan to work on the stability lemmas.\r\n>\r\n> I can do it after this PR is merged\r\n\r\nI can provide the stability lemmas too if needed because I did it for a more complicated sorting algorithm based on push/pop mechanism. I guess that stability proofs for this algorithm are relatively easy."},{"author":"CohenCyril","date":"2019-04-23T15:49:50Z","comment":"Just for the record, I wish the following lemmas to be integrated in 1.9.0 whether in this PR or another:\r\n```coq\r\nSection HomoSortSeq.\r\nVariables (T T' : Type) (leT : rel T) (leT' : rel T') (f : T -> T').\r\n\r\nLemma homo_sorted : {homo f : x y / leT x y >-> leT' x y} ->\r\n  {homo map f : s / sorted leT s >-> sorted leT' s}.\r\nProof. by move=> /homo_path f_path [|//= x s]. Qed.\r\n\r\nSection Mono.\r\nHypothesis f_mono : {mono f : x y / leT x y >-> leT' x y}.\r\n\r\nLemma mono_sorted : {mono map f : s / sorted leT s >-> sorted leT' s}.\r\nProof. by case=> //= x s; rewrite (mono_path f_mono). Qed.\r\n\r\nLemma map_merge : {morph map f : s1 s2 / merge leT s1 s2 >-> merge leT' s1 s2}.\r\nProof.\r\nelim=> //= x s1 IHs1; elim => [|y s2 IHs2] //=; rewrite f_mono.\r\nby case: leT; rewrite /= ?IHs1 ?IHs2.\r\nQed.\r\n\r\nLemma map_sort : {morph map f : s1 / sort leT s1 >-> sort leT' s1}.\r\nProof.\r\nhave map_pop s1 ss : map f (merge_sort_pop leT s1 ss) =\r\n                     merge_sort_pop leT' (map f s1) (map (map f) ss).\r\n  by elim: ss s1 => //= x ss IHss s1; rewrite IHss map_merge.\r\nhave map_push s1 ss : map (map f) (merge_sort_push leT s1 ss) =\r\n                     merge_sort_push leT' (map f s1) (map (map f) ss).\r\n  by elim: ss s1 => [|[|y s2] ss IHss s1]//=; rewrite IHss map_merge.\r\nmove=> s; rewrite /sort -[[::] in RHS]/(map (map f) [::]).\r\nelim: {s}_.+1 {-2}s [::] (ltnSn (size s)) => // n IHn s ss.\r\ncase: s => [|x [|y s]]/=; rewrite ?map_pop//=.\r\nby move=> /ltnW s_small; rewrite IHn ?map_push// f_mono//; case: leT.\r\nQed.\r\n\r\nEnd Mono.\r\n\r\nEnd HomoSortSeq.\r\n\r\nArguments homo_sorted {T T' leT leT'}.\r\nArguments mono_sorted {T T' leT leT'}.\r\nArguments map_merge {T T' leT leT'}.\r\nArguments map_sort {T T' leT leT'}.\r\n```"},{"author":"ybertot","date":"2019-05-29T13:41:35Z","comment":"I have no time to work on this PR currently, please proceed without me."},{"author":"CohenCyril","date":"2019-05-29T13:42:53Z","comment":"> I have no time to work on this PR currently, please proceed without me.\r\n\r\nI will take ownership of this PR and do the some changes so that it gets integrated. Further changes can come later."},{"author":"CohenCyril","date":"2019-05-29T17:41:48Z","comment":"I will let @pi8027 prove stability (cf https://github.com/math-comp/math-comp/pull/328#issuecomment-485778757) in another PR."},{"author":"CohenCyril","date":"2019-05-31T13:25:17Z","comment":"@ggonthier could we merge this one and let @pi8027 do the stability proofs in a subsequent PR?"},{"author":"pi8027","date":"2019-06-11T09:01:26Z","comment":"I have proved the stability lemmas. https://github.com/pi8027/math-comp/tree/more-abstract-sort-april-19"},{"author":"CohenCyril","date":"2019-06-12T17:19:42Z","comment":"> I have proved the stability lemmas. https://github.com/pi8027/math-comp/tree/more-abstract-sort-april-19\r\n\r\n@pi8027 please open a new PR."},{"author":"amahboubi","date":"2019-10-24T12:47:24Z","comment":"@CohenCyril @pi8027 It would be great to write a comment here clarifying the status of this PR with respect to #358 "},{"author":"CohenCyril","date":"2019-10-25T07:48:53Z","comment":"> @CohenCyril @pi8027 It would be great to write a comment here clarifying the status of this PR with respect to #358\r\n\r\nThis PR was subsumed by #358, so it is now closed."}],"review_discussion":[{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2019-04-12T17:59:59Z","comment":"Please, rename section `SortSeq`"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2019-04-12T18:00:46Z","comment":"Please merge with the previous `Variable` (and hence use `Variables`)"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2019-04-12T18:06:16Z","comment":"While you are at it, you could add to this section everything else that does not depend on `T` being an `eqType`, so at least:\r\n- `sorted` and `path_sorted`,\r\n- and under `Hypothesis leT_total : ...`, put also `merge_path`, `merge_sorted` and `sort_sorted`, and just after the end of the section `rev_sorted` (because the relation changes).\r\n\r\nAdditionally, you could also try to put `order_path_min`, `sorted_filter`, `size_merge` and `size_sort`  that have a fake dependency in `T` being discrete."},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2019-04-12T18:06:47Z","comment":"You could merge these two `Variable` commands."},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2019-04-12T18:06:59Z","comment":"Please rename to (e.g.) `EqSortSeq`."},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2019-04-12T18:13:03Z","comment":"Keep only `merge`, `sort` and `sorted` (when it is here) and remove empty lines from inbetween `Local Notation` commands."},{"author":"ybertot","file":"mathcomp/ssreflect/path.v","date":"2019-04-12T18:49:01Z","comment":"So \"abstract_sort -> SortSeq\"  and \"SortSeq -> EqSortSeq\" right?\r\nThe rest seems clear."},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2019-04-12T18:50:40Z","comment":"yes"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2019-04-16T09:00:11Z","comment":"In order for this PR to be merged in 1.8.1 (should this release exist), the statement of `size_merge` should not change, so we might want to keep `size (s1 ++ s2)` and you could submit a new PR to change the RHS to `size s1 + size s2`.\r\n\r\nAlso @ggonthier  recommends to document the introduced variables (instead of using `?`), so I took the liberty to refactor it a little bit. (And we should document this style in CONTRIBUTING.md)\r\n```coq\r\nLemma size_merge s1 s2 : size (merge s1 s2) = size (s1 ++ s2).\r\nProof.\r\nrewrite size_cat; elim: s1 s2 => // x s1 IHs1; elim => //= y s2 IHs2.\r\nby case: leT; rewrite /= ?IHs1 ?IHs2.\r\nQed.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2019-04-16T09:00:57Z","comment":"Nice proof, I suggest the following refactoring:\r\n```coq\r\nLocal Notation sum_size ss := (sumn (map size ss)).\r\nLemma size_sort s : size (sort s) = size s.\r\nProof.\r\nhave size_pop r ss : size (merge_sort_pop r ss) = size r + sum_size ss.\r\n  by elim: ss => // s2 ss IHs in r *; rewrite IHs size_merge size_cat addnA.\r\nhave size_push r ss : sum_size (merge_sort_push r ss) = size r + sum_size ss.\r\n  elim: ss => [|[|x s'] ss IHss]/= in r *; rewrite ?(addn0, add0n)//.\r\n  by rewrite IHss size_merge ?size_cat/= !addnS addnA.\r\nsuff -> ss: size (merge_sort_rec ss s) = sum_size ss + size s by [].\r\nelim: {s}_.+1 {-2}s ss (ltnSn (size s)) => // n IHn.\r\ncase=> [|x [|/= y s]] ss; rewrite ?size_pop ?(addn0, addnS)//.\r\nby move=> /ltnW s_small; rewrite IHn// size_push; case: ifP.\r\nQed.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2019-04-16T09:10:12Z","comment":"As I can tell thanks to the CI, you accidentally deleted this very important lemma which should be restored in `EqSortSeq`."},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2019-04-16T09:26:13Z","comment":"Could you remove all local notations besides `merge`, `sort` and `sorted` (the ones that appear in the statements)."},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2019-04-16T09:27:01Z","comment":"`rev_sorted` should be moved at the end of section `EqSortSeq` and generalized"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2019-04-16T12:07:31Z","comment":"This hypothesis comes too early, it is more informative to put it juste before `merge_path`"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2019-04-16T12:08:09Z","comment":"there is one unnecessary space here."},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2019-04-16T12:12:29Z","comment":"`order_path_min` should also be generalized (cf https://github.com/math-comp/math-comp/pull/328#discussion_r275010699) and put here, here is the corrected proof:\r\n```coq\r\nHypothesis leT_tr : transitive leT.\r\n\r\nLemma order_path_min x s : path leT x s -> all (leT x) s.\r\nProof.\r\nelim: s => //= y [//|z s] ihs /andP[xy yz]; rewrite xy {}ihs//.\r\nby move: yz => /= /andP[/(leT_tr _)->].\r\nQed.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2019-04-16T12:14:24Z","comment":"The section hypothesis `leT_total : total leT.` can be moved just before `perm_sort` "},{"author":"ggonthier","file":"mathcomp/ssreflect/path.v","date":"2019-06-03T09:37:43Z","comment":"If we're going to document the stability of `sort` and `merge`, it would be better to inverse this comparison (`leT x1 x2`), i.e., put items of `s1` before non-greater items of `s2` in the merged sequence. This requires swapping `s1` and `s2` in `merge_sort_push` and `merge_sort_pop` below, and slightly adapting the sorting proof for `merge`."},{"author":"ggonthier","file":"mathcomp/ssreflect/path.v","date":"2019-06-03T09:40:57Z","comment":"Eta expanding `(leT x)` into `[pred y | leT x y]` merely adds `simpl` overhead."},{"author":"ggonthier","file":"mathcomp/solvable/abelian.v","date":"2019-06-03T09:45:12Z","comment":"This fix can be avoided by declaring the right `Arguments` (see below)."},{"author":"ggonthier","file":"mathcomp/ssreflect/path.v","date":"2019-06-03T10:09:14Z","comment":"The rest of the library doesn't eta-expand generic instances of `map`, as this can lead to unwanted expansion of function operators (e.g., `f \\o g`). I do realise the Coq printer now eta-expands on display, but hopefully we'll eventually get some way to disable that behaviour when it's undesirable (as it is for `map`, `filter`, `image`, `codom`, ...)."},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2019-06-05T20:53:15Z","comment":"@ggonthier I have started stability proofs with following your suggestions. However, swapping `s1` and `s2` in `merge_sort_push` causes many undesirable unfolding of `merge` by `/=`. \r\n```coq\r\nFixpoint merge_sort_push s1 ss :=\r\n  match ss with\r\n  | [::] :: ss' | [::] as ss' => s1 :: ss'\r\n  | s2 :: ss' => [::] :: merge_sort_push (merge s2 s1) ss' (* `merge s2 s1` does pattern-matching on `s2` first *)\r\n  end.\r\n```"},{"author":"ggonthier","file":"mathcomp/ssreflect/path.v","date":"2019-06-06T08:05:32Z","comment":"You can always add and `Arguments` declaration so that `merge` does not simplify unless _both_ its arguments expose constructors. That said, because `merge` has an inner loop (to ensure structural recursion), some of the unfoldings will always be unwieldy - I guess you could tidy up by defining `merge_left` and `merge_right` mutually recursive functions (of type `T -> seq T -> seq T -> seq T`), but it makes little difference to the local proof, and I'm not sure of the value of adding two additional definitions in the library just for this sake."},{"author":"ggonthier","file":"mathcomp/ssreflect/path.v","date":"2019-06-06T09:50:20Z","comment":"  Also, if you're looking into this, some of my indications for required premises are wrong, and it looks like the basic lemma one wants to show is one about lexicographic order. Here's my second take at it, including some tentative additions to `ssrbool` and `seq`:\r\n```\r\nSection BoolRel.\r\n\r\nContext {T : Type}.\r\n\r\nDefinition relV (r : rel T) := [rel x y | r y x].\r\n\r\nDefinition relC (r : rel T) := [rel x y | ~~ r x y].\r\n\r\nDefinition relI (r1 r2 : rel T) := [rel x y | r1 x y && r2 x y].\r\n\r\nDefinition condrel (r1 r2 : rel T) := [rel x y | r1 x y ==> r2 x y].\r\n\r\nDefinition optrel (r : rel T) := [rel x y | oapp (oapp r xpredT x) false y].\r\n\r\nDefinition lexrel (r1 r2 : rel T) := [rel x y | r1 x y && (r1 y x ==> r2 x y)].\r\n\r\nLemma lexrel_trans r1 r2 :\r\n  transitive r1 -> transitive r2 -> transitive (lexrel r1 r2).\r\nProof.\r\nmove=> r1tr r2tr y x z /andP[le1xy /implyP-le2xy] /andP[le1yz /implyP-le2yz] /=.\r\nrewrite (r1tr y) //; apply/implyP=> r1zx.\r\nby apply/(r2tr y); [apply/le2xy/(r1tr z) | apply/le2yz/(r1tr x)].\r\nQed.\r\n\r\nLemma lexrel_total r1 r2 : total r1 -> total r2 -> total (lexrel r1 r2).\r\nProof.\r\nmove=> r1T r2T x y; move: (r1T x y) (r2T x y); rewrite /total /=.\r\nby do 2!case: (r1).\r\nQed.\r\n\r\nEnd BoolRel.\r\n\r\nArguments nilp {T} s.\r\n\r\nSection SeqRel.\r\n\r\nContext {T : Type}.\r\n\r\nDefinition allrel (r : rel T) s t := all (fun x => all (r x) t) s.\r\n\r\nDefinition hasrel (r : rel T) s t := has (fun x => has (r x) t) s.\r\n\r\nLemma allrelC r s t : allrel (relC r) s t = ~~ hasrel r s t.\r\nProof. by rewrite -all_predC; apply/eq_all=> x; rewrite all_predC. Qed.\r\n\r\nLemma hasrelC r s t : hasrel (relC r) s t = ~~ allrel r s t.\r\nProof. by rewrite -has_predC; apply/eq_has=> x; rewrite has_predC. Qed.\r\n\r\nLemma allrelV r s t : allrel (relV r) t s = allrel r s t.\r\nProof.\r\nby elim: t => /= [|y t ->]; rewrite ?[RHS]all_predT // -all_predI; apply/eq_all.\r\nQed.\r\n\r\nLemma hasrelV r s t : hasrel (relV r) t s = hasrel r s t.\r\nProof. by apply/negb_inj; rewrite -!allrelC allrelV. Qed.\r\n\r\nLemma allrel_trans r: transitive r -> {in predC nilp, transitive (allrel r)}.\r\nProof.\r\nmove=> r_tr [|y t] //= _ s u rst /andP[ryu _].\r\nby apply: sub_all rst => x /andP[rxy _]; apply: sub_all ryu => z; apply: r_tr.\r\nQed.\r\n\r\nLemma all_mask (a : pred T) m s : all a s -> all a (mask m s).\r\nProof. by apply: contraLR; rewrite -!has_predC => /has_mask. Qed.\r\n\r\nLemma pathI (e1 e2 : rel T) x p :\r\n  path (relI e1 e2) x p = path e1 x p && path e2 x p.\r\nProof. by elim: p x => //= y p IHp x; rewrite andbACA -IHp. Qed.\r\n\r\nEnd SeqRel.\r\n\r\nSection Sorted.\r\n\r\nVariables (T : Type) (leT : rel T).\r\n\r\nDefinition sorted s := if s is x :: s' then path leT x s' else true.\r\n\r\nLemma path_sorted x s : path leT x s -> sorted s.\r\nProof. by case: s => //= y s /andP[]. Qed.\r\n\r\nLemma path_min_sorted x s : all (leT x) s -> path leT x s = sorted s.\r\nProof. by case: s => //= y s /andP[->]. Qed.\r\n\r\nLemma cat_sorted_r s1 s2 : sorted (s1 ++ s2) -> sorted s1 /\\ sorted s2.\r\nProof.\r\nby elim: s1 => //= x1 s1 IHs; rewrite cat_path => /andP[-> /path_sorted].\r\nQed.\r\n\r\nHypothesis leT_tr : transitive leT.\r\n\r\nLemma path_sortedP {x s} : reflect (all (leT x) s /\\ sorted s) (path leT x s).\r\nProof.\r\nelim: s x => [|y s IHs] x; [by left | rewrite /= -{IHs}(sameP andP (IHs y))].\r\napply: (iffP andP) => [[leTxy]|[]] /andP[// leTys ->]; rewrite leTxy leTys.\r\nby rewrite (sub_all _ leTys) // => z; apply: leT_tr leTxy.\r\nQed.\r\n\r\nLemma order_path_min x s : path leT x s -> all (leT x) s.\r\nProof. by case/path_sortedP. Qed.\r\n\r\nLemma cat_sorted s1 s2 :\r\n  sorted (s1 ++ s2) = [&& sorted s1, sorted s2 & allrel leT s1 s2].\r\nProof.\r\nelim: s1 => [|x1 s1 IHs] /=; first by rewrite andbT.\r\nby rewrite !(sameP path_sortedP andP) all_cat IHs -!andbA !(andbCA (all _ s2)).\r\nQed.\r\n\r\nLemma mask_sorted m s : sorted s -> sorted (mask m s).\r\nProof.\r\nelim: s m => [|x s IHs] [|b m] //; rewrite mask_cons cat_sorted /allrel /=.\r\nby rewrite all_nseq => /path_sortedP[/all_mask-> /IHs->]; case: b.\r\nQed.\r\n\r\nLemma filter_sorted a s : sorted s -> sorted (filter a s).\r\nProof. by move=> ord_s; rewrite filter_mask mask_sorted. Qed.\r\n\r\nEnd Sorted.\r\n\r\nLemma sortedI {T} (r1 r2 : rel T) s :\r\n  sorted (relI r1 r2) s = sorted r1 s && sorted r2 s.\r\nProof. by case: s => //= x s; rewrite pathI. Qed.\r\n\r\nSection EqSorted.\r\n\r\nContext {T : eqType} (leT : rel T).\r\nHypothesis leT_tr : transitive leT.\r\n\r\nLemma subseq_sorted s1 s2 : subseq s1 s2 -> sorted leT s2 -> sorted leT s1.\r\nProof. by case/subseqP=> m _ -> /mask_sorted->. Qed.\r\n\r\nLemma eq_sorted (leT_asym : antisymmetric leT) s1 s2 :\r\n  sorted leT s1 -> sorted leT s2 -> perm_eq s1 s2 -> s1 = s2.\r\nProof.\r\nelim: s2 s1 => [|x2 s2 IHs] s1 ord_s1; first by move=> _ /perm_nilP.\r\ncase/path_sortedP=> // leTxs2 ord_s2 eq_s12.\r\nhave: x2 \\in s1 by rewrite (perm_mem eq_s12) mem_head.\r\ncase: s1 ord_s1 => //= x1 s1 /path_sortedP[//|leTxs1 ord_s1] in eq_s12 *.\r\nhave: x1 \\in x2 :: s2 by rewrite -(perm_mem eq_s12) mem_head.\r\nrewrite !inE eq_sym; case: eqP eq_s12 => [-> | x1'2 _ /= s2x1 s1x2].\r\n  by rewrite perm_cons => /IHs->.\r\nby case: x1'2; apply/leT_asym; rewrite (allP leTxs2) ?(allP leTxs1).\r\nQed.\r\n\r\nHypothesis leT_irr : irreflexive leT.\r\n\r\nLemma sorted_uniq s : sorted leT s -> uniq s.\r\nProof.\r\nelim: s => //= x s IHs /path_sortedP[//|/allP-leTxs /IHs->].\r\nby rewrite (contraFN (leTxs x)) ?leT_irr.\r\nQed.\r\n\r\nLemma eq_sorted_irr s1 s2 :\r\n  sorted leT s1 -> sorted leT s2 -> s1 =i s2 -> s1 = s2.\r\nProof.\r\nmove=> ord_s1 ord_s2 eq_s12; apply/eq_sorted=> // [x y /andP[ltxy ltyx]|].\r\n  by have:= leT_irr x; rewrite (leT_tr ltxy ltyx).\r\nby apply/uniq_perm=> //; apply: sorted_uniq.\r\nQed.\r\n\r\nEnd EqSorted.\r\n\r\nSection MergeSort.\r\n\r\nContext {T : Type} (leT : rel T).\r\n\r\nFixpoint merge s1 :=\r\n  if s1 isn't x1 :: s1r then id else fix merge_s1 s2 :=\r\n  if s2 isn't x2 :: s2r then s1 else\r\n  if leT x1 x2 then x1 :: merge s1r s2 else x2 :: merge_s1 s2r.\r\n\r\nLocal Fixpoint merge_sort_push s1 ss :=\r\n  match ss with\r\n  | [::] :: ss' | [::] as ss' => s1 :: ss'\r\n  | s2 :: ss' => [::] :: merge_sort_push (merge s2 s1) ss'\r\n  end.\r\n\r\nLocal Fixpoint merge_sort_pop s1 ss :=\r\n  if ss is s2 :: ss' then merge_sort_pop (merge s2 s1) ss' else s1.\r\n\r\nLocal Fixpoint merge_sort_rec ss s :=\r\n  if s is [:: x1, x2 & s'] then\r\n    let s1 := if leT x1 x2 then [:: x1; x2] else [:: x2; x1] in\r\n    merge_sort_rec (merge_sort_push s1 ss) s'\r\n  else merge_sort_pop s ss.\r\n\r\nDefinition sort := merge_sort_rec [::].\r\n\r\nLemma count_merge a s1 s2 : count a (merge s1 s2) = count a s1 + count a s2.\r\nProof.\r\nelim: s1 s2 => //= x1 s1 IHs1; elim=> [|x2 s2 IHs2] /=; first by rewrite addn0. \r\nby case: leT => /=; [rewrite IHs1 addnA | rewrite IHs2 addnCA].\r\nQed.\r\n\r\nLemma size_merge s1 s2 : size (merge s1 s2) = size s1 + size s2.\r\nProof. by rewrite -!count_predT count_merge. Qed.\r\n\r\nLet allrel_merge r s t u (sr := (allrel r)^~ u) : sr (merge s t) = sr s && sr t.\r\nProof.\r\nrewrite -all_cat all_count count_cat size_cat.\r\nby rewrite [LHS]all_count count_merge size_merge.\r\nQed.\r\n\r\nLet sort_rec1 := fix sort_rec1 ss s :=\r\n  if s is x :: s then sort_rec1 (merge_sort_push [:: x] ss) s else\r\n  merge_sort_pop [::] ss.\r\n\r\nLet sortE s : sort s = sort_rec1 [::] s.\r\nProof.\r\ntransitivity (sort_rec1 [:: nil] s); last by case: s.\r\nrewrite /sort; move: [::] {2}_.+1 (ltnSn (size s)./2) => ss n.\r\nby elim: n => // n IHn in ss s *; case: s => [|x [|y s]] //= /IHn->.\r\nQed.\r\n\r\nLemma count_sort a s : count a (sort s) = count a s.\r\nProof.\r\nrewrite -[RHS]/(sumn (map (count a) [::]) + count a s) sortE.\r\nelim: s [::] => [|x s IHs] ss /=.\r\n  set s1 := [::]; rewrite -[0]/(count a s1); elim: ss s1 => //= s2 ss IHss s1.\r\n  by rewrite addnAC addnC -count_merge -IHss.\r\nrewrite {}IHs addnA -(muln1 (a x)) -count_nseq [nseq 1 x]/=; congr (_ + _).\r\nelim: ss {x}[:: x] => [|[|x s2] ss IHss] s1 //=; try by rewrite addnC.\r\nby rewrite IHss (count_merge a (_ :: _)) add0n addnCA addnA.\r\nQed.\r\n\r\nLocal Remark size_merge_sort_push s1 :\r\n  let graded ss := forall i, size (nth [::] ss i) \\in pred2 0 (2 ^ (i + 1)) in\r\n  size s1 = 2 -> {homo merge_sort_push s1 : ss / graded ss}.\r\nProof.\r\nset n := {2}1; rewrite -[RHS]/(2 ^ n) => graded sz_s1 ss.\r\nelim: ss => [|s2 ss IHss] in (n) graded s1 sz_s1 * => sz_ss i //=.\r\n  by case: i => [|[]] //; rewrite sz_s1 inE eqxx orbT.\r\ncase: s2 i => [|x s2] [|i] // in sz_ss *; first by rewrite sz_s1 inE eqxx orbT.\r\n  exact: (sz_ss i.+1).\r\nrewrite addSnnS; apply: IHss i => [|i]; last by rewrite -addSnnS (sz_ss i.+1).\r\nby rewrite size_merge sz_s1 (eqnP (sz_ss 0)) addnn expnS mul2n.\r\nQed.\r\n\r\nSection Stable.\r\n\r\nVariable leT0 : rel T.\r\n\r\nNotation leT0s := (allrel leT0).\r\nLet leT1 := relU (relC (relV leT)) (relI leT leT0).\r\nLet leTlex := lexrel leT leT0.\r\n\r\nLemma merge_stable s1 s2 :\r\n  leT0s s1 s2 -> sorted leT1 s1 -> sorted leT1 s2 -> sorted leT1 (merge s1 s2).\r\nProof.\r\nhave sorted_opt s : sorted leT1 s = path (optrel leT1) None (map Some s).\r\n  by case: s => //= x s; elim: s x => //= y s IHs x; rewrite IHs.\r\nrewrite !sorted_opt; elim: s1 s2 None => //= x s IHs; elim=> //= y t IHt w.\r\ncase/andP=> /andP[le0xy le0xt] le0st /andP[le1wx le1xs] /andP[le1wy le1yt].\r\nhave [leTxy | le'xy] /= := ifP; first by rewrite le1wx IHs //= leTxy le0xy orbT.\r\nby rewrite le1wy IHt /= ?le'xy // le0xt; apply: sub_all le0st => z /andP[].\r\nQed.\r\n\r\nHypothesis leT0_tr : transitive leT0.\r\n\r\nLemma sort_stable s : sorted leT0 s -> sorted leT1 (sort s).\r\nProof.\r\npose no_nil := filter (predC (@nilp T)); pose leT0s_tr := allrel_trans leT0_tr.\r\npose stackp t ss := all (sorted leT1) ss && path (relV leT0s) t (no_nil ss).\r\nhave stackp_rec t u v ss: stackp t (u :: v :: ss) -> stackp t (merge v u :: ss).\r\n  case: v u => // y v [] // x u; rewrite /stackp [y :: v]lock [x :: u]lock /=.\r\n  rewrite !ifT /= -!lock //; last by rewrite -lt0n size_merge.\r\n  case/and4P=> /and3P[le1yv le1xu ->] le0ut le0vu; rewrite merge_stable //.\r\n  rewrite allrel_merge (leT0s_tr (x :: u)) // le0ut [y :: v]lock.\r\n  case/no_nil: ss => //= w ss; rewrite -lock => /andP[le0wv {ss}->].\r\n  by rewrite -allrelV allrel_merge 2!allrelV le0wv (leT0s_tr (y :: v)).\r\nrewrite sortE; elim: s [::] (isT : stackp s [::]) => /= [|x s IHs] ss ssP.\r\n  clear 1; set s := [::]; rewrite -[stackp _ _]/(stackp [::] (s :: ss)) in ssP.\r\n  elim: ss => [|t ss IHss] in (s) ssP *; first by case/andP: ssP => /andP[].\r\n  exact/IHss/stackp_rec.\r\nset t := [:: x] => /path_sortedP[//|leT0xs]; apply: IHs.\r\nhave{ssP leT0xs}: stackp s (t :: ss).\r\n  case/andP: ssP; rewrite /stackp /= leT0xs => ->; case/no_nil: ss => //= w ss.\r\n  by rewrite -!(allrelV leT0) /= andbT andbAC => /andP[].\r\nby elim: ss => [|[|y u] ss IHss] // in {x}(t) * => /stackp_rec/IHss.\r\nQed.\r\n\r\nHypothesis leT_total : total leT.\r\n\r\nLet leTlexE s : sorted leTlex s = sorted leT1 s.\r\nProof.\r\ncase: s => // x0 s; apply/eq_path=> x y {x0 s} /=.\r\nby rewrite implybE; case: (leT x y) (leT_total x y) => //= ->.\r\nQed.\r\n\r\nLemma merge_lex_sorted s1 s2 :\r\n    leT0s s1 s2 -> sorted leTlex s1 -> sorted leTlex s2 ->\r\n  sorted leTlex (merge s1 s2).\r\nProof. by rewrite !leTlexE; apply: merge_stable. Qed.\r\n\r\nLemma sort_lex_sorted s : sorted leT0 s -> sorted leTlex (sort s).\r\nProof. by rewrite leTlexE; apply: sort_stable. Qed.\r\n\r\nEnd Stable.\r\n\r\nSection Sorted.\r\n\r\nHypothesis leT_total : total leT.\r\n\r\nLet relT := [rel x y : T | true].\r\nLet leTlexE s : sorted (lexrel leT relT) s = sorted leT s.\r\nProof. by case: s => // *; apply/eq_path=> x y /=; rewrite implybT andbT. Qed.\r\n\r\nLemma merge_sorted s1 s2 :\r\n  sorted leT s1 -> sorted leT s2 -> sorted leT (merge s1 s2).\r\nProof.\r\nrewrite -!leTlexE; apply: merge_lex_sorted => //.\r\nby apply: sub_all (all_predT s1) => x /=; rewrite all_predT.\r\nQed.\r\n\r\nLemma sort_sorted s : sorted leT (sort s).\r\nProof.\r\nby rewrite -!leTlexE sort_lex_sorted //; case: s => //= x s; elim: s x => /=.\r\nQed.\r\n\r\nEnd Sorted.\r\n\r\nEnd MergeSort.\r\n```\r\nI'm not entirely satisfied with this because the `leT1` relation isn't the strongest possible, and strengthening it would make it difficult to prove `merge_lex_sorted`. An alternative would be to prove the stability lemmas only for `iota` sequences, taking `leT0` = `leq` or `ltn`, and use the `map (nth ...)` theory to derive the final results.\r\n"},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2019-06-07T15:20:31Z","comment":"OK. I will prove the stability lemmas only for `iota` sequence, then derive others from it."},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2019-06-10T15:40:05Z","comment":"`T'` is not required to be `eqType` here."},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2019-06-10T15:41:21Z","comment":"`T` is not required to be `eqType`, at least for `homo_sorted_in` and `mono_sorted_in`."},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2019-06-13T11:10:03Z","comment":"One could prove `sort_map_in` without the use of `leT_total : total leT`, but one of the following variants of `sort_sorted` would be needed. :/\r\n```\r\nsort_sorted_in : forall (T : eqType) (leT : rel T) (s : seq T), {in s &, total leT} -> sorted leT (sort leT s)\r\nor\r\nsort_sorted_in : forall (T : Type) (P : pred T) (leT : rel T) (s : seq T), all P s -> {in P &, total leT} -> sorted leT (sort leT s).\r\n```"},{"author":"anton-trunov","file":"mathcomp/solvable/abelian.v","date":"2019-06-13T15:17:47Z","comment":"@ggonthier It's probably some GitHub glitch, because I can't find the `Arguments` annotation for `order_path_min` you were referring to."},{"author":"anton-trunov","file":"mathcomp/solvable/abelian.v","date":"2019-06-13T15:20:10Z","comment":"If that was one of the short remarks above, then it seems that just making arguments `T`, `leT`, `x` and `s` implicit and maximally inserted doesn't work.\r\n"},{"author":"ggonthier","file":"mathcomp/solvable/abelian.v","date":"2019-06-19T12:08:33Z","comment":"You are right, it doesn't, because `path_min_sorted` has non-prenex implicits. See https://github.com/math-comp/math-comp/pull/358#discussion_r295259267\r\nfor possible fixes, and #220 for the main thread on this topic."}],"tags":[{"tag":"kind: enhancement","description":"Issue or PR about addition of features."}],"commits":[{"author":"ybertot","committer":"CohenCyril","hash":"5ab7ac6b5f499eb9fcb4eade811f1e2d0dcdebf4","message":"Modified the definition of sort to work on any type","date":"2019-05-29T17:25:42Z"},{"author":"CohenCyril","committer":"CohenCyril","hash":"4a3a6c99b50384a6d454a3446fdafc3e84a66a5f","message":"Other Generalizations, fixes and CHANGELOG entry","date":"2019-05-29T18:26:10Z"}]}