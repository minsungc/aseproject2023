{"author":"pi8027","number":464,"diff_summary":[{"file":".gitlab-ci.yml","status":"A","additions":7224,"deletions":2150},{"file":"mathcomp/Make.test-suite","status":"A","additions":7224,"deletions":2150},{"file":"mathcomp/algebra/interval.v","status":"A","additions":7224,"deletions":2150},{"file":"mathcomp/algebra/rat.v","status":"A","additions":7224,"deletions":2150},{"file":"mathcomp/algebra/ssrint.v","status":"A","additions":7224,"deletions":2150},{"file":"mathcomp/algebra/ssrnum.v","status":"A","additions":7224,"deletions":2150},{"file":"mathcomp/ssreflect/order.v","status":"A","additions":7224,"deletions":2150},{"file":"mathcomp/test_suite/test_order_conv.v","status":"A","additions":7224,"deletions":2150}],"state":"open","open_date":"2020-03-04T06:50:07Z","update_date":"2023-02-24T23:25:14Z","discussion":[{"author":"spitters","date":"2020-04-26T16:50:55Z","comment":"Did you consider also join semilattices? Perhaps as an meet semilattice on the opposite order."},{"author":"pi8027","date":"2020-04-26T18:52:17Z","comment":"@spitters We did not consider adding a structure of join semilattices because the canonical `meetSemilatticeType` instance of `T^d` should work as the canonical join semilattice of `T` where `^d` stands for dual. But, actually, I see that making this design choice work requires some more work, and I do not fully understand how to do that yet."},{"author":"spitters","date":"2020-04-27T17:00:43Z","comment":"It's done using duality in Corn.\nThe HoTT library has duality for categories.\n\nWhat are the issues in math-comp?\n\nOn Sun, Apr 26, 2020 at 8:52 PM Kazuhiko Sakaguchi <notifications@github.com>\nwrote:\n\n> @spitters <https://github.com/spitters> We did not consider adding a\n> structure of join semilattices because the canonical meetSemilatticeType\n> instance of T^d should work as the canonical join semilattice of T where\n> ^d stands for dual. But, actually, I see that making this design choice\n> work requires some more work, and I do not fully understand how to do that\n> yet.\n>\n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/math-comp/math-comp/pull/464#issuecomment-619604982>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AABTNTU5JCSNCKHDD5CTDMDROR7G3ANCNFSM4LA5HSLQ>\n> .\n>\n"},{"author":"pi8027","date":"2020-04-28T08:59:10Z","comment":"The first issue is that the class record of `latticeType` should include two semilattice mixins to implement proper inheritance from join semilattices to lattices, but now actually it does not. In packed classes, inheritance should be implemented by inclusion rather than construction. See our IJCAR '20 papers for details:\r\n- [Competing inheritance paths in dependent type theory: a case study in functional analysis](https://hal.inria.fr/hal-02463336),\r\n- [Validating Mathematical Structures](https://arxiv.org/abs/2002.00620).\r\n\r\nThe second issue is that I do not see how to implement structure inference of join semilattices and lattices without having the actual interface for join semilattices. We probably should have the join semilattice structure to implement complete duality between meet/join semilattices, but it is still unclear to me.\r\n\r\nAlso, since this PR now features several new improvements from immediately useful ones to experimental and incomplete ones, I would rather split this PR into some fragments and merge a preliminary part before working on the complete implementation of duality."},{"author":"pi8027","date":"2020-05-01T09:37:05Z","comment":"Thinking about definitionally involutive duals, I also believe that `[latticeType of (A *p B)^d]` and `[latticeType of A^d *p B^d]` should be convertible."},{"author":"CohenCyril","date":"2020-05-01T09:44:27Z","comment":"Suggestion: (follow-up of comments wrongly placed in #490)\r\n```coq\r\nFrom Coq Require Import ssreflect ssrfun ssrbool.\r\n\r\nInductive display := Simple of unit | Dual of display.\r\nNotation dual_display d := (if d is Dual d then d else Dual d).\r\n\r\nRecord pt (d : display) := PT {sort :> Type; elt1 : sort; elt2 : sort}.\r\nArguments elt1 {d} : simpl never.\r\nArguments elt2 {d} : simpl never.\r\n\r\nNotation tt_display := (Simple tt).\r\nNotation default_display := (Simple _).\r\nFact prod_key : unit. Proof. exact: tt. Qed.\r\nNotation prod_display := (Simple prod_key).\r\n\r\nDefinition dual {d} (T : pt d) : pt (dual_display d) := @PT _ T (elt2 T) (elt1 T).\r\nDefinition dprod {d1 d2} (T1 : pt d1) (T2 : pt d2) : pt prod_display :=\r\n @PT _ (T1 * T2) (elt1 T1, elt1 T2) (elt2 T1, elt2 T2).\r\n\r\nDefinition pt_bool : pt tt_display := @PT _ bool false true.\r\nNotation simple_elt1 := (@elt1 default_display). \r\nNotation dual_elt1 := (@elt1 (Dual default_display)). \r\nNotation simple_elt2 := (@elt2 default_display). \r\nNotation dual_elt2 := (@elt2 (Dual default_display)). \r\n\r\nGoal dual (dual (pt_bool)) = pt_bool.\r\nreflexivity.\r\nQed.\r\n\r\nGoal elt1 (dual (dual pt_bool)) = elt2 (dual pt_bool).\r\nreflexivity.\r\nQed.\r\n\r\nGoal elt1 (dprod pt_bool (dual pt_bool)) = elt2 (dual (dprod (dual pt_bool) pt_bool)).\r\nFail reflexivity. (* it is not supposed to work at all *)\r\nAbort.\r\n```"},{"author":"pi8027","date":"2020-05-01T09:51:17Z","comment":"`dual (dual T) = T` holds for some particular instances, but in general, it does not.\r\n```coq\r\nGoal forall d (T : pt d), dual (dual T) = T.\r\nreflexivity.\r\nQed.\r\n```"},{"author":"CohenCyril","date":"2020-05-01T10:03:18Z","comment":"```coq\r\nFrom Coq Require Import ssreflect ssrfun ssrbool.\r\n\r\nSet Primitive Projections.\r\nRecord display := Display { is_dual : bool; disp : unit }.\r\nUnset Primitive Projections.\r\nArguments is_dual _ /.\r\n\r\nNotation dual_display d := (let: Display n u := d in @Display (~~ n) u).\r\n\r\nRecord pt (d : display) := PT {sort :> Type; elt1 : sort; elt2 : sort}.\r\nArguments elt1 {d} : simpl never.\r\nArguments elt2 {d} : simpl never.\r\n\r\nNotation tt_display := (Display false tt).\r\n\r\nFact prod_key : unit. Proof. exact: tt. Qed.\r\nNotation prod_display := (Display false prod_key).\r\n\r\nDefinition dual {d} (T : pt d) : pt (dual_display d) := @PT _ T (elt2 T) (elt1 T).\r\nDefinition dprod {d1 d2} (T1 : pt d1) (T2 : pt d2) : pt prod_display :=\r\n @PT _ (T1 * T2) (elt1 T1, elt1 T2) (elt2 T1, elt2 T2).\r\n\r\nDefinition pt_bool : pt tt_display := @PT _ bool false true.\r\nNotation simple_elt1 := (@elt1 (Display false _)). \r\nNotation dual_elt1 := (@elt1 (Display true _)). \r\nNotation simple_elt2 := (@elt2 (Display false _)). \r\nNotation dual_elt2 := (@elt2 (Display true _)). \r\n\r\nGoal dual (dual (pt_bool)) = pt_bool.\r\nreflexivity.\r\nQed.\r\n\r\nGoal elt1 (pt_bool) = elt2 (dual pt_bool).\r\nsimpl.\r\nreflexivity.\r\nQed.\r\n\r\nGoal elt1 (dual (dual pt_bool)) = elt2 (dual pt_bool).\r\nsimpl.\r\nreflexivity.\r\nQed.\r\n\r\nGoal elt1 (dprod pt_bool (dual pt_bool)) = elt2 (dual (dprod (dual pt_bool) pt_bool)).\r\nsimpl.\r\nFail reflexivity. (* products are not primitive records, so this does not work *)\r\nAbort.\r\n\r\nFail Goal forall d (T : pt d), dual (dual T) = T.\r\n(* Would work with definitional ~~ (~~ b) = b *)\r\n```"},{"author":"CohenCyril","date":"2020-05-01T10:08:34Z","comment":"> `dual (dual T) = T` holds for some particular instances, but in general, it does not.\r\n\r\nThis theorem will hold for every concrete instance."},{"author":"pi8027","date":"2020-10-16T10:50:09Z","comment":"I have attempted to implement a complete duality of structures without having some dual structures, but my conclusion is that it seems impossible. For example, we have `porderType`, `bPorderType`, and `tbPorderType`, then `bPorderType (dual_display disp)` can be seen as `tPorderType disp`, and we can define `1%O` as the dual of `0%O`. When we write `(0 = 1)%O`, we expect a `tbPorderType` to be inferred as the type of `0` and `1`, but it can never happen in this setting. So we have to declare all the dual structures anyway. Does this make sense?"},{"author":"pi8027","date":"2020-10-20T10:04:15Z","comment":"I have added join-semilattice structures and some order structures with a top but without a bottom anyway. I hope this will be helpful to implement the order structures and definitionally involutive duals using Hierarchy Builder even if we will not merge this as it is. It seems that it also simplifies the theory part of order.v by accident."},{"author":"pi8027","date":"2020-10-29T07:02:40Z","comment":"Documentation is not done yet and finmap has to be fixed. Except that, this PR is ready for review. But we have an option not to merge this PR and rather reimplement it using HB."},{"author":"pi8027","date":"2020-11-04T10:59:49Z","comment":"@CohenCyril Would you like to review and merge this PR soon? I'm not requesting to include this in 1.12. But I would like to know whether it is reasonable to rework #281 after merging this, or I should not wait for that."},{"author":"CohenCyril","date":"2020-11-04T15:28:07Z","comment":"> @CohenCyril Would you like to review and merge this PR soon? I'm not requesting to include this in 1.12. But I would like to know whether it is reasonable to rework #281 after merging this, or I should not wait for that.\r\n\r\nDear @pi8027, I am afraid I will not have the time to review this PR this month since it is a pretty big one, and I would need the changelog as a guideline to read the diff... I think we should reschedule it to 1.13..."},{"author":"CohenCyril","date":"2020-11-04T15:30:34Z","comment":"BTW, I came across a problem recently: I could not make `'I_n` a `finOrderType` for any `n` (not manifestly positive), because our phrasing of `finOrderType` inherits structures with bottom and top. I remember making this choice consciously in your office last year, but nowadays I think we should backtrack on that. Are you doing it in this PR?"},{"author":"pi8027","date":"2020-11-04T15:38:52Z","comment":"> Dear @pi8027, I am afraid I will not have the time to review this PR this month since it is a pretty big one, and I would need the changelog as a guideline to read the diff... I think we should reschedule it to 1.13...\r\n\r\n@CohenCyril Sure. So I will finish the documentation work first anyway.\r\n\r\n> BTW, I came across a problem recently: I could not make `'I_n` a `finOrderType` for any `n` (not manifestly positive), because our phrasing of `finOrderType` inherits structures with bottom and top. I remember making this choice consciously in your office last year, but nowadays I think we should backtrack on that. Are you doing it in this PR?\r\n\r\nThis choice has been made because a nonempty finite lattice always has the top and the bottom, but I think what you say makes sense. This PR currently does not do that, but I can do it."},{"author":"pi8027","date":"2020-11-16T04:29:13Z","comment":"> > BTW, I came across a problem recently: I could not make `'I_n` a `finOrderType` for any `n` (not manifestly positive), because our phrasing of `finOrderType` inherits structures with bottom and top. I remember making this choice consciously in your office last year, but nowadays I think we should backtrack on that. Are you doing it in this PR?\r\n> \r\n> This choice has been made because a nonempty finite lattice always has the top and the bottom, but I think what you say makes sense. This PR currently does not do that, but I can do it.\r\n\r\nDone. The diagram of the new hierarchy is attached. I still have to do the documentation work.\r\n\r\n![hierarchy_ssreflect](https://user-images.githubusercontent.com/111003/99212893-94bd8180-280f-11eb-84c6-7703f3828156.png)\r\n"},{"author":"pi8027","date":"2020-12-07T00:57:58Z","comment":"I finished documentation and this PR is ready for review. But, we probably have to separate the finite counterparts off as `finorder.v` since `order.v` became too large (approx. 12k lines)."},{"author":"pi8027","date":"2021-01-15T16:05:06Z","comment":"Since `(meet|join)Semilattice` is too long, I'm thinking about replacing them with `(meet|join)Order`, e.g., `meetOrderType`. Any opinion?"}],"review_discussion":[{"author":"pi8027","file":"mathcomp/ssreflect/order.v","date":"2021-01-10T06:23:58Z","comment":"They are redundant and can be replaced with:\r\n```coq\r\n  le_anti : forall x y, le x y -> le y x -> x = y;\r\n```"}],"tags":[{"tag":"kind: enhancement","description":"Issue or PR about addition of features."}],"commits":[{"author":"pi8027","committer":"pi8027","hash":"b26abe87b46af2417f0fb798e77853951dc571a3","message":"Fix `\\meet^p` and `\\join^p` notations and the scope of n.-tuplelexi notation","date":"2023-02-24T23:10:49Z"},{"author":"pi8027","committer":"pi8027","hash":"804f155e0fee7d3b6448198eb902f434f32a08e6","message":"Redefine the lattice structure with fewer axioms\n\nthat also eliminate the interaction between meet and join, so that it can also\nbe redefined as the join of meet-semilattice and join-semilattice structures\nwithout extra mixin.","date":"2023-02-24T23:10:49Z"},{"author":"pi8027","committer":"pi8027","hash":"aed9dc0e0e5bc86df3b47e0cf5afb280f211fca4","message":"Add some order structures and implement definitionally involutive duals\n\n- Add meet and join semilattice structures\n- Add some order structures with a top but without a bottom\n- T^d^d is definitionally equal to T where T is an ordered type instance","date":"2023-02-24T23:10:49Z"},{"author":"pi8027","committer":"pi8027","hash":"fd8732c50e835c544443915ce76f05d1b255a86c","message":"Add some more order structures\n\n- The following order structures have been added:\n  + `(b|t|tb)OrderType`,\n  + `fin(B)MeetSemilatticeType`, and\n  + `fin(T)JoinSemilatticeType`.\n- Since a finite lattice has lower and upper bounds if it is nonempty, the\n  finite lattice structures `finLatticeType`, `finDistrLatticeType`,\n  `finOrderType`, and `finCDistrLatticeType` were equipped with bounds before\n  this change. They have been renamed to `finTBLatticeType`,\n  `finTBDistrLatticeType`, `finTBOrderType`, and `finCTBDistrLatticeType` and\n  the original ones except for `finCDistrLatticeType` have been redefined as\n  possibly empty ones, which allows us, e.g., to make a finite ordinal `'I_n`\n  a `finOrderType` for any `n`.","date":"2023-02-24T23:10:49Z"},{"author":"pi8027","committer":"pi8027","hash":"d37495aa8ebe9e0d594046e90c4aa256f8b813b8","message":"Documentation","date":"2023-02-24T23:10:49Z"},{"author":"pi8027","committer":"pi8027","hash":"93250a5f9056fda5f16bf2035da42598e2dbfae9","message":"Refactor the order theory\n\n- Refactor the order theory,\n- Redefine `porderType` with fewer axioms, and\n- Rename `(meet|join)SemilatticeMixin` to `(meet|join)Mixin`.","date":"2023-02-24T23:10:49Z"},{"author":"pi8027","committer":"pi8027","hash":"c315edd8fe3abbfdfe8a915ff95edda967f4e6a6","message":"Add CI overlays","date":"2023-02-24T23:10:49Z"}]}