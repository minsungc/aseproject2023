{"author":"CohenCyril","number":372,"diff_summary":[{"file":".gitlab-ci.yml","status":"M","additions":339,"deletions":387},{"file":"mathcomp/algebra/finalg.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/algebra/fraction.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/algebra/intdiv.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/algebra/matrix.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/algebra/mxalgebra.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/algebra/mxpoly.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/algebra/poly.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/algebra/ssrnum.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/character/character.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/character/classfun.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/character/integral_char.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/character/mxabelem.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/character/mxrepresentation.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/field/algebraics_fundamentals.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/field/algnum.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/field/closed_field.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/field/fieldext.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/field/finfield.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/field/galois.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/fingroup/action.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/fingroup/automorphism.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/fingroup/fingroup.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/fingroup/gproduct.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/fingroup/morphism.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/fingroup/perm.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/solvable/abelian.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/solvable/alt.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/solvable/burnside_app.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/solvable/center.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/solvable/cyclic.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/solvable/extremal.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/solvable/frobenius.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/solvable/jordanholder.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/solvable/maximal.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/solvable/primitive_action.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/solvable/sylow.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/ssreflect/div.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/ssreflect/eqtype.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/ssreflect/fingraph.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/ssreflect/finset.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/ssreflect/fintype.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/ssreflect/prime.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/ssreflect/seq.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/ssreflect/ssrbool.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/ssreflect/ssreflect.v","status":"M","additions":339,"deletions":387},{"file":"mathcomp/ssreflect/ssrnat.v","status":"M","additions":339,"deletions":387}],"state":"closed","open_date":"2019-07-18T16:40:37Z","update_date":"2020-06-04T15:15:05Z","discussion":[{"author":"gares","date":"2019-07-18T18:00:37Z","comment":"Can't you just say that `/[x]` stands for \"rewrite ! x\" and that `->` is special in that context and means `{}top in *`? It is just that `/!inE` is not much shorter than `/[inE]` and the latter is a bit more future proof, eg you may need to apply the rewrite rule to specialize it, or write a multi rule (assuming you can define a notation for `[x,y,..,z]` in there)."},{"author":"CohenCyril","date":"2019-07-22T13:15:44Z","comment":"> Can't you just say that `/[x]` stands for \"rewrite ! x\" and that `->` is special in that context and means `{}top in *`? It is just that `/!inE` is not much shorter than `/[inE]` and the latter is a bit more future proof, eg you may need to apply the rewrite rule to specialize it, or write a multi rule (assuming you can define a notation for `[x,y,..,z]` in there).\r\n\r\nSometimes it is with `!` sometimes it is without, moreover a general design pattern of mathcomp is that bracketed notations start with a keyword/symbol as in `[&& ..]`, `[:: ...]`, `[seq ...]`, `[tuple ...]`, `[eqType ...]` ... so using `[ rule ]` for rewriting breaks this pattern. At the very least it should be `[! rule]` (for bang) `[1 rule]` for once... and maybe it is alright... let me see."},{"author":"CohenCyril","date":"2019-07-24T08:03:16Z","comment":"@gares \r\n> `[->]` means `rewrite {}top in *`\r\n\r\nIt's more like `elim: _ / top in *` except I found no stable enough way of reverting all the local context (with exceptions or renamings for section hyps) and introducing everything back consistently  :disappointed:\r\n\r\nSee my commit: the current version seems to work but is a bit broken for hypothesis that depend on others, where I have to default to Coq's less powerful `fold` tactic with a `in` and potentially screwing up section hypothesis... moreover it does not handle multi-rules and quantified rules...\r\n\r\nI have tried more clever versions since then... and my last attempt, which is supposed to handle everything is:\r\n```coq\r\nLtac discharge_all_but x := do ![match goal with \r\n  H : _ |- _ => (* discharges a let in which is not x *)\r\n                (move: x @H => x)\r\n                 (* otherwise discharges a n assumption which is not x *)\r\n                || (move: x H => x);\r\n                (* tests whether H is still there, which means it is a section hypothesis *)\r\n                tryif move: H => _\r\n                then fail else idtac\r\n  end].\r\n\r\nLemma lock_goal A : locked A -> A.\r\nProof. by rewrite -lock. Qed.\r\nLemma unlock_goal A : A -> locked A.\r\nProof. by rewrite -lock. Qed.\r\n\r\n(* implementation of `/[<-]` *)\r\nLtac subst_eq :=\r\n  let top_eq := fresh \"_top_eq_\" in move=> top_eq;\r\n  apply: lock_goal; discharge_all_but top_eq;\r\n  (* try dependent elim, otherwise (if it's a multirule) rewriting *)\r\n  ((elim: _ / top_eq) || (rewrite -!{}top_eq));\r\n  (* the `intros` here assumes that `move:` discharged hyps with\r\n  the names they used to have, which seems like a decent invariant\r\n  unfortunately, it seems to break with hyps introduced by `=> +` *)\r\n  intros; apply: unlock_goal.\r\n```\r\nwhich works very well, except in the presence of `=> +` (see comment)\r\n\r\n"},{"author":"gares","date":"2019-07-24T08:40:26Z","comment":"I thought you were calling the primitive `subst` tactic for `/[->]`.\r\nTo my knowledge, any context manipulation in ltac1 is very hard to write, so I would not even try."},{"author":"amahboubi","date":"2019-10-24T12:49:49Z","comment":"This PR needs an assignee. @gares ?"},{"author":"gares","date":"2019-10-24T13:22:15Z","comment":"The more I think about this, the more I've the impression that you try to be too generic.\r\n\r\nEg many of the use cases that seem very legit could be also covered by `=> /mxE /inE`, that is ad hoc calls to `rewrite ! lemma` (and at some extent they are unfolding lemmas, so `/e` reminds me that, but maybe it's too confusing for a newcomer). What do you think about this? It's a baby step but still useful I believe.\r\n\r\nThe `subst` thing seems ahead of time: with Ltac2 (or anything else than ltac1) you can surely code something sensible, if the already existing `subst` does not behave as you like. I'm not sure we want that ltac code around."},{"author":"affeldt-aist","date":"2020-03-25T14:46:39Z","comment":"The relaease managers propose to put this PR in the 1.12.0 miletone. Are you ok?"},{"author":"CohenCyril","date":"2020-03-25T15:25:57Z","comment":"> The relaease managers propose to put this PR in the 1.12.0 miletone. Are you ok?\r\n\r\nI agree"},{"author":"CohenCyril","date":"2020-03-25T15:26:54Z","comment":"As a side note, it was discussed in a math-comp meeting that substitution should mention the context hypotheses  explicitly anyway."},{"author":"CohenCyril","date":"2020-05-08T22:42:05Z","comment":"I splitted this PR in bits. The first bit is available as #501, the second as #502."}],"review_discussion":[],"tags":[{"tag":"kind: enhancement","description":"Issue or PR about addition of features."},{"tag":"needs: discussion","description":"Issue or PR that needs discussion. Please come in a give your opinion."}],"commits":[{"author":"CohenCyril","committer":"CohenCyril","hash":"1decc8c7f3565833369e106069e12529d5cb7736","message":"Experimented with new features of coq 8.10","date":"2019-07-18T16:35:46Z"},{"author":"CohenCyril","committer":"CohenCyril","hash":"d354ab49c6db588b12919f7f193544aa267a2d37","message":"updating gitlab ci","date":"2019-07-18T16:35:49Z"},{"author":"CohenCyril","committer":"CohenCyril","hash":"87e0c9f0ab76a57b796fea668858fbef15504c87","message":"switching to [!rule] syntax and better [->]","date":"2019-07-23T08:24:12Z"}]}