{"author":"soraros","number":343,"diff_summary":[{"file":"mathcomp/ssreflect/ssrnat.v","status":"M","additions":1,"deletions":1}],"state":"closed","open_date":"2019-05-05T18:49:59Z","update_date":"2019-05-06T18:58:51Z","discussion":[{"author":"ggonthier","date":"2019-05-06T07:17:18Z","comment":"Good catch! The `finmap-dev` failure is actually a `finmap` bug, now corrected by math-comp/finmap#38; unfortunately GitLab doesn't let you rerun checks manually.\r\nIdeally, we also should try to remove the `plus_n_Sm` hint, to see if it's being accidentally used elsewhere."},{"author":"soraros","date":"2019-05-06T08:08:56Z","comment":"It is used elsewhere. \r\nI removed the hints by adding the following line to ssrnat (these are the ones in `core` that I think maybe troublesome, others are just definition unfolding and things)\r\n```coq\r\nRemove Hints\r\n       n_Sn O_S\r\n       not_eq_S not_eq_sym\r\n       plus_n_O plus_n_Sm\r\n       mult_n_O mult_n_Sm\r\n       eq_add_S\r\n       f_equal_nat f_equal2_mult\r\n  : core.\r\n```\r\nhere are other dependences I found in `ssrnat`(they are picked up by `by ...`, so maybe we need to re-add some of their ssr counterparts):\r\n\r\n- `iter_succn` -> `plus_n_O`, `plus_n_Sm`\r\n- `nat_of_add_bin` -> `plus_n_O`\r\n- `nat_of_mul_bin` -> `mult_n_O`\r\n\r\nAlso, this might be useful:\r\n```coq\r\nCheck n_Sn : forall n : nat, n <> S n.\r\nCheck O_S : forall n : nat, 0 <> S n.\r\n\r\nCheck not_eq_S : forall n m : nat, n <> m -> S n <> S m.\r\nCheck not_eq_sym : forall (A : Type) (x y : A), x <> y -> y <> x.\r\n\r\nCheck plus_n_O : forall n : nat, n = n + 0.\r\nCheck plus_n_Sm : forall n m : nat, S (n + m) = n + S m.\r\nCheck mult_n_Sm : forall n m : nat, n * m + n = n * S m.\r\nCheck mult_n_O : forall n : nat, 0 = n * 0.\r\n\r\nCheck eq_add_S : forall n m : nat, S n = S m -> n = m.\r\nCheck f_equal_nat : forall (B : Type) (f : nat -> B) (x y : nat), x = y -> f x = f y.\r\nCheck f_equal2_mult : forall x1 y1 x2 y2 : nat, x1 = y1 -> x2 = y2 -> x1 * x2 = y1 * y2.\r\n```"},{"author":"soraros","date":"2019-05-06T08:12:38Z","comment":"The output of `Print HintDb core.`\r\n```\r\nNon-discriminated database\r\nUnfoldable variable definitions: none\r\nUnfoldable constant definitions: none\r\nCut: emp\r\nFor any goal ->   \r\nFor CompSpec ->   unfold CompSpec(level 4, id 0) \r\nFor CompSpecT ->   unfold CompSpecT(level 4, id 0) \r\nFor ge ->   unfold ge(level 4, id 0) \r\nFor gt ->   unfold gt(level 4, id 0) \r\nFor lt ->   unfold lt(level 4, id 0) \r\nFor not ->   simple apply n_Sn(level 0, pattern ?META105 <> S ?META105, id 0)\r\n             simple apply O_S(level 0, pattern 0 <> S ?META103, id 0)\r\n             simple apply not_eq_S(level 1, pattern S ?META97 <> S ?META98, id 0)\r\n             simple apply not_eq_sym ; trivial(level 1, pattern \r\n             ?META51 <> ?META50 :> ?META49, id 0) unfold not(level 4, id 0) \r\nFor notT ->   simple apply not_identity_sym ; trivial(level 1, pattern \r\n              notT (identity ?META87 ?META86), id 0) \r\nFor BoolSpec ->   simple apply BoolSpecF(level 1, pattern \r\n                  BoolSpec ?META48 ?META49 false, id 0)\r\n                  simple apply BoolSpecT(level 1, pattern \r\n                  BoolSpec ?META45 ?META46 true, id 0) \r\nFor CompareSpec ->   simple apply CompGt(level 1, pattern \r\n                     CompareSpec ?META85 ?META86 ?META87 Gt, id 0)\r\n                     simple apply CompLt(level 1, pattern \r\n                     CompareSpec ?META81 ?META82 ?META83 Lt, id 0)\r\n                     simple apply CompEq(level 1, pattern \r\n                     CompareSpec ?META77 ?META78 ?META79 Eq, id 0) \r\nFor CompareSpecT ->   simple apply CompGtT(level 1, pattern \r\n                      CompareSpecT ?META109 ?META110 ?META111 Gt, id 0)\r\n                      simple apply CompLtT(level 1, pattern \r\n                      CompareSpecT ?META105 ?META106 ?META107 Lt, id 0)\r\n                      simple apply CompEqT(level 1, pattern \r\n                      CompareSpecT ?META101 ?META102 ?META103 Eq, id 0) \r\nFor True ->   exact I(level 0, pattern True, id 0) \r\nFor and ->   simple apply conj(level 2, pattern ?META1 /\\ ?META2, id 0) \r\nFor eq ->   simple apply mult_n_Sm(level 0, pattern ?META147 * ?META148 + ?META147 =\r\n                                                    ?META147 * S ?META148, id 0)\r\n            simple apply mult_n_O(level 0, pattern 0 = ?META145 * 0, id 0)\r\n            simple apply plus_n_Sm(level 0, pattern S (?META129 + ?META130) =\r\n                                                    ?META129 + S ?META130, id 0)\r\n            simple apply @eq_refl(level 0, pattern ?META125 = ?META125 :> ?META124, id 0)\r\n            simple apply plus_n_O(level 0, pattern ?META123 = ?META123 + 0, id 0)\r\n            simple apply eq_add_S ; trivial(level 1, pattern \r\n            ?META91 = ?META92, id 0)\r\n            simple apply f_equal_nat(level 1, pattern ?META82 ?META83 =\r\n                                                      ?META82 ?META84 :> \r\n                                                      ?META81, id 0)\r\n            simple apply eq_sym ; trivial(level 1, pattern \r\n            ?META47 = ?META46 :> ?META45, id 0)\r\n            simple apply f_equal2_mult(level 2, pattern ?META133 * ?META135 =\r\n                                                        ?META134 * ?META136, id 0)\r\n            simple apply f_equal2_nat(level 2, pattern ?META108 ?META109 ?META111 =\r\n                                                       ?META108 ?META110 ?META112 :>\r\n                                                       ?META107, id 0) \r\nFor ex ->   simple eapply ex_intro(level 2, pattern ex ?META26, id 0) \r\nFor ex2 ->   simple eapply ex_intro2(level 3, pattern exists2 x : \r\n                                                      ?META29, \r\n                                                      ?META30 x & ?META31 x, id 0) \r\nFor identity ->   simple apply identity_refl(level 0, pattern \r\n                  identity ?META126 ?META126, id 0)\r\n                  simple apply identity_sym ; trivial(level 1, pattern \r\n                  identity ?META83 ?META82, id 0) \r\nFor inhabited ->   simple apply inhabits(level 1, pattern inhabited ?META61, id 0) \r\nFor le ->   simple apply le_n(level 0, pattern ?META151 <= ?META151, id 0)\r\n            simple apply le_S(level 1, pattern ?META152 <= S ?META153, id 0) \r\nFor or ->   simple apply or_intror(level 1, pattern ?META8 \\/ ?META9, id 0)\r\n            simple apply or_introl(level 1, pattern ?META5 \\/ ?META6, id 0) \r\nFor prod ->   simple apply @pair(level 2, pattern (?META57 * ?META58)%type, id 0) \r\nFor sig ->   simple eapply exist(level 2, pattern {x : ?META105 | ?META106 x}, id 0) \r\nFor sig2 ->   simple eapply exist2(level 3, pattern {x : ?META109 | \r\n                                                    ?META110 x & \r\n                                                    ?META111 x}, id 0) \r\nFor sigT ->   simple eapply existT(level 2, pattern {x : ?META115 & ?META116 x}, id 0) \r\nFor sigT2 ->   simple eapply existT2(level 3, pattern {x : \r\n                                                      ?META119 & \r\n                                                      ?META120 x & \r\n                                                      ?META121 x}, id 0) \r\nFor sum ->   simple apply @inr(level 1, pattern (?META64 + ?META65)%type, id 0)\r\n             simple apply @inl(level 1, pattern (?META61 + ?META62)%type, id 0) \r\nFor sumbool ->   simple apply @right(level 1, pattern {?META84} + {?META85}, id 0)\r\n                 simple apply @left(level 1, pattern {?META81} + {?META82}, id 0) \r\nFor sumor ->   simple apply @inright(level 1, pattern ?META90 + {?META91}, id 0)\r\n               simple apply @inleft(level 1, pattern ?META87 + {?META88}, id 0) \r\n```"},{"author":"ggonthier","date":"2019-05-06T14:55:46Z","comment":"@soraros, thanks for taking a closer look; the only hints we should be concerned with are `plus_n_0`, `plus_n_Sm`, `mult_n_0` and `mult_n_Sm`. The others are irrelevant to `by ...` because they are either at level > 0 and thus not used by `trivial`, and/or otherwise covered by the default `done` (for example, via `discriminate` or `split`).\r\n  We should certainly get rid of them within `ssrnat.v`, and it would be useful to check whether we can do so for the rest of MathComp, or if we should add some of `addn0`, `addnS`, `muln0` and `mulnS` to replace them, perhaps as `Extern` hints that warn against their use."},{"author":"soraros","date":"2019-05-06T15:40:57Z","comment":"@ggonthier, thank you for clarifying. However, I'm quite new to ssr and coq so I'm afraid I'm incompetent to do any of the things you suggested properly.\r\nSo, shall I close this PR?"},{"author":"ggonthier","date":"2019-05-06T16:23:37Z","comment":"@soraros, I'm fine with you just completing this PR by removing all other uses of `Arith` lemmas from `ssrnat`. By \"check\" I just meant trying to see how much of rest of the library compiles with your `Remove Hints` command, but we can leave that experiment for another PR."},{"author":"soraros","date":"2019-05-06T19:08:37Z","comment":"Sorry, I accidentally close the PR (changed the branch name and the pr got closed).\r\nAnyway, I created a new one at [#344](https://github.com/math-comp/math-comp/pull/344)."}],"review_discussion":[],"tags":[],"commits":[{"author":"soraros","committer":"web-flow","hash":"eb35517485ddb5371f42b4853561a2cc1c6fde44","message":"remove addnS's dependence on plus_n_Sm","date":"2019-05-05T18:49:43Z"}]}