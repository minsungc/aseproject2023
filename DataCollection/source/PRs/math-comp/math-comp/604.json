{"author":"chdoc","number":604,"diff_summary":[{"file":"CHANGELOG_UNRELEASED.md","status":"M","additions":104,"deletions":1},{"file":"mathcomp/ssreflect/seq.v","status":"M","additions":104,"deletions":1}],"state":"merged","open_date":"2020-10-01T16:17:52Z","update_date":"2020-11-11T21:20:52Z","discussion":[{"author":"CohenCyril","date":"2020-10-30T17:14:18Z","comment":"> @CohenCyril I chose `_pivot` for the `s1 ++ x :: s2` pattern, but I am open to suggestions. I would favor this pattern over `rcons s1 x ++ s2`, because the former arises naturally when using `rot_to_arc` (`x` being the beginning of the second arc).\r\n\r\nAll right, I never noticed this before, this is a bit unfortunate since `splitP` chooses the other pattern :disappointed: "},{"author":"chdoc","date":"2020-10-30T19:08:44Z","comment":"Well, just ran a count on my graph-theory development and I have about the same number of uses of `path.splitP` (if one imports `all_ssreflect`, `splitP` ends up being the one for ordinals) and of `splitPr`. The former is more useful when dealing with paths, where one usually cares about the last element, so `splitP` allows rewriting with `last_rcons`. The latter is more useful when dealing with arcs, where the \"end\" of the arc is actually part of the other arc (i.e, `arc s x y` contains `x` but not `y`). "},{"author":"chdoc","date":"2020-11-04T19:45:04Z","comment":"@CohenCyril , I rebased, but I kept the changes following your review in a separate commit. Please ping me before merging, even if you are okay with my alternative choice of names, so that I can squash the commits. "},{"author":"chdoc","date":"2020-11-06T19:51:05Z","comment":"@CohenCyril I committed your suggestions and added a fixup commit to make it compile and update the change log. Who would be a good second reviewer? "},{"author":"CohenCyril","date":"2020-11-07T23:18:59Z","comment":"I guess it's time to summon @pi8027..."},{"author":"chdoc","date":"2020-11-11T19:40:37Z","comment":"And another rebase to resolve the conflicts with the other recent additions to `seq.v`..."},{"author":"CohenCyril","date":"2020-11-11T19:43:44Z","comment":"> And another rebase to resolve the conflicts with the other recent additions to `seq.v`...\r\n\r\nIt might very well have been the last one though."}],"review_discussion":[{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-10-29T22:27:18Z","comment":"`x \\notin s3 ++ s4` seems sufficient"},{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2020-10-30T08:07:42Z","comment":"I guess you're right, the statement was motivated by what's available at the point of use in `subseq_pivot`. There, I suppose, the same criticism applies. I will have a look later; the proof of `subseq_pivot` is based on `subseq_uniqP`..."},{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2020-10-31T13:53:54Z","comment":"On second thought, I'm not sure what the ideal statement for this lemma is. The proposed `x \\notin x3 ++ s4` is clearly sufficient. But then one has to go via `count (pred1 x)` to recover `x \\notin s1` to prove the lemma. In fact, that would be the only purpose of assuming `x \\notin s4`. So one could weaken the assumption even further to assume `x \\notin s1` and `x \\notin s3`. On the other hand, this would make the lemma even more cumersome to use if one only has `uniq (s3 ++ x :: s4)` in the context. In my setting, almost all occurring sequences are duplicate free.  :thinking: "},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-04T13:41:48Z","comment":"> On second thought, I'm not sure what the ideal statement for this lemma is. The proposed `x \\notin x3 ++ s4` is clearly sufficient. But then one has to go via `count (pred1 x)` to recover `x \\notin s1` to prove the lemma. In fact, that would be the only purpose of assuming `x \\notin s4`. So one could weaken the assumption even further to assume `x \\notin s1` and `x \\notin s3`. On the other hand, this would make the lemma even more cumersome to use if one only has `uniq (s3 ++ x :: s4)` in the context. In my setting, almost all occurring sequences are duplicate free.\r\n\r\nThen let's keep this one and rename it `eqseq_uniq_pivotr`? (the `r` standing for the uniq holding on the right pivot)\r\n\r\nAdditionally, the 80 character limit is exceeded."},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-04T15:42:10Z","comment":"```suggestion\r\nLemma rev_mask m s : size m = size s -> rev (mask m s) = mask (rev m) (rev s).\r\nProof.\r\nmove: m s; apply: seq_ind2 => //= b x m s eq_size_sm IH.\r\nby case: b; rewrite !rev_cons mask_rcons ?IH ?size_rev// (cats1, cats0).\r\nQed.\r\n```\r\nprovided you also add\r\n```coq\r\nLemma mask_rcons b m x s : size m = size s ->\r\n  mask (rcons m b) (rcons s x) = mask m s ++ nseq b x.\r\nProof. by move=> ms; rewrite -!cats1 mask_cat//; case: b. Qed.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-04T15:45:29Z","comment":"I suggest `subseq_uniq_pivot` (using the same convention as `eqseq_uniq_pivotr`, but omitting the `r` because there would never be a `l` version)"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-04T15:49:42Z","comment":"```suggestion\r\nLemma eqseq_uniq_pivotr s1 s2 s3 s4 x : uniq (s3 ++ x :: s4) ->\r\n  s1 ++ x :: s2 == s3 ++ x :: s4 = (s1 == s3) && (s2 == s4).\r\n```"},{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2020-11-04T16:04:30Z","comment":"Hmm, according to `mainSymbol_suffixes(_condition)?` I would rather name this `eqseq_pivot_uniqr`. The \"pivot\" is `x` and the `pivot` is to describe the `_ ++ _ :: _` pattern. (I guess neither of us wants to call it `uniqr_eqseq_pivot` after the `(condition_)?mainSymbol_suffixes` convention.). I guess a `uniql` variant doesn't hurt either."},{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2020-11-04T16:10:48Z","comment":"Hmm, if I follow my argument from above, I end up at `subseq_pivot_uniq` which is ambiguous as uniq is unary predicate. So maybe `uniq_subseq_pivot` is more appropriate. Maybe naming the other one `uniqr_eqseq_pivot` isn't that bad a choice after all. @CohenCyril What do you think?"},{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2020-11-04T16:13:16Z","comment":"(Hmm, there was no \"Reply...\" for your first comment, so I commented after clicking on \"view changes\", but this comment isn't shown above :thinking: )"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-04T21:13:34Z","comment":"While we are at it, we could include all the following variations and side lemmas:\r\n(and for the sake of uniformity, with `uniq_subseq_pivot` I would prefer the names `uniq_eqseq_pivotl` and `uniq_eqseq_pivotr`)\r\n```suggestion\r\nLemma index_pivot x s1 s2 (s := s1 ++ x :: s2) : x \\notin s1 -> \r\n  index x s = size s1.\r\nProof. by rewrite index_cat/= eqxx addn0; case: ifPn. Qed.\r\n\r\nLemma take_pivot x s2 s1 (s := s1 ++ x :: s2) : x \\notin s1 -> \r\n  take (index x s) s = s1.\r\nProof. by move=> /index_pivot->; rewrite take_size_cat. Qed.\r\n\r\nLemma rev_pivot x s1 s2 : rev (s1 ++ x :: s2) = rev s2 ++ x :: rev s1.\r\nProof. by rewrite rev_cat rev_cons cat_rcons. Qed.\r\n\r\nLemma eqseq_pivot2l x s1 s2 s3 s4 : x \\notin s1 -> x \\notin s3 ->\r\n  (s1 ++ x :: s2 == s3 ++ x :: s4) = (s1 == s3) && (s2 == s4).\r\nProof.\r\nmove=> xNs1 xNs3; apply/idP/idP => [E|/andP[/eqP-> /eqP->]//].\r\nsuff S : size s1 = size s3 by rewrite eqseq_cat// eqseq_cons eqxx in E.\r\nby rewrite -(index_pivot s2 xNs1) (eqP E) index_pivot.\r\nQed.\r\n\r\nLemma eqseq_pivot2r x s1 s2 s3 s4 : x \\notin s2 -> x \\notin s4 ->\r\n  (s1 ++ x :: s2 == s3 ++ x :: s4) = (s1 == s3) && (s2 == s4).\r\nProof.\r\nmove=> xNs2 xNs4; rewrite -(can_eq revK) !rev_pivot.\r\nby rewrite eqseq_pivot2l ?mem_rev// !(can_eq revK) andbC.\r\nQed.\r\n\r\nLemma eqseq_pivotl x s1 s2 s3 s4 : x \\notin s1 -> x \\notin s2 ->\r\n  (s1 ++ x :: s2 == s3 ++ x :: s4) = (s1 == s3) && (s2 == s4).\r\nProof.\r\nmove=> xNs1 xNs2; apply/idP/idP => [E|/andP[/eqP-> /eqP->]//].\r\nrewrite -(@eqseq_pivot2l x)//; have /eqP/(congr1 (count_mem x)) := E.\r\nrewrite !count_cat/= eqxx !addnS (count_memPn _ _ xNs1) (count_memPn _ _ xNs2).\r\nby move=> -[/esym/eqP]; rewrite addn_eq0 => /andP[/eqP/count_memPn].\r\nQed.\r\n\r\nLemma eqseq_pivotr x s1 s2 s3 s4 : x \\notin s3 -> x \\notin s4 ->\r\n  (s1 ++ x :: s2 == s3 ++ x :: s4) = (s1 == s3) && (s2 == s4).\r\nProof.\r\nby move=> *; rewrite eq_sym eqseq_pivotl// [s3 == _]eq_sym [s4 == _]eq_sym.\r\nQed.\r\n\r\nLemma uniq_eqseq_pivotl x s1 s2 s3 s4 : uniq (s1 ++ x :: s2) ->\r\n  (s1 ++ x :: s2 == s3 ++ x :: s4) = (s1 == s3) && (s2 == s4).\r\nProof.\r\nby rewrite uniq_catC/= mem_cat => /andP[/norP[? ?] _]; rewrite eqseq_pivotl.\r\nQed.\r\n\r\nLemma uniq_eqseq_pivotr x s1 s2 s3 s4 : uniq (s3 ++ x :: s4) ->\r\n  (s1 ++ x :: s2 == s3 ++ x :: s4) = (s1 == s3) && (s2 == s4).\r\nProof.\r\nby move=> ?; rewrite eq_sym uniq_eqseq_pivotl// [s3 == _]eq_sym [s4 == _]eq_sym.\r\nQed.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-04T21:15:24Z","comment":"same proof, shorter script:\r\n```suggestion\r\nby rewrite (leq_trans (count_size _ _))// size_take; case: ltnP.\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-08T16:45:34Z","comment":"```suggestion\r\nProof. by move/index_pivot->; rewrite take_size_cat. Qed.\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-08T17:11:28Z","comment":"```suggestion\r\nProof. by move=> *; rewrite eq_sym eqseq_pivotl//; case: eqVneq => /=. Qed.\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-08T17:11:56Z","comment":"```suggestion\r\nProof. by move=> ?; rewrite eq_sym uniq_eqseq_pivotl//; case: eqVneq => /=. Qed.\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-08T20:07:32Z","comment":"```suggestion\r\nby case/subseqP => m size_m ->; rewrite rev_mask // mask_subseq.\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-08T20:11:48Z","comment":"```suggestion\r\ncase/subseqP=> m size_m ->.\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-08T20:55:33Z","comment":"There is an `Implicit Types` declaration for `s` in this section.\r\n```suggestion\r\nLemma subseq_cat2l s s1 s2 : subseq (s ++ s1) (s ++ s2) = subseq s1 s2.\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-08T20:56:03Z","comment":"```suggestion\r\nLemma subseq_cat2r s s1 s2 : subseq (s1 ++ s) (s2 ++ s) = subseq s1 s2.\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-08T20:57:33Z","comment":"The conclusion can be an equation rather than implication.\r\n```suggestion\r\nLemma uniq_subseq_pivot s1 s2 s3 s4 x (s := s3 ++ x :: s4) :\r\n  uniq s -> subseq (s1 ++ x :: s2) s = (subseq s1 s3 && subseq s2 s4).\r\nProof.\r\nmove=> uniq_s; apply/idP/idP; last first.\r\n  case/andP=> /subseqP [m1 size_m1 ->] /subseqP [m2 size_m2 ->].\r\n  by rewrite -(mask_cat (true :: _) (_ :: _)) // mask_subseq.\r\nmove=> sub_s'_s; have uniq_s' := subseq_uniq sub_s'_s uniq_s.\r\nhave/eqP {sub_s'_s uniq_s} := subseq_uniqP _ uniq_s sub_s'_s.\r\nrewrite filter_cat /= mem_cat mem_head orbT /= uniq_eqseq_pivotl //.\r\nby case/andP=> /eqP -> /eqP ->; rewrite !filter_subseq.\r\nQed.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-08T23:39:10Z","comment":"I prefer the former."},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-09T01:39:45Z","comment":"except for the extra spaces\r\n```suggestion\r\nmove=> /subseqP[m size_m ->].\r\n```"},{"author":"CohenCyril","file":"CHANGELOG_UNRELEASED.md","date":"2020-11-09T01:43:55Z","comment":"```suggestion\r\n  `uniq_eqseq_pivotl`, `uniq_eqseq_pivotr`, `mask_rcons`, `rev_mask`,\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-09T07:30:32Z","comment":"> I prefer the former.\r\n\r\nWhy do you think so?"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-09T07:30:36Z","comment":"@CohenCyril You may prefer `move=> /subseqP[m size_m ->]` over my suggestion here too."},{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2020-11-09T10:31:51Z","comment":"Of course, this could be an equality, but I don't think the direction from left to right is of much use. In particular, the direction from right to left can (after intros) be simplified to `by rewrite cat_subseq //= eqxx.` The main use of this lemma is to split the complicated assumption into simpler (more useful) ones. "},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-10T08:12:13Z","comment":"If you want to use it mainly as a view lemma, stating it using an equation can lengthen proof scripts a bit indeed. On the other hand, if you have only the implication version of this lemma and want to rewrite a subterm of the goal or hypotheses with it, I think it will be even costly."},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-10T08:14:00Z","comment":"At least, I prefer to use `&&` for conjunctions of boolean values and to perform `case/andP` when needed."},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-10T15:37:53Z","comment":"The syntax `move/view` and `case/view` is the historical syntax, views in intro pattern came later AFAIR , and for the sake of teaching, we usually only teach the latter, so whenever it does not save a line, I personally prefer when the view, case and dispatch are all regrouped in the intro pattern as in `/view[stuff]`, it looks more \"modern\" to me."},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-10T15:53:03Z","comment":"@CohenCyril I didn't know that. Thanks!"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-10T16:04:15Z","comment":"I'm not sure which one I like best, but if one keeps the implication, I'd rather have a `prod` than a  `and` in the conclusion, so as to rewrite with it, at least. BTW the variable `x` should come first in case it needs to be specified.\r\n\r\nPS: On second thoughts I think I prefer the equality, since it is more versatile, even though there is a slight overhead when one wants to transform the hypothesis, (hopefully it might be fixed by #501 someday)"},{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2020-11-11T17:08:10Z","comment":"Fine, you get your equality. "},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-11T19:30:39Z","comment":"One last detail: `x` should come first."},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-11T19:30:55Z","comment":"```suggestion\r\nLemma uniq_subseq_pivot x (s1 s2 s3 s4 : seq T) (s := s3 ++ x :: s4) :\r\n```"},{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2020-11-11T19:32:04Z","comment":"I knew I forgot something ... "},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-11T19:41:51Z","comment":"Yes, but it's all right, it's just a preference, not a requirement."}],"tags":[],"commits":[{"author":"chdoc","committer":"chdoc","hash":"7bef434688cea376694fbde648f31867d04d8d88","message":"lemmas on subseq and rot","date":"2020-11-11T19:34:26Z"},{"author":"chdoc","committer":"chdoc","hash":"188ffa169aeaf83fe111753380699f0f20915ce9","message":"suggestions from Cyril","date":"2020-11-11T19:36:39Z"},{"author":"chdoc","committer":"chdoc","hash":"cde6e5af0d272081884f3dc1813ebbbabc0198c3","message":"Apply suggestions from code review\n\nCo-authored-by: Cyril Cohen <CohenCyril@users.noreply.github.com>","date":"2020-11-11T19:36:39Z"},{"author":"chdoc","committer":"chdoc","hash":"2acb66dcb2d8e571b3edfecf70099893187a169f","message":"fixup after feedback from Cyril","date":"2020-11-11T19:36:39Z"},{"author":"chdoc","committer":"chdoc","hash":"cd8f803281d5e62fb474192605f1de455c21bc4b","message":"Apply suggestions from code review\n\nCo-authored-by: Cyril Cohen <CohenCyril@users.noreply.github.com>\nCo-authored-by: Kazuhiko Sakaguchi <pi8027@gmail.com>","date":"2020-11-11T19:36:39Z"},{"author":"chdoc","committer":"chdoc","hash":"85aee7ba9a19dceccc49c16b3d9eb295c60de774","message":"turn uniq_subseq_pivot into equality","date":"2020-11-11T19:36:39Z"},{"author":"chdoc","committer":"chdoc","hash":"b408b52bcb89468c7d61c4c56c2e7c02d8f458a8","message":"make pivot the first argument in uniq_subseq_pivot\n\nCo-authored-by: Cyril Cohen <CohenCyril@users.noreply.github.com>","date":"2020-11-11T19:38:49Z"}]}