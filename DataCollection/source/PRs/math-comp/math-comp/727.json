{"author":"pi8027","number":727,"diff_summary":[{"file":"CHANGELOG_UNRELEASED.md","status":"M","additions":241,"deletions":183},{"file":"mathcomp/ssreflect/order.v","status":"M","additions":241,"deletions":183},{"file":"mathcomp/ssreflect/path.v","status":"M","additions":241,"deletions":183},{"file":"mathcomp/ssreflect/seq.v","status":"M","additions":241,"deletions":183}],"state":"merged","open_date":"2021-03-19T12:36:45Z","update_date":"2021-05-20T13:51:29Z","discussion":[{"author":"pi8027","date":"2021-03-25T11:18:10Z","comment":"I will port some more lemmas from [coq-stablesort](https://github.com/pi8027/stablesort) which is another library dedicated to stability proofs of sort and highly optimized sorting algorithms. (It will take some more time I guess.)"}],"review_discussion":[{"author":"chdoc","file":"mathcomp/ssreflect/path.v","date":"2021-05-19T16:25:59Z","comment":"In line with the lemmas above, I think these should be named `relI_*` (rather than `*_relI`) and stated in the converse direction. Should we introduce some notation for relI, (e.g., `[relI e1 & e2]`)?"},{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2021-05-19T16:32:53Z","comment":"I think this should be `cat_nilp`, as `nilp` is a unary predicate. The same holds for `nilp_rev` below. (I'm not a fan of the special convention for unary predicates, but that's a different discussion). "},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2021-05-19T16:44:14Z","comment":"> In line with the lemmas above, I think these should be named `relI_*` (rather than `*_relI`)\r\n\r\nI don't think so: https://github.com/math-comp/math-comp/blob/57af89f67dc3ace1a35fdfdbf32be309e20f0108/mathcomp/ssreflect/seq.v#L647-L660\r\n\r\n> and stated in the converse direction.\r\n\r\nSure.\r\n\r\n> Should we introduce some notation for relI, (e.g., `[relI e1 & e2]`)?\r\n\r\nProbably, yes."},{"author":"chdoc","file":"mathcomp/ssreflect/path.v","date":"2021-05-19T17:16:11Z","comment":"I don't understand why you point to `all` here, which is a binary predicate. `CONTRIBUTING.md` states:\r\n- `naryPredicate_mainSymbol+`\r\n- `mainSymbol_unaryPredicate`\r\nSummoning @CohenCyril "},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2021-05-19T18:45:39Z","comment":"Well, one can argue whether `sorted` and `path` are really unary and `all` binary ðŸ˜¹. We tend to consider them as following the unary convention in the main argument (the list), but the binary relation plays the same role as the unary predicate in `all`.\r\n\r\nI agree the direction should be the converse one indeed (as for `all`)."},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2021-05-19T18:53:12Z","comment":"Why don't you use `[rel xy | ...]`? I wonder whether we should add `[relI r & r' ]`..."},{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2021-05-19T19:28:28Z","comment":"Isn't `[rel x y | ...]` is only for homogeneous relations?"},{"author":"chdoc","file":"mathcomp/ssreflect/path.v","date":"2021-05-19T19:40:44Z","comment":"Well, while I am not exactly a fan of the special convention for unary predicates, but I would prefer if new names were in line with preexisting names. So that means defaulting to `<main_symbol>_path`, as with the other path lemmas. Indeed, I tend to think of path as unary, where the relation should be inferable from the context and the sequence is nonempty. Even more so for sorted. But with \"for all\" neither the domain nor the predicate is a natural candidate for being implicit or inferable from the context."},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2021-05-19T20:03:22Z","comment":"I'm not 100% fan of the special convention for unary predicates either, especially when the predicate is only unary through certain lenses... However, the convention is definitely pervasive and I'm afraid it would affect even more loc than #733 itself, not to mention power users neurons... :smile:\r\n\r\nIn other `path` lemmas' name  `<main_symbol>_path`, `<main_symbol>` refers to the path sequence argument, not the relation argument. Note that before this PR, AFAICT only `merge_path` and `map_path` do follow this convention, while `path_mask` and `path_filter` are breaking it... we should fix them (in another PR).\r\n\r\nWhat I meant but maybe failed to convey is that, for me, the fact that the `<main_symbol>` is on the relation argument is a good enough reason to switch to the n+2-ary convention in the current case."},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2021-05-19T20:49:17Z","comment":"Ah yes you are right, ... such a shame though... maybe we can add notations `{rel T}` for unary and `{rel T & T'}` for binary and generalize constructions and lemmas... probably not very important though..."},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2021-05-20T03:03:39Z","comment":"The rule should be flipped"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2021-05-20T03:19:11Z","comment":"Done. Shall we open a new issue for `rel`?"},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2021-05-20T03:33:54Z","comment":"I have no strong opinion on this point but agree with the last paragraph by Cyril. Since these lemmas reason about two different graphs `e` and `e'`, `path` can be seen as a binary predicate in this particular case."},{"author":"chdoc","file":"mathcomp/ssreflect/path.v","date":"2021-05-20T07:39:18Z","comment":"Indeed, the naming of the path lemmas is not as consistent as one would hope, but that's another issue. I agree that it's hard to justify using the \"unary predicate\" convention for the cases where the main symbol is not within the \"main\" argument of a pseudo-unary predicate. So changing the direction is probably sufficient here. "}],"tags":[{"tag":"kind: enhancement","description":"Issue or PR about addition of features."},{"tag":"kind: refactoring","description":"Issue or PR about a refactoring. (reorganizing the code, reusing theorems, simplifications...)"},{"tag":"kind: clean-up","description":"This issure/PR is about cleaning up obsolete code, removing hacks, etc"}],"commits":[{"author":"pi8027","committer":"pi8027","hash":"3fc99e2afaa9c8dbcac42348dfe47d1848e29e33","message":"Add `eq(_in)_sorted` lemmas and remove deprecation aliases","date":"2021-05-19T23:37:50Z"},{"author":"pi8027","committer":"pi8027","hash":"ffd1aae50f626e5abf2ce225880f25ed0defb9b1","message":"Refactor some lemmas about `path.sort`\n\n- new lemma `allrelT` in seq.v,\n- new lemma `all_merge` in path.v, and\n- lemmas `merge_path`, `merge_sorted`, and `sort_sorted(_in)` are now derived\n  from their stable variants.","date":"2021-05-19T23:37:50Z"},{"author":"pi8027","committer":"pi8027","hash":"abc8bb1f76304f5d7e63d548517c83262dac7018","message":"More seq/path lemmas","date":"2021-05-20T02:50:29Z"},{"author":"pi8027","committer":"pi8027","hash":"97b4e3a25fddd3d7251de7e57c0d9955ea1c994d","message":"Add `homo_sort_map(_in)` lemmas","date":"2021-05-20T02:50:33Z"}]}