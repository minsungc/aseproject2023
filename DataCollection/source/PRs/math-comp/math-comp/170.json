{"author":"CohenCyril","number":170,"diff_summary":[{"file":"mathcomp/algebra/ssralg.v","status":"M","additions":14,"deletions":2}],"state":"merged","open_date":"2017-12-12T16:36:28Z","update_date":"2017-12-15T10:18:09Z","discussion":[{"author":"ggonthier","date":"2017-12-13T11:40:31Z","comment":"I'm afraid this is too much of a generalisation of #169, which provided a backchaining lemma in the vein of `subr0_eq`. These lemmas can't be used this way: one would have to formulate explicitly the `x / y = 1` subgoal, which could be inconvenient if `x` or `y` are large. Plus, I don't see the point of the rewrite multirule formulation, since either `x` or `y` can't be inferred from the left or right hand side. Finally, switching the equation sides is unnatural (the `y = ...` conclusions).\r\n  So I'd suggest sticking to the `subr0_eq` model, with perhaps a `mulr1_eq` lemma defining the inverse of `x`; perhaps we should also add an `addr0_eq` lemma for consistency?\r\n\r\n```\r\nLemma mulr1_eq x y : x * y = 1 -> x^-1 = y.\r\nProof.\r\nby move=> xy_eq1; rewrite -[LHS]mulr1 -xy_eq1; apply/mulKr/unitrPr; exists y.\r\nQed.\r\n\r\nLemma divr1_eq x y : x / y = 1 -> x = y. Proof. by move/mulr1_eq/invr_inj. Qed.\r\n```"},{"author":"CohenCyril","date":"2017-12-14T11:11:02Z","comment":"I agree this makes much more sense for backchaining. I updated my pull request accordingly.\r\nWe can merge when Travis compiles.\r\n(My original intent was not to forget that x was a unit while using this view in a forward chain. Now the user needs to make the duplication himself if he needs to, which is ok I guess.)"}],"review_discussion":[],"tags":[],"commits":[{"author":"CohenCyril","committer":"CohenCyril","hash":"c13976f1405b12009c12165aa0b5585285586dac","message":"Using x * y = 1 and x / y = 1 to derive the inverse\n\nfixes #169","date":"2017-12-14T11:07:17Z"}]}