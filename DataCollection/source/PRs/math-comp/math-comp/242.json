{"author":"anton-trunov","number":242,"diff_summary":[{"file":"mathcomp/algebra/vector.v","status":"M","additions":41,"deletions":22},{"file":"mathcomp/ssreflect/eqtype.v","status":"M","additions":41,"deletions":22},{"file":"mathcomp/ssreflect/seq.v","status":"M","additions":41,"deletions":22},{"file":"mathcomp/ssreflect/ssrnat.v","status":"M","additions":41,"deletions":22},{"file":"mathcomp/ssreflect/tuple.v","status":"M","additions":41,"deletions":22}],"state":"merged","open_date":"2018-11-12T08:45:39Z","update_date":"2018-11-19T11:07:19Z","discussion":[{"author":"amahboubi","date":"2018-11-12T08:53:40Z","comment":"Hi @anton-trunov, thanks for this PR. Yet before merging, I would like to wait for @ggonthier's feedback, since I believe he was the author of these `Canonical` declarations."},{"author":"anton-trunov","date":"2018-11-12T08:55:06Z","comment":"@amahboubi Sure thing! I would also love to learn from his input! Thanks."},{"author":"ggonthier","date":"2018-11-12T12:00:40Z","comment":"Making a mixin `Canonical` does serve a purpose: it lets type inference extrapolate the mixin and hence the corresponding packed class (when the mixing is also a class) from one of its value projections, just as one does for value projections of packed classes, such as `topred` in `predType`, or `val` and `Sub` in `subType`.\r\n  In the MathComp library this is only really implemented for `eqType`. The idea is that this makes it possible to rewrite right-to-left with lemma `eqE`, to fold back recursive comparisons after using partial evaluation to simplify a comparison on concrete instances.\r\n   The generic way to do this would be`rewrite eqE /= -!eqE`.\r\nThe reason one may need to fold back is that we need to give the full computational rule for recursive datatypes such as `nat` or `seq` _before_ we can declare a mixin, and thus it is not possible to use eq_op to do the recursive comparison.\r\n  This feature isn't used in the MathComp library, which favours using more precise specialisations of `-eqE`, such as `eqbE` or `eqseqE`, or even helpful corollaries like `eqSS` or `eqseq_cons`.\r\n   Despite this I still believe having a generic reversible `eqE` is useful, so I'd rather we let the `Canonical` declarations stand - perhaps while documenting it above `eqE` in the text, with a pointer in the `eqtype` file header.\r\n   We should point out that such `Canonical` declarations remove the need for specific inverses to `eqE` for new recursive , but can only be used for manifest mixing with a bespoke comparison function, and so is incompatible with `PcanEqMixin` and the like - this is why the `tree_eqMixin` for `GenTree.tree` in library `choice` is not declared `Canonical`."},{"author":"ggonthier","date":"2018-11-12T12:11:28Z","comment":"There is nevertheless one instance, in library `tuple`, of a `Canonical` `finMixin`. This could, in principle, make it possible to similarly fold the `Finite.enum` of a finite `tuple` type... but in practice will not work because the `mixin_enum` projector has been berried under an opaque alias, to avoid some nasty performance issues during type inference. Thus in that case you _have_ spotted an outdated `Canonical` declaration that has slipped by, and should indeed be changed to `Definition`.\r\n   Well done!"},{"author":"anton-trunov","date":"2018-11-12T17:32:09Z","comment":"@ggonthier Thank you very much for the explanation! Things are much clearer now.\r\n\r\n**(1)** I will restore the `Canonical` declarations and add some documenting comments.\r\n\r\n**(2)** If I understand correctly, declaring the mixins of *non-recursive* types as `Canonical` is still desirable if one wants to be less precise with rewriting context, e.g.`do ! [rewrite !eqE /= -!eqE].`\r\nBut this will break down for non-symmetrical equality operators such as `opt_eq` for `option` type, e.g.\r\n```coq\r\nLemma foo (b : bool) (o : option nat) :\r\n  (Some 42 == o) && (o == Some 42) && (b == false) && (false == b).\r\nProof.\r\ndo !rewrite !eqE /= -!eqE.\r\n\r\n(* the goal at this point is\r\n  oapp (fun n : nat => match n with\r\n                       | 42 => true\r\n                       | _ => false\r\n                       end) false o && (o == Some 42) && (b == false) && (false == b)\r\n*)\r\nAbort.\r\n```\r\nShould I try and fix this behavior?\r\n\r\n**(3)** It seems that `lfun_eqMixin` should *not* be declared as `Canonical`, as\r\n```coq\r\nCanonical lfun_eqMixin := Eval hnf in [eqMixin of 'Hom(aT, rT) by <:].\r\n```\r\nproduces\r\n```\r\nWarning: Projection value has no head constant: fun x y : 'Hom(aT, rT) => f2mx x == f2mx y in canonical instance lfun_eqMixin of Equality.op, ignoring\r\nit. [projection-no-head-constant,typechecker]\r\n```\r\n\r\n"},{"author":"ggonthier","date":"2018-11-12T17:42:54Z","comment":"Well observed, again!\r\n  Quick answers for (2) and (3): The fix for (2) would be to use an `Arguments` declaration to require both arguments be constructors for simplification to take place. That feature did not yet exist when the math comp library was written. Do note however that you suggested command is likely to diverge, as, if I recall correctly, `do ![tactic]` does not check for progress (perhaps it should?).\r\n   Finally, you are correct regarding `lfun` - well spotted, again."},{"author":"anton-trunov","date":"2018-11-13T09:13:28Z","comment":"> The fix for (2) would be to use an `Arguments` declaration to require both arguments be constructors for simplification to take place. \r\n\r\nThank you, `Arguments opt_eq [T] !_ !_.` seems to work fine.\r\n\r\n> if I recall correctly, `do ![tactic]` does not check for progress (perhaps it should?)\r\n\r\nMy experiments seem to show `do` does check for progress, but I could not find this in the docs. The manual says \"`!` the step tactic is repeated as many times as possible, and done at least once.\" Perhaps, @gares could clarify this a bit. If `do` really checks for progress, we could fix this behavior in Coq's test suite and add it to the manual."},{"author":"anton-trunov","date":"2018-11-13T09:48:05Z","comment":"I just pushed an updated version with more documenting commentaries. I'd be happy to add any improvements or clarifications!"},{"author":"anton-trunov","date":"2018-11-13T17:44:49Z","comment":"@ggonthier I tried to address some of your suggestions in two separate commits (I'll squash all three of the new commits afterwards). I hope I didn't miss any explicit comparison functions."},{"author":"anton-trunov","date":"2018-11-14T17:34:34Z","comment":"@ggonthier I squashed the commits, removed the redundant `eqE` description from the header and incorporated your suggestion for `pair_eq` as a `rel (T1 * T2)`."}],"review_discussion":[{"author":"ggonthier","file":"mathcomp/ssreflect/eqtype.v","date":"2018-11-13T14:03:25Z","comment":"This is not quite the right information to put in the header: the key point to make is that `EqMixin` instances should be declared `Canonical`, and this info should appear in or just after the entry for EqMixin ... which is missing in the documentation. Indeed the documentation for factories for eqType is seriously incomplete - it should have entries for all the major definitions and notation, as in `ssralg` or `fintype` (`choice` is also lacking, though less so). This needs to be addressed beforehand, ideally in a separate commit.\r\nI'll do this first so you can proceed. \r\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/tuple.v","date":"2018-11-13T14:15:39Z","comment":"See above remark concerning the multiline comment style (and punctuation)."},{"author":"ggonthier","file":"mathcomp/ssreflect/eqtype.v","date":"2018-11-13T14:16:04Z","comment":"All other explicit comparison functions will have a similar issue, so you should run through them and add similar annotations throughout.\r\nAs a rule, the type parameter(s) of a polymorphic function should be maximally inserted, as this makes it possible to use said function as one would in ML or Haskell, so you should have `{T}` instead of `[T]`."},{"author":"ggonthier","file":"mathcomp/ssreflect/eqtype.v","date":"2018-11-13T14:16:09Z","comment":"The MathComp library uses exclusively block comments, with 80-character lines enclosed in the `(*` / `*)` delimiters. Multiline comments are strictly limited to out-commented code. Please conform to this stye.\r\nAlso, that last sentence is missing its final stop."},{"author":"ggonthier","file":"mathcomp/ssreflect/eqtype.v","date":"2018-11-13T14:50:00Z","comment":"Actually, while editing the header I realised there _was_ a comment to that effect in the entry for eqType. I'll just insert the forward pointer to eqE so you won't have to do anything else."},{"author":"anton-trunov","file":"mathcomp/ssreflect/eqtype.v","date":"2018-11-13T17:40:54Z","comment":"The case of `pair_eq` is a bit tricky if we'd like to be able to fold back for the products.\r\n\r\nIf we did, then `pair_eq`'s definition would be tweaked a bit to allow for an annotation like this:\r\n```coq\r\nArguments pair_eq {T1 T2} !_ !_ /.\r\n```\r\nThen `prod_eqMixin` could be made canonical.\r\n\r\nI tried this option and only two lines (in mathcomp) needed simple fixes. I'll push the tentative changes, but I'm fine with reverting those as this breaks some things for the users relying on that previous simplifying behavior."},{"author":"ggonthier","file":"mathcomp/ssreflect/eqtype.v","date":"2018-11-14T16:14:50Z","comment":"I actually did add a forward reference to `eqE` along with more precise advice on declaring `Canonical` equality mixins in the updated documentation in the master branch. This makes this extra comment somewhat redundant, and too detailed for the header section, where, as a rule, we try to document types, definitions and notations precisely, but only describe the lemmas and theorems in general terms, because we don't want to discourage users from actually reading the documentation. There are some exceptions for some particularly important theorems, but `eqE` isn't one of those."},{"author":"ggonthier","file":"mathcomp/ssreflect/eqtype.v","date":"2018-11-14T16:45:43Z","comment":"The intent in defining `pair_eq` as a `simpl_rel`, which always simplifies when applied, is clearly to make such unfolding automatic and irreversible. This is reasonable because this yields in a readable expression. Even if you've only found one instance of this being used in the math comp library itself, I don't think it's a good idea to change this behaviour arbitrarily; I suspect there may be more instances in the Odd Order theorem proof, for one. So I would advise against that particular change.\r\n  However, in this case the `Canonical` declaration _is_ an error, because the head constant of the comparison is the generic `rel_of_simpl_rel` coercion, rather than `pair_eq` - so you are correct in using `Definition` here.\r\n   Alternatively, one could declare `pair_eq` as a `rel (T1 * T2)` and use the `/` annotation of `Arguments` to implement the unfolding behaviour; then the head constant would be `pair_eq`, and the `Canonical` declaration would be proper (though only marginally useful).\r\n  "},{"author":"anton-trunov","file":"mathcomp/ssreflect/eqtype.v","date":"2018-11-14T17:28:08Z","comment":"I agree that with `Arguments pair_eq {T1 T2} _ _ /.`, declaring `prod_eqMixin` as canonical is not particularly useful. `Arguments pair_eq {T1 T2} !_ !_ /.` seems to be a bit better in this respect (although, I agree that it's too much of a change)."},{"author":"ggonthier","file":"mathcomp/ssreflect/eqtype.v","date":"2018-11-15T09:58:55Z","comment":"While we're at it, perhaps this you should merge the `Arguments` and `Prenex Implicits` lines..."},{"author":"anton-trunov","file":"mathcomp/ssreflect/eqtype.v","date":"2018-11-15T10:02:41Z","comment":"Sure! Would you prefer if I did it for the whole file for consistency? Or just locally for the parts I touched? (so the rest of the relevant declarations could be  addressed in a separate PR)"},{"author":"ggonthier","file":"mathcomp/ssreflect/eqtype.v","date":"2018-11-15T10:19:16Z","comment":"It's probably best to do only this change for this PR (as you're touching those lines, might as well do a clean job). If you are willing, it would indeed be good to clean up the `Arguments` declarations for reflection lemmas, which are the result of a general port of old-style implicit declaration. For one thing, the intent was always to have maximal implicit arguments for reflection lemmas, but the old-style declarations only used to provide non-maximal implicits. Hence the `Prenex Implicits` declarations, which are only occasional because implicits just happen to behave like maximal implicits when the last argument is non-dependent. Putting in the proper declarations would certainly be cleaner."},{"author":"anton-trunov","file":"mathcomp/ssreflect/eqtype.v","date":"2018-11-15T19:28:31Z","comment":"Documented in #246"},{"author":"anton-trunov","file":"mathcomp/ssreflect/eqtype.v","date":"2018-11-15T19:30:27Z","comment":"Updated. I'll try to address the rest of the `Prenex Implicits` declarations for reflection lemmas in a separate PR"}],"tags":[],"commits":[{"author":"anton-trunov","committer":"anton-trunov","hash":"851d7d2dd8d968a00c2c7043ab4c1a7d5c943389","message":"Tweak code related to canonical mixins\n\nRemove some unused canonical mixins.\n  Change simplification behavior of concrete comparison functions to allow for\nbetter simplification using unfolding and sebsequent folding back e.g. with\n`rewrite !eqE /= -!eqE`.\n  A bit of cleanup for `Prenex Implicits` declarations.\n  Document some explanations by G. Gonthier.","date":"2018-11-15T10:42:36Z"}]}