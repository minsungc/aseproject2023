{"author":"ggonthier","number":434,"diff_summary":[{"file":"CHANGELOG_UNRELEASED.md","status":"M","additions":405,"deletions":379},{"file":"mathcomp/algebra/intdiv.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/algebra/mxalgebra.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/algebra/mxpoly.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/algebra/poly.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/algebra/polyXY.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/algebra/polydiv.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/algebra/ssrnum.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/character/mxrepresentation.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/field/algebraics_fundamentals.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/field/algnum.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/field/closed_field.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/field/cyclotomic.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/field/fieldext.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/field/galois.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/field/separable.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/fingroup/fingroup.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/fingroup/gproduct.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/fingroup/perm.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/solvable/abelian.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/solvable/alt.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/solvable/extraspecial.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/solvable/extremal.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/solvable/gseries.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/solvable/hall.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/solvable/jordanholder.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/solvable/maximal.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/solvable/nilpotent.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/solvable/pgroup.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/solvable/sylow.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/ssreflect/bigop.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/ssreflect/binomial.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/ssreflect/choice.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/ssreflect/div.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/ssreflect/path.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/ssreflect/prime.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/ssreflect/seq.v","status":"M","additions":405,"deletions":379},{"file":"mathcomp/ssreflect/ssrnat.v","status":"M","additions":405,"deletions":379}],"state":"merged","open_date":"2019-11-20T15:53:46Z","update_date":"2019-11-22T09:02:05Z","discussion":[{"author":"gares","date":"2019-11-22T13:12:52Z","comment":"I arrive a bit late, but my suggestion can be applied a posteriori.\r\n\r\nI believe the *diff* of this PR is very relevant for the user willing to port his files. It may be nice to have a pointer to this PR or this commit in the changelog, eg \"This commit ports math-comp to the new idiom: <link>\".\r\n\r\n"}],"review_discussion":[{"author":"amahboubi","file":"mathcomp/fingroup/perm.v","date":"2019-11-21T07:43:55Z","comment":"This idiom seems to indicate that allowing `suff <intro-pat> := ...` would be useful. "},{"author":"ybertot","file":"CHANGELOG_UNRELEASED.md","date":"2019-11-21T07:46:10Z","comment":"mesures --> measures"},{"author":"amahboubi","file":"mathcomp/solvable/abelian.v","date":"2019-11-21T07:49:30Z","comment":"Why is this `clearbody` needed? Also, I though that the idiom would by `by clearbody n`, with `by []` used only before a dot."},{"author":"ggonthier","file":"mathcomp/solvable/abelian.v","date":"2019-11-21T08:50:30Z","comment":"The `clearbody n` is executed _after_ the `have`, whose proof relies on `n` being convertible to `#|G|`. It is needed because the following line needs to abstract `n` _after_ `G`; without it Coq would complain that \"`G` occurs in `n`\". Alternatively I could have rewritten that line\r\n```\r\nelim: {G}n (G) => // n G ...\r\n```\r\nbut I felt the `clearbody` was more self-contained.\r\nI also considered adding a helper lemma in `ssrnat` to support this idiom:\r\n```\r\nVariant ubn_leq_spec m : nat -> Type := UbnLeq n of m <= n : ubn_leq_spec m n.\r\nLemma ubnPleq m : ubn_leq_spec m m. Proof. by []. Qed.\r\n```\r\nalongside a similar one for `==`, but in the end decided against this because there were relatively few instances. I can restore them by popular demand."},{"author":"ggonthier","file":"mathcomp/fingroup/perm.v","date":"2019-11-21T08:57:16Z","comment":"It would be a somewhat awkward tactic, because `have ... := ...` does not usually generate two subgoals. It only does so here because the statement of `IHn s` has the form `premise -> inductive`. This it is very much a special case; if there were more premises more subgoals would be generated."},{"author":"ggonthier","file":"CHANGELOG_UNRELEASED.md","date":"2019-11-21T09:01:51Z","comment":"Well spotted; should I also include the more direct call for clients to update as well (which I added to the PR description), perhaps splitting the paragraph between the `Added` and `Changed` sections?"},{"author":"CohenCyril","file":"mathcomp/solvable/abelian.v","date":"2019-11-21T09:12:01Z","comment":"I prefer a helper lemma.\r\nHowever the `have [] := ubnPleq x` you suggest abstracts all occurences of `x` in the goal while `have [] := ubnP x` does not, so the apparent similarity in naming could be misleading..."},{"author":"ggonthier","file":"mathcomp/solvable/abelian.v","date":"2019-11-21T09:19:28Z","comment":"There's nothing to abstract to in `ubnP M`, because the bound produced is `M.+1`. To be precise, `have [n] := ubnP M` could only replace `M` with `n.-1`, which is fairly unnatural behaviour likely to yield unusable induction hypotheses."},{"author":"CohenCyril","file":"mathcomp/solvable/abelian.v","date":"2019-11-21T09:24:01Z","comment":"OK then I am all in for your `ubnPleq`."},{"author":"ybertot","file":"CHANGELOG_UNRELEASED.md","date":"2019-11-21T09:27:48Z","comment":"I agree adding the direct call for clients to update is a good use of the CHANGELOG file."},{"author":"CohenCyril","file":"mathcomp/solvable/abelian.v","date":"2019-11-21T09:34:15Z","comment":"Alternatively if you want to factor the cases for `<=` and `==`, we could have\r\n```coq\r\nVariant ub_spec T x (r : rel T) : T -> Type := UbRefl y of r x y : ub_spec x r y.\r\nLemma ubP T (r : rel T) x : r x x -> ub_spec x r x. Proof. by []. Qed.\r\n\r\nLemma test P (m : nat) : P m.\r\nhave [n] := ubP (leqnn m).\r\nRestart.\r\nhave [n] := ubP (eqxx m).\r\nAbort.\r\n```"},{"author":"ggonthier","file":"mathcomp/solvable/abelian.v","date":"2019-11-21T10:12:39Z","comment":"I believe it would be counter-productive to have to state the proof of the (in)equality. The name `ubP` wouldn't be appropriate, because it is actually a helper lemma for selectively abstracting the argument of a bool predicate, which doesn't cover that many use cases. I'd rather use the tactic language and its context selectors in such cases. To give an example, `upP` couldn't be used to generalise `G : {group gT}` as an `H \\subset G`, because `G` actually occurs as `(mem (gval G))` in the type `G \\subset G` of `subxx G G`."},{"author":"CohenCyril","file":"mathcomp/solvable/abelian.v","date":"2019-11-21T10:32:34Z","comment":"Oh! right..."},{"author":"amahboubi","file":"mathcomp/fingroup/perm.v","date":"2019-11-21T14:38:32Z","comment":"Oh sure, I see now that my suggestion is pointless. I guess I would have created a separate, preliminary,  `have` for the proof of the premise in this case.I'm resolving the conversation anyway."},{"author":"amahboubi","file":"mathcomp/solvable/abelian.v","date":"2019-11-21T20:21:51Z","comment":"@CohenCyril is this conversation resolved?\r\n"},{"author":"amahboubi","file":"CHANGELOG_UNRELEASED.md","date":"2019-11-21T20:23:11Z","comment":"@ggonthier I propose to merge as soon as you implement @ybertot 's suggestion."},{"author":"ggonthier","file":"mathcomp/fingroup/perm.v","date":"2019-11-22T01:24:38Z","comment":"That last remark is actually a good stylistic improvement, which I've implemented."},{"author":"ggonthier","file":"CHANGELOG_UNRELEASED.md","date":"2019-11-22T01:26:26Z","comment":"Done (and squashed), along with the inclusion of the additional helpers that arose from the conversation with @CohenCyril."}],"tags":[],"commits":[{"author":"ggonthier","committer":"ggonthier","hash":"311ae6a1f9e1e22866f1c6ff3afb67e03987af96","message":"New generalised induction idiom\n\nReplaced the legacy generalised induction idiom with a more robust one\nthat does not rely on the `{-2}` numerical occurrence selector, using\neither new helper lemmas `ubnP` and `ltnSE` or a specific `nat`\ninduction principle `ltn_ind`.\n\nAdded (non-strict in)equality induction helper lemmas\n\n  Added `ubnP[lg]?eq` helper lemmas that abstract an integer expression\nalong with some (in)equality, in preparation for some generalised\ninduction. Note that while `ubnPleq` is very similar to `ubnP` (indeed\n`ubnP M` is basically `ubnPleq M.+1`), `ubnPgeq` is used to remember\nthat the inductive value remains below the initial one.\n  Used the change log to give notice to users to update the generalised\ninduction idioms in their proofs to one of the new forms before\nMathcomp 1.11.","date":"2019-11-22T01:15:49Z"}]}