{"author":"CohenCyril","number":624,"diff_summary":[{"file":"CHANGELOG_UNRELEASED.md","status":"M","additions":85,"deletions":20},{"file":"mathcomp/ssreflect/seq.v","status":"M","additions":85,"deletions":20}],"state":"merged","open_date":"2020-10-30T17:34:17Z","update_date":"2020-11-12T16:46:00Z","discussion":[{"author":"CohenCyril","date":"2020-11-08T00:39:22Z","comment":"@affeldt-aist @pi8027 comments taken into account, you may merge if you like."},{"author":"pi8027","date":"2020-11-08T12:36:53Z","comment":"Remark: `forall x, count_mem x s1 <= count_mem x s2` can be seen as a non-symmetric version of `perm_eq` (conversely, `perm_eq` is the symmetric closure of it). Defining a boolean relation for this and refactoring the `perm_eq` theory using it can probably be useful, but depending on its applications."},{"author":"CohenCyril","date":"2020-11-08T13:13:00Z","comment":"> Remark: `forall x, count_mem x s1 <= count_mem x s2` can be seen as a non-symmetric version of `perm_eq` (conversely, `perm_eq` is the symmetric closure of it). Defining a boolean relation for this and refactoring the `perm_eq` theory using it can probably be useful, but depending on its applications.\r\n\r\nGood remark, I think it's beyond the scope of this PR. Maybe you can open an issue to suggest this refactoring, but I'm not sure it's useful to anyone as of today: if it's not free and if there is no application yet, we can postpone it."},{"author":"CohenCyril","date":"2020-11-08T23:38:57Z","comment":"I think I'd also turn `count_maskP` and `count_subsetP` into equivalences."},{"author":"CohenCyril","date":"2020-11-09T00:37:36Z","comment":"> I think I'd also turn `count_maskP` and `count_subsetP` into equivalences.\r\n\r\n@pi8027 which I did, you may rereview."},{"author":"CohenCyril","date":"2020-11-11T22:19:42Z","comment":"Every remark has been attended!"}],"review_discussion":[{"author":"affeldt-aist","file":"mathcomp/ssreflect/seq.v","date":"2020-11-06T04:12:55Z","comment":"`drop_index` does not appear in the changelog"},{"author":"affeldt-aist","file":"mathcomp/ssreflect/seq.v","date":"2020-11-06T04:22:59Z","comment":"that might fit in one line by using `take_size` instead of `take_oversize`\r\n```\r\nProof. by move=>?; rewrite remE memNindex ?take_size ?drop_oversize ?cats0. Qed.\r\n```"},{"author":"affeldt-aist","file":"mathcomp/ssreflect/seq.v","date":"2020-11-06T05:05:18Z","comment":"superfluous `//` after `rem_id`"},{"author":"affeldt-aist","file":"mathcomp/ssreflect/seq.v","date":"2020-11-06T05:09:09Z","comment":"I would put `by move=> _; elim: s` with the first line using a `; last first ...` but this is maybe against the rules."},{"author":"affeldt-aist","file":"mathcomp/ssreflect/seq.v","date":"2020-11-06T05:17:08Z","comment":"This can be restated as\r\n```\r\nLemma subset_subseqP s t : (forall x, count_mem x s <= count_mem x t) ->\r\n  exists2 u, subseq u t & perm_eq s u.\r\n```\r\nso that the proof becomes a one liner"},{"author":"affeldt-aist","file":"mathcomp/ssreflect/seq.v","date":"2020-11-06T07:32:35Z","comment":"Shouldn't the name rather be `count_subseqP`?"},{"author":"affeldt-aist","file":"mathcomp/ssreflect/seq.v","date":"2020-11-06T07:33:51Z","comment":"Shouldn't the name be `count_maskP`?  Because the hypothesis is not equivalent to `{subset s1 <= s2}`."},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-06T09:43:53Z","comment":"I did not touch the proof, but I can"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-06T09:44:06Z","comment":"```suggestion\r\nhave [xs|xNs]/= := boolP (x \\in s); last by rewrite subn0 rem_id.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-06T09:51:02Z","comment":"Looks like a better name indeed."},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-06T18:58:59Z","comment":"```suggestion\r\nLemma subseq_rem x : {homo rem x : s1 s2 / @subseq T s1 s2}.\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-06T18:59:04Z","comment":"```suggestion\r\nmove=> s1 s2; elim: s2 s1 => [|x2 s2 IHs2] [|x1 s1]; rewrite ?sub0seq //=.\r\nhave [->|_] := eqVneq x1 x2; first by case: eqP => //= _ /IHs2; rewrite eqxx.\r\nmove/IHs2/subseq_trans=> -> //.\r\nhave [->|_] := eqVneq x x2; [apply: rem_subseq|apply: subseq_cons].\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-07T23:26:40Z","comment":"```suggestion\r\nLemma count_subseqP s1 s2 : (forall x, count_mem x s1 <= count_mem x s2) ->\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-07T23:27:06Z","comment":"```suggestion\r\nLemma count_maskP s1 s2 : (forall x, count_mem x s1 <= count_mem x s2) ->\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-07T23:28:43Z","comment":"I'd rather have a 3 line proof than breaking the conventions of the file (no list is named `u`)"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-07T23:29:00Z","comment":"Or maybe you can, in a separate PR :+1: "},{"author":"CohenCyril","file":"CHANGELOG_UNRELEASED.md","date":"2020-11-07T23:29:49Z","comment":"```suggestion\r\n  - in `seq.v`, added `drop_index`, `in_mask`, `cons_subseq`, `undup_subseq`,\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-07T23:30:40Z","comment":"```suggestion\r\nby move=> xNs; rewrite remE memNindex ?take_size ?drop_oversize ?cats0.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-07T23:31:30Z","comment":"```suggestion\r\nby move=> /count_maskP[m]; exists (mask m s2); rewrite ?mask_subseq.\r\n```"},{"author":"CohenCyril","file":"CHANGELOG_UNRELEASED.md","date":"2020-11-07T23:34:59Z","comment":"```suggestion\r\n    `count_maskP`, `count_subseqP`, `count_rem`, `count_mem_rem`,\r\n    `rem_cons`, `remE`,  `subseq_rem` and `leq_count_uniq`.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-08T00:36:12Z","comment":"I'm not fond of gluing `=>` with `?`,  so I took your proof, but kept the name of the introduced variable and on 3 lines."},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-08T14:35:06Z","comment":"```suggestion\r\nhave [y|m s1s2] := IHs (rem x s1); first by rewrite count_mem_rem leq_subLR.\r\nexists ((x \\in s1) :: m); case: (boolP (x \\in s1)).\r\n  by move/perm_to_rem/permPl->; rewrite perm_cons.\r\nby rewrite -(permPr s1s2); move/rem_id->.\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-09T18:08:00Z","comment":"```suggestion\r\nProof. by move=> x_s; rewrite /rot drop_index. Qed.\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-09T18:24:35Z","comment":"```suggestion\r\nhave [/perm_to_rem/permP->|xNs]/= := boolP (x \\in s); first by rewrite addKn.\r\nby rewrite subn0 rem_id.\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-09T18:32:17Z","comment":"```suggestion\r\nrewrite count_rem; have []//= := boolP (x \\in s).\r\nby case: eqP => // <- /count_memPn->.\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-09T19:31:26Z","comment":"`T` is not required to be an `eqType` here."},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-09T19:39:06Z","comment":"Here is another possible one-liner.\r\n```coq\r\nProof. by elim: s => //= y s IHs /norP[neq_yx /IHs->]; case: eqVneq neq_yx. Qed.\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-09T19:39:49Z","comment":"```suggestion\r\nsplit=> [s1_le|[m _ /permP s1ms2 x]]; last by rewrite s1ms2 leq_count_mask.\r\nsuff [m mP]: exists m, perm_eq s1 (mask m s2).\r\n  by have [m' sm' eqm] := resize_mask m s2; exists m'; rewrite -?eqm.\r\nelim: s2 => [|x s2 IHs]//= in s1 s1_le *.\r\n  by exists [::]; apply/allP => x _/=; rewrite eqn_leq s1_le.\r\nhave [y|m s1s2] := IHs (rem x s1); first by rewrite count_mem_rem leq_subLR.\r\nexists ((x \\in s1) :: m); have [|/rem_id<-//] := boolP (x \\in s1).\r\nby move/perm_to_rem/permPl->; rewrite perm_cons.\r\n```"},{"author":"pi8027","file":"CHANGELOG_UNRELEASED.md","date":"2020-11-09T19:52:04Z","comment":"```suggestion\r\n    `rem_cons`, `remE`, `subseq_rem`, and `leq_uniq_count`.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-11T22:12:33Z","comment":"Yes, it is, but not for `leq_count_mask` indeed!"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-11T23:51:02Z","comment":"The converse of this lemma also holds, and both directions hold for each `x : T`. So it should probably be something like this:\r\n```coq\r\nLemma leq_uniq_countP x s1 s2 : uniq s1 ->\r\n  reflect (x \\in s1 -> x \\in s2) (count_mem x s1 <= count_mem x s2).\r\nProof.\r\nmove/count_uniq_mem->; case: (boolP (_ \\in _)) => //= _; last by constructor.\r\nby rewrite -has_pred1 has_count; apply: (iffP idP) => //; apply.\r\nQed.\r\n```\r\nSince it aims to bridge the gap between `count_maskP` and `subset_maskP`, it is also fine to replace the last implication with `<->`."},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-12T05:50:17Z","comment":"for composition to be possible we should have your lemma and mine, untouched.\r\n\r\nblindfix!\r\n\r\n```suggestion\r\nLemma leq_uniq_countP x s1 s2 : uniq s1 ->\r\n  reflect (x \\in s1 -> x \\in s2) (count_mem x s1 <= count_mem x s2).\r\nProof.\r\nmove/count_uniq_mem->; case: (boolP (_ \\in _)) => //= _; last by constructor.\r\nby rewrite -has_pred1 has_count; apply: (iffP idP) => //; apply.\r\nQed.\r\n\r\nLemma leq_uniq_count s1 s2 : uniq s1 -> {subset s1 <= s2} ->\r\n  (forall x, count_mem x s1 <= count_mem x s2).\r\nProof. by move=> s1_uniq s1_s2 x; apply/leq_uniq_countP/s1_s2. Qed.\r\n```"},{"author":"pi8027","file":"CHANGELOG_UNRELEASED.md","date":"2020-11-12T07:31:52Z","comment":"```suggestion\r\n    `rem_cons`, `remE`, `subseq_rem`, `leq_uniq_countP`, and\r\n    `leq_uniq_count`.\r\n```"}],"tags":[],"commits":[{"author":"CohenCyril","committer":"CohenCyril","hash":"9bc96e0d82346cdd62e769332c2adfb3a12dc6b7","message":"Adding some theory for `rem` and generalizing `subset_maskP`\n\n- Added helper lemmas about `rem`: `rem_cons` (to control unfolding),\n  `remE`, `count_rem`, `count_mem_rem`, and `subseq_mem`.\n  (New lemma `drop_index` briges the gap between `cat_take_drop` and `remE`).\n- `subset_maskP`, which was not released yet is generalized with\n  hypothesis `(forall x, count_mem x s1 <= count_mem x s2)`, instead of\n  `uniq s1` and `{subset s1 <= s2}`, the previous behaviour can be\n  restored with helper lemma `leq_uniq_count`\n- Its trivial consequence `subset_subseqP` has been added too.","date":"2020-11-12T13:17:50Z"},{"author":"CohenCyril","committer":"CohenCyril","hash":"74eb80a663cb1e45147a67dfa8c190547ee850e2","message":"Shorter proofs and suggestions by Kazuhiko\n\nCo-authored-by: Kazuhiko Sakaguchi <pi8027@gmail.com>","date":"2020-11-12T13:17:50Z"},{"author":"CohenCyril","committer":"CohenCyril","hash":"94dd02febd112669b6a1543695df2eea5291dcde","message":"Equivalences instead of implications for `count_maskP` and `count_subseqP`","date":"2020-11-12T13:17:50Z"},{"author":"CohenCyril","committer":"CohenCyril","hash":"e0d5c492d95b6833879a920430833fdaa2d7b621","message":"Apply suggestions from Kazuhiko\n\nCo-authored-by: Kazuhiko Sakaguchi <pi8027@gmail.com>","date":"2020-11-12T13:17:50Z"}]}