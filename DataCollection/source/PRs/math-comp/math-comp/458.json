{"author":"pi8027","number":458,"diff_summary":[{"file":"CHANGELOG_UNRELEASED.md","status":"M","additions":1422,"deletions":417},{"file":"mathcomp/algebra/interval.v","status":"M","additions":1422,"deletions":417},{"file":"mathcomp/algebra/ssrnum.v","status":"M","additions":1422,"deletions":417},{"file":"mathcomp/ssreflect/order.v","status":"M","additions":1422,"deletions":417}],"state":"merged","open_date":"2020-01-30T10:29:13Z","update_date":"2020-09-28T14:11:49Z","discussion":[{"author":"pi8027","date":"2020-08-28T08:48:14Z","comment":"@CohenCyril This PR is ready for review."},{"author":"CohenCyril","date":"2020-08-28T14:02:19Z","comment":"Looks great! I will try to review it next week!"},{"author":"pi8027","date":"2020-09-23T07:03:13Z","comment":"I removed `bound_ltLb`, `bound_ltbR`, `ltr_in_itv`, `ler_in_itv`, and `itv_gte` for now, added `in_itv`, and confirmed that it is not so hard to port real-closed (see math-comp/real-closed#28). (I prefer to discuss addition of more lemmas separately if needed.)\r\n\r\nI will update the compatibility layer and the CHANGELOG entries later today."},{"author":"pi8027","date":"2020-09-25T03:05:58Z","comment":"Done."},{"author":"pi8027","date":"2020-09-26T09:05:27Z","comment":"I fixed a few glitches in CHANGELOG and header documentation. It may worth to double-check."},{"author":"CohenCyril","date":"2020-09-28T08:19:17Z","comment":"I think we are close to a merge! Can you rebase?"},{"author":"pi8027","date":"2020-09-28T08:22:22Z","comment":"> I think we are close to a merge! Can you rebase?\r\n\r\nDone."}],"review_discussion":[{"author":"pi8027","file":"mathcomp/algebra/interval.v","date":"2020-08-29T10:28:36Z","comment":"I think this result can be generalized by introducing the notion of the dimension of a lattice. I would say a lattice `L` is n-dimensional if \"∀x_0 ... x_n ∈ L. ∃i ∈ {0, ..., n}. ⋀_(0 ≦ j ≦ n) x_j = ⋀_(0 ≦ j ≦ n ∧ j ≠ i) x_j\" and its dual statement for the join hold. As a result, a totally ordered set is a 1-dimensional lattice, the product of n- and m-dimensional lattices forms an (n + m)-dimensional lattice, and the above lemma follows from these facts. The problem is that this wording is confusing with lattice points."},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-03T11:39:35Z","comment":"I guess this can be left for later."},{"author":"pi8027","file":"mathcomp/algebra/interval.v","date":"2020-09-03T11:41:51Z","comment":"I agree. Let me open another issue after merging this PR."},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-03T11:51:37Z","comment":"By doing this you make `le_boundl` the canonical relation between bounds (whereas `le_boundr` is \"the other one\").\r\n\r\nI think it is desirable that there is a canonical one, but I think that as such we are in big trouble.\r\n\r\nMoreover, after doing some filters in `analysis`, and sign tables in `real-closed`, I have come to think that it might be desirable to switch the `BClose_if` representation to a `BLeft_if` (with two infinities `-oo = BLInfty_if false` and `+oo = BLInfty_if true`) representation, so as to deduplicate comparison, join, etc ...\r\n\r\n```coq\r\nDefinition pred_of_itv i : pred T :=\r\n  [pred x | let: Interval l u := i in\r\n      match l with\r\n        | BLeft_if b lb => lb < x ?<= if b\r\n        | BLInfty_if b => b\r\n      end &&\r\n      match u with\r\n        | BLeft_if b ub => x < ub ?<= if ~~ b\r\n        | BLInfty_if b => ~~ b\r\n      end].\r\n```"},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-03T11:55:22Z","comment":"It could even become \r\n```coq\r\nDefinition pred_of_itv i : pred T :=\r\n  [pred x | let: Interval l u := i in (l <= BLeft_if x false) && (BLeft_if x true <= u)].\r\n```\r\n(where `Inductive bound T := BLeft_if of bool & T | BLInfty_if of bool` is canonically ordered \"from left to right\")"},{"author":"pi8027","file":"mathcomp/algebra/interval.v","date":"2020-09-04T08:55:48Z","comment":"I agree with this. It also gives us the canonical `tb(Distr)LatticeType` instance of lattices. Let me do that."},{"author":"pi8027","file":"mathcomp/algebra/interval.v","date":"2020-09-06T04:12:37Z","comment":"I think it is better to redefine `pred_of_itv` as follows:\r\n```coq\r\nDefinition pred_of_itv i : pred T := [pred x | `[x, x] <= i].\r\n```"},{"author":"pi8027","file":"mathcomp/algebra/interval.v","date":"2020-09-11T22:23:25Z","comment":"Done."},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-17T12:48:57Z","comment":"-> `bound_lexx` ?"},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-17T12:50:55Z","comment":"move to `ssrnum.v` ?"},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-17T12:51:23Z","comment":"```suggestion\r\n  BSide of bool & T | BInfty of bool.\r\n```"},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-17T12:56:24Z","comment":"In my previous review the choice of \"left if\" was intentional: it respects the convention of signs i.e. negative = true because `(-1) ^+ b` is negative iff `b` is true. That's why I'd pick `BLeft = BSide true` and `'-oo' = BInfty true`.\r\nWas there a clear advantage to use the opposite convention?"},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-17T13:00:20Z","comment":"```suggestion\r\nby [apply/lteif_imply: (lteif_trans ha ha'); case: b1 b2 ha ha' => [][] |\r\n    apply/lteif_imply: (lteif_trans hb' hb); case: b1' b2' hb hb' => [][]].\r\n```\r\n?"},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-17T13:06:31Z","comment":"Actually, I'm not sure what is the best \"default rule\" to write here.\r\nMaybe for the first one it is `true = true` and the second one `forall b, keyed b = false`? (since `x \\in Interval +oo y = false` anyway)."},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-17T13:11:53Z","comment":"I guess a generalization to `itv_gte` could be added, e.g. perhaps\r\n```coq\r\nLemma itv_ge b1 b2 : ~~ (b1 < b2) -> Interval b1 b2 =i pred0.\r\n```\r\n(if I got it right).\r\nThis looks like a consequence of `lt_in_itv : x \\in Interval b1 b2 -> b1 < b2`"},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-17T13:15:39Z","comment":"I guess top and bottom should be denoted to `+oo%bound` and `-oo%bound` in this display. "},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-17T13:19:40Z","comment":"```suggestion\r\n  by [|apply: ltW | move: (lteif_trans ha hb) => //=; exact: ltW].\r\n```\r\nshould work"},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-17T13:21:26Z","comment":"Maybe add the general version `lt_in_itv : x \\in Interval b1 b2 -> b1 < b2` too."},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-17T13:34:39Z","comment":"Splitting lemmas could now take a bound as argument instead of separate arguments of type `T` and `bool`. Would it more be convenient?\r\n```suggestion\r\nLemma itv_splitU c a b : a <= c <= b ->\r\n  forall y, y \\in Interval a b = (y \\in Interval a c) || (y \\in Interval c b).\r\n```"},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-17T13:53:20Z","comment":"This statement is not informative enough: the trivial case should be isolated from the meaningful cases by assuming the sequence is non empty. The better alternative would be to add a predicate `P` and check that `has P s` when stating the lemma:\r\n```suggestion\r\nLemma itv_total_meets_condE (I : Type) (s : seq I) (P : pred I) (F : I -> interval T) (sP : filter P s):\r\n  has P s -> \\meet_(i <- s | P i) F i \\in [seq F i `&` F j | i <- sP, j <- sP].\r\n```\r\n\r\nwith consequence:\r\n```coq\r\nLemma itv_total_meetsE (I : Type) (s : seq I) (F : I -> interval T) :\r\n  (size s > 0)%N -> \\meet_(i <- s) F i \\in [seq F i `&` F j | i <- s, j <- s].\r\n```\r\n\r\nMaybe a more general formulation would go through a function `itv_meet_seq : forall (I : Type), (I -> interval T) -> seq I -> seq I`, such that `size (itv_meet_seq s) <= 2`, `subseq (itv_meet_seq s) s` and `\\meet_(i <- s) F i = \\meet_(i <- itv_meet_seq s) F i`... I guess it depends on your usecases... can you point them out?"},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-17T13:53:47Z","comment":"move to `ssrnum.v`?"},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-17T13:54:59Z","comment":"Move to the line just after the proof of `itv_boundlr`?"},{"author":"pi8027","file":"mathcomp/algebra/interval.v","date":"2020-09-17T21:20:04Z","comment":"Since the canonical ordering of `bool` is `false < true`, I thought \"right if\" is natural. But I have no objection."},{"author":"pi8027","file":"mathcomp/algebra/interval.v","date":"2020-09-17T21:26:08Z","comment":"I would rather move them to `order.v`."},{"author":"pi8027","file":"mathcomp/algebra/interval.v","date":"2020-09-18T08:21:48Z","comment":"It is doable but we cannot use them for interval bounds of a `porderType`, since we do not have `tbPorderType`."},{"author":"pi8027","file":"mathcomp/algebra/interval.v","date":"2020-09-18T15:36:09Z","comment":"I will remove these lemmas for now and put them back as another PR to address your comment. My use cases are quantifier elimination algorithms such as Fourier–Motzkin. Inequations and their conjunction can be seen as intervals (such as `]-oo, a]` and `[b, +oo[`) and their intersection respectively."},{"author":"pi8027","file":"mathcomp/algebra/interval.v","date":"2020-09-21T08:31:15Z","comment":"They should be renamed to `lt_in_itv` and `le_in_itv` but the former one conflicts with the above `lt_in_itv`."},{"author":"pi8027","file":"mathcomp/algebra/interval.v","date":"2020-09-21T08:32:08Z","comment":"Here. Should we rename this one to `ltb_in_itv` or `lt_bound_in_itv`? @CohenCyril "},{"author":"pi8027","file":"mathcomp/algebra/interval.v","date":"2020-09-21T08:40:42Z","comment":"Yes! And I'm not sure if `itv_gte` is still useful."},{"author":"pi8027","file":"mathcomp/algebra/interval.v","date":"2020-09-21T08:49:20Z","comment":"The first case is the same as the present one, but it's fine to replace it with `true = true`. Also, I don't get what `keyed` do you mean here."},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-21T09:17:28Z","comment":"Suffix `b` is reserved for booleans. \r\nHowever, I am not completely sure about having `ltr_in_itv` anymore since it can be the composition of `lt_in_itv` and (missing) lemma `~~ C -> x < y ?<= if C -> x < y`"},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-21T09:20:08Z","comment":"cf my remark above"},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-21T09:20:18Z","comment":"Sorry, I meant `unkeyed`, cf https://github.com/coq/coq/blob/master/theories/ssr/ssreflect.v#L347-L357"},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-21T09:22:39Z","comment":"Anyway, I'm not 100% convinced that it is desirable... it would be nice is the goal is of the form `is_true _`, but otherwise it will just be weird, and anyway seeing `` `]+oo, x[`` in the context will obviously look wrong to anyone..."},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-21T09:28:58Z","comment":"I think a bettername would be `itv_splitUeq`"},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-21T09:30:16Z","comment":"Didn't `rewrite (@itv_splitU (BLeft x)) ... // (@itv_splitU (BRight x) _ b) ... //` lead to a shorter proof?"},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-21T09:33:36Z","comment":"```suggestion\r\nLemma mem0_itvcc_xNx x : (0 \\in `[- x, x]) = (0 <= x).\r\nProof. by rewrite itv_boundlr [in LHS]/<=%O /= oppr_le0 andbb. Qed.\r\n\r\nLemma mem0_itvoo_xNx x : 0 \\in `](- x), x[ = (0 < x).\r\nProof. by rewrite itv_boundlr [in LHS]/<=%O /= oppr_lt0 andbb. Qed.\r\n\r\nLemma oppr_itv ba bb (xa xb x : R) :\r\n  (- x \\in Interval (BSide ba xa) (BSide bb xb)) =\r\n  (x \\in Interval (BSide (~~ bb) (- xb)) (BSide (~~ ba) (- xa))).\r\nProof.\r\nby rewrite !itv_boundlr /<=%O /= !implybF negbK andbC lteif_oppl lteif_oppr.\r\nQed.\r\n\r\nLemma oppr_itvoo (a b x : R) : (- x \\in `]a, b[) = (x \\in `](- b), (- a)[).\r\nProof. exact: oppr_itv. Qed.\r\n\r\nLemma oppr_itvco (a b x : R) : (- x \\in `[a, b[) = (x \\in `](- b), (- a)]).\r\nProof. exact: oppr_itv. Qed.\r\n\r\nLemma oppr_itvoc (a b x : R) : (- x \\in `]a, b]) = (x \\in `[(- b), (- a)[).\r\nProof. exact: oppr_itv. Qed.\r\n\r\nLemma oppr_itvcc (a b x : R) : (- x \\in `[a, b]) = (x \\in `[(- b), (- a)]).\r\nProof. exact: oppr_itv. Qed.\r\n```"},{"author":"CohenCyril","file":"mathcomp/algebra/interval.v","date":"2020-09-22T13:54:29Z","comment":"I'm not fond of reusing suffix `b` for `bound`, maybe we can use `d`. \r\nOr maybe if this is the only occurence, we can name these lemmas `gt_BLeft` and `lt_BRight`?"},{"author":"pi8027","file":"mathcomp/algebra/interval.v","date":"2020-09-24T00:37:14Z","comment":"Should these boolean values also be opposite?"},{"author":"pi8027","file":"mathcomp/algebra/interval.v","date":"2020-09-24T00:39:32Z","comment":"According to the previous comments, it seems so. Let me do that."},{"author":"CohenCyril","file":"CHANGELOG_UNRELEASED.md","date":"2020-09-27T13:01:35Z","comment":"```suggestion\r\n  + Interval bounds `itv_bound : Type -> Type` are redefined with two constructors\r\n    `BSide : bool -> T -> itv_bound T` and `BInfty : bool -> itv_bound T`.\r\n    New notations `BLeft` and `BRight` are aliases for `BSide true` and `BSide false` respectively. \r\n    `BInfty false` and `BInfty true` respectively means positive and negative infinity.\r\n    `BLeft x` and `BRight x` respectively mean close and open bounds as left bounds,\r\n    and they respectively mean open and close bounds as right bounds.\r\n    This change gives us the canonical \"left to right\" ordering of interval bounds.\r\n```"},{"author":"CohenCyril","file":"CHANGELOG_UNRELEASED.md","date":"2020-09-27T13:07:02Z","comment":"```suggestion\r\n  + `itv_intersection` (removed, use `Order.meet` instead)\r\n  + `itv_intersection1i` (removed, use `meet1x` instead)\r\n  + `itv_intersectioni1` (removed, use `meetx1` instead)\r\n  + `itv_intersectionii` (removed, use `meetxx` instead)\r\n  + `itv_intersectionC` (removed, use `meetC` instead)\r\n  + `itv_intersectionA` (removed, use `meetA` instead)\r\n```"},{"author":"CohenCyril","file":"CHANGELOG_UNRELEASED.md","date":"2020-09-27T13:07:17Z","comment":"```suggestion\r\n- in `interval.v`, we deprecate and replace the following:\r\n```"},{"author":"pi8027","file":"CHANGELOG_UNRELEASED.md","date":"2020-09-27T16:33:25Z","comment":"We have deprecation for them and they have not been removed yet. (But indeed, they are not replacements.)"},{"author":"CohenCyril","file":"CHANGELOG_UNRELEASED.md","date":"2020-09-27T17:22:53Z","comment":"`s/removed/deprecated/` then, I just wanted to outline the fact they were subsumed by generic lemmas"},{"author":"pi8027","file":"CHANGELOG_UNRELEASED.md","date":"2020-09-28T03:35:53Z","comment":"So I would rather say:\r\n```\r\n\r\n- in `interval.v`, we deprecate the following:\r\n  + `itv_intersection` (use `Order.meet` instead)\r\n  + `itv_intersection1i` (use `meet1x` instead)\r\n  + `itv_intersectioni1` (use `meetx1` instead)\r\n  + `itv_intersectionii` (use `meetxx` instead)\r\n  + `itv_intersectionC` (use `meetC` instead)\r\n  + `itv_intersectionA` (use `meetA` instead)\r\n```"},{"author":"pi8027","file":"CHANGELOG_UNRELEASED.md","date":"2020-09-28T11:10:37Z","comment":"They should be placed in the \"Removed\" section."}],"tags":[],"commits":[{"author":"pi8027","committer":"pi8027","hash":"3e292da9f901e1032311181990bbc1dd160105bb","message":"The new interval library\n\n- `x <= y ?< if c` (lersif) has been replaced with `x < y ?<= if c'` (lteif)\n  where `c'` is negation of `c`. This change makes statements of several lemmas\n  (e.g., `lteif_orb`) easily comprehensible.\n- The first constructor `BOpen_if` of `itv_bound` has been replaced with\n  `BClose_if` where the first argument is inverted. Now `pred_of_itv` is defined\n  by using `lteif` instead of `lersif`.\n- Intervals of `T : porderType` form a `porderType` where the ordering relation\n  is the subset relation. If `T` is a `latticeType`, intervals also form a\n  `latticeType` where the join and meet are intersection and convex hull\n  respectively. They are distributive if `T` is an `orderType`.","date":"2020-09-28T11:12:56Z"},{"author":"pi8027","committer":"pi8027","hash":"1f224d39ac3e3a68652d1a6b64387c22543b2663","message":"Redefine itv_bound with BRight_if and BRInfty_if","date":"2020-09-28T11:12:56Z"},{"author":"pi8027","committer":"pi8027","hash":"29d37a333d417c1bb27f4910704fd388b49f9a78","message":"Apply suggestions from code review\n\nCo-authored-by: Cyril Cohen <CohenCyril@users.noreply.github.com>","date":"2020-09-28T11:14:02Z"}]}