{"author":"pi8027","number":740,"diff_summary":[{"file":"CHANGELOG_UNRELEASED.md","status":"M","additions":82,"deletions":52},{"file":"etc/utils/hierarchy.ml","status":"M","additions":82,"deletions":52},{"file":"mathcomp/algebra/finalg.v","status":"M","additions":82,"deletions":52},{"file":"mathcomp/algebra/ssrnum.v","status":"M","additions":82,"deletions":52}],"state":"merged","open_date":"2021-05-11T01:18:26Z","update_date":"2021-06-17T12:41:31Z","discussion":[],"review_discussion":[{"author":"CohenCyril","file":"CHANGELOG_UNRELEASED.md","date":"2021-05-26T12:10:11Z","comment":"I'm not sure I understand. It \"recognizes\" non-forgetful inheritance, but what does it do with it? Warn? Error? Tolerate given some special instructions?"}],"tags":[{"tag":"kind: fix","description":"PR that fixes a bug. Please refer to the appropriate issue(s) if relevant."}],"commits":[{"author":"pi8027","committer":"pi8027","hash":"3b7e26fff4e63deb7932df063a63637be69b7fa1","message":"Fix some inheritance issues\n\n- The way `hierachy.ml` recognizes inheritance has been changed: `S1` inherits\n  from `S2` when there is a coercion path from `S1.sort` to `S2.sort` and there\n  is a canonical structure instance that unifies `S1.sort` and `S2.sort`,\n  regardless of where (which module) these constants are declared.\n  As a result, it recognizes non-forgetful inheritance and checks the uniqueness\n  of join and exhaustiveness of canonical declarations involving it.\n- `finFieldType` now inherits from `countDecFieldType`. This should probably be\n  done with forgetful inheritance and a factory, but it remains non-forgetful\n  inheritance for now.\n- Get rid of a workaround in `ssrnum` thanks to the improvement of\n  `hierarchy.ml`.","date":"2021-06-16T08:20:42Z"}]}