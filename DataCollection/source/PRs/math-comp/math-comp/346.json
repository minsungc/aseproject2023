{"author":"palmskog","number":346,"diff_summary":[{"file":"mathcomp/ssreflect/path.v","status":"M","additions":24,"deletions":0}],"state":"closed","open_date":"2019-05-10T17:31:43Z","update_date":"2020-11-18T10:34:49Z","discussion":[{"author":"ggonthier","date":"2019-05-21T10:31:48Z","comment":"My main issue with this PR is that it introduces a fair amount of material for a result that is ultimately only useful as documentation of the algorithm (as MathComp does not provide facilities for reasoning about algorithmic complexity), while still not providing any actual natural language of the algorithm it purports to document.\r\n  At the very least there needs to be an explanatory comment describing the algorithm (along the lines of what Hugo wrote in the Coq standard library implementation of the very same), and the proof itself should be clearly marked as a documentary result and be self-contained -- see my suggestion above.\r\n   I'd actually written this review last week, but somehow failed to post it... sorry."},{"author":"ybertot","date":"2020-04-01T14:29:10Z","comment":"Dear @palmskog , we are currently looking at this PR for potential inclusion in the next release.  I just performed a rebase locally and we would mostly need to add the documentation that @ggonthier mentioned.  Will you have time to work on this on the next few days?"},{"author":"ybertot","date":"2020-04-01T14:47:54Z","comment":"For the record, the result of the rebase is visible at https://github.com/ybertot/math-comp/tree/merge-sort-push-invariant\r\nWe could work together on adding the right comment to document the behavior of `merge_sort_push` that is illustrated by your added lemma."},{"author":"CohenCyril","date":"2020-04-10T09:55:45Z","comment":"> For the record, the result of the rebase is visible at https://github.com/ybertot/math-comp/tree/merge-sort-push-invariant\r\n\r\nI think this `Remark` by @ggonthier should be merged, regardless of which other additions are planned."}],"review_discussion":[{"author":"ggonthier","file":"mathcomp/ssreflect/path.v","date":"2019-05-13T12:18:08Z","comment":"A more compact formalisation and proof that `merge_sort_push` maintains a graded list stack.\r\n```\r\nLocal Remark size_merge_sort_push s1 :\r\n  let graded ss := forall i, size (nth [::] ss i) \\in pred2 0 (2 ^ (i + 1)) in\r\n  size s1 = 2 -> {homo merge_sort_push s1 : ss / graded ss}.\r\nProof.\r\nset n := {2}1; rewrite -[RHS]/(2 ^ n) => graded sz_s1 ss.\r\nelim: ss => [|s2 ss IHss] in (n) graded s1 sz_s1 * => sz_ss i //=.\r\n  by case: i => [|[]] //; rewrite sz_s1 inE eqxx orbT.\r\ncase: s2 i => [|x s2] [|i] //= in sz_ss *; first by rewrite sz_s1 inE eqxx orbT.\r\n  exact: (sz_ss i.+1).\r\nrewrite addSnnS; apply: IHss i => [|i]; last by rewrite -addSnnS (sz_ss i.+1).\r\nby rewrite size_merge size_cat sz_s1 (eqnP (sz_ss 0)) addnn expnS mul2n.\r\nQed.\r\n```"},{"author":"ejgallego","file":"mathcomp/ssreflect/path.v","date":"2019-05-13T22:10:54Z","comment":"Maybe you could fold the case inside the intro pattern `move=> nsize2s [] //= n`."},{"author":"ejgallego","file":"mathcomp/ssreflect/path.v","date":"2019-05-13T22:17:29Z","comment":"You may want to intro the pattern a bit more: `elim: ss s1 n => [|s2 ss ihss] s1 n sizen`"},{"author":"ejgallego","file":"mathcomp/ssreflect/path.v","date":"2019-05-13T22:17:46Z","comment":"Last `move` seems unnecessary."},{"author":"ejgallego","file":"mathcomp/ssreflect/path.v","date":"2019-05-13T22:18:12Z","comment":"In the sense that you are already on the intro pattern `case: s1 sizen => //= _ s ->`"}],"tags":[],"commits":[{"author":"palmskog","committer":"palmskog","hash":"d43ad40d18a2ab64404a970bbdd274608446ebe3","message":"add lemma on merge_sort_push invariant","date":"2019-05-13T22:28:38Z"}]}