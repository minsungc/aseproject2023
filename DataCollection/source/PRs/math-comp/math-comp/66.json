{"author":"thery","number":66,"diff_summary":[{"file":"mathcomp/odd_order/PFsection9.v","status":"M","additions":35,"deletions":30},{"file":"mathcomp/ssreflect/binomial.v","status":"M","additions":35,"deletions":30}],"state":"merged","open_date":"2016-09-15T16:07:30Z","update_date":"2016-10-13T12:18:48Z","discussion":[{"author":"ggonthier","date":"2016-09-15T18:57:45Z","comment":"  Both `mul_binSn` and `mul_binnS` are good additions, and the name change to `mul_binSS` is certainly an improvement. I would have been happy with the Pascal-triangle naming scheme as well, as long as it was documented in a comment.\n  I do have an objection to the parameter naming: `'C(n, m)` is documented with parameters in that order, so it would be best if all lemmas followed that convention, which is almost the case now. Would you mind changing the statements accordingly, and setting right the other three outliers in `binomial` (`bin_gt0`, `leq_bin2l` and `bin_fact`)?\n  As I've noted on the mailing list, it might be worthwhile to generalize and simplify `mul_binSn` and `mul_binSS` by using `n.-1` instead of `n.+1` - the identities `n * 'C(n.-1, m) = m.+1 * 'C(n, m.+1)` and\n`n * 'C(n.-1, m) = (n - m) * 'C(n, m)` are valid for `n = 0` (sadly, this doesn't hold for `m` in the former).\n   I'm not sure how to handle this in your naming scheme, or in your example use; perhaps the Pascal-triangle inspired names are better after all (provided they're documented).\n  Concerning the proofs: there's no need to derive `mul_binSn` and `mul_binnS` from first principles, as the first follows from `mul_binSS` and `bin_sub`, while the second is a chaining of the first with `mul_binSS` (plus the `n=0` case, except if we go for the predecessor variants above).\n  Finally, there's a hidden defect in the `mul_binSS` proof in that it relies on the `mult_n_0` hint in the Coq prelude, thanks to stronger unification in the `trivial` tactic. We should correct this.\n  Here's my suggested code for the revised proofs using the Pasal names (for lack of a better idea) : \n\n```\nLemma bin_gt0 n m : (0 < 'C(n, m)) = (m <= n).\nProof.\nby elim: n m => [|n IHn] [|m] //; rewrite addn_gt0 !IHn orbC ltn_neqAle andKb.\nQed.\n\nLemma leq_bin2l n1 n2 m : n1 <= n2 -> 'C(n1, m) <= 'C(n2, m).\nProof.\nby elim: n1 n2 m => [|n1 IHn] [|n2] [|m] le_n12 //; rewrite leq_add ?IHn.\nQed.\n\nLemma bin_small n m : n < m -> 'C(n, m) = 0.\nProof. by rewrite ltnNge -bin_gt0; case: posnP. Qed.\n\nLemma binn n : 'C(n, n) = 1.\nProof. by elim: n => [|n IHn] //; rewrite binS bin_small. Qed.\n\n(* Multiply to move diagonally down and right in the Pascal triangle. *)\nLemma mul_bin_diag n m : n * 'C(n.-1, m) = m.+1 * 'C(n, m.+1).\nProof.\nrewrite [RHS]mulnC; elim: n m => [|[|n] IHn] [|m] //=; first by rewrite bin1.\nby rewrite mulSn [in _ * _]binS mulnDr addnCA !IHn -mulnS -mulnDl -binS.\nQed.\n\nLemma bin_fact n m : m <= n -> 'C(n, m) * (m`! * (n - m)`!) = n`!.\nProof.\nelim: n m => [|n IHn] [|m] // le_m_n; first by rewrite bin0 !mul1n.\nby rewrite !factS -!mulnA mulnCA mulnA -mul_bin_diag -mulnA IHn.\nQed.\n\n(* In fact the only exception for bin_factd is n = 0 and m = 1 *)\nLemma bin_factd n m : 0 < n -> 'C(n, m) = n`! %/ (m`! * (n - m)`!).\nProof.\nhave [/bin_fact<-|*] := leqP m n; first by rewrite mulnK ?muln_gt0 ?fact_gt0.\nby rewrite divnMA bin_small ?divn_small ?fact_gt0 ?fact_smonotone.\nQed.\n\nLemma bin_ffact n m : 'C(n, m) * m`! = n ^_ m.\nProof.\nhave [lt_n_m | le_m_n] := ltnP n m; first by rewrite bin_small ?ffact_small.\nby rewrite ffact_factd // -(bin_fact le_m_n) mulnA mulnK ?fact_gt0.\nQed.\n\nLemma bin_ffactd n m : 'C(n, m) = n ^_ m %/ m`!.\nProof. by rewrite -bin_ffact mulnK ?fact_gt0. Qed.\n\nLemma bin_sub n m : m <= n -> 'C(n, n - m) = 'C(n, m).\nProof.\nby move=> le_m_n; rewrite !bin_ffactd !ffact_factd ?leq_subr // divnAC subKn.\nQed.\n\n(* Multiply to move down in the Pascal triangle. *)\nLemma mul_bin_down n m : n * 'C(n.-1, m) = (n - m) * 'C(n, m).\nProof.\ncase: n => //= n; have [lt_n_m | le_m_n] := ltnP n m.\n  by rewrite (eqnP lt_n_m) mulnC bin_small.\nby rewrite -!['C(_, m)]bin_sub ?leqW ?subSn ?mul_bin_diag.\nQed.\n\n(* Multiply to move left in the Pascal triangle. *)\nLemma mul_bin_left n m : m.+1 * 'C(n, m.+1) = (n - m) * 'C(n, m).\nProof. by rewrite -mul_bin_diag mul_bin_down. Qed.\n\nLemma binSn n : 'C(n.+1, n) = n.+1.\nProof. by rewrite -bin_sub ?leqnSn // subSnn bin1. Qed.\n\nLemma bin2 n : 'C(n, 2) = (n * n.-1)./2.\nProof. by rewrite -[n.-1]bin1 mul_bin_diag -divn2 mulKn. Qed.\n\nLemma bin2odd n : odd n -> 'C(n, 2) = n * n.-1./2.\nProof. by case: n => // n oddn; rewrite bin2 -!divn2 muln_divA ?dvdn2. Qed.\n\nLemma prime_dvd_bin k p : prime p -> 0 < k < p -> p %| 'C(p, k).\nProof.\nmove=> p_pr /andP[k_gt0 lt_k_p].\nsuffices /Gauss_dvdr<-: coprime p (p - k) by rewrite -mul_bin_down dvdn_mulr.\nby rewrite prime_coprime // dvdn_subr 1?ltnW // gtnNdvd.\nQed.\n```\n"}],"review_discussion":[],"tags":[],"commits":[{"author":"thery","committer":"thery","hash":"88b1305ed18f783c7ec8e16ae8da1f932303742c","message":"Refactoring of binonial\n\nVariable renaming from 'C(m,n) to 'C(n,m)\nRenaming theorem mul_Sm_binn to mul_bin_diag\nAdding theorems mul_bin_left mul_bin_right","date":"2016-09-16T11:14:28Z"}]}