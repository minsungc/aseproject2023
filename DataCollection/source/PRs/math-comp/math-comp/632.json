{"author":"pi8027","number":632,"diff_summary":[{"file":"CHANGELOG_UNRELEASED.md","status":"M","additions":254,"deletions":144},{"file":"mathcomp/ssreflect/path.v","status":"M","additions":254,"deletions":144},{"file":"mathcomp/ssreflect/seq.v","status":"M","additions":254,"deletions":144}],"state":"merged","open_date":"2020-11-05T07:39:20Z","update_date":"2020-11-11T17:58:03Z","discussion":[{"author":"pi8027","date":"2020-11-06T16:20:48Z","comment":"> This already looks very solid to me. However, I wonder whether using `subseq` rather than explicit masks would simplify things. Put differently, I wonder whether there is additional complexity introduced by not requiring an `eqType`, and whether this is is justified by some application or model.\r\n\r\nIn general, I would like to make `_in` lemmas general enough to derive their specific counterparts immediately. Since `(homo|mono)_(path|cycle|sorted)` lemmas have not been derived from their `_in` counterparts, this probably does not apply to this PR. But, IMO, this is quite crucial to keep PR #601 as simple as possible, since many existing lemmas which I generalize do not require an `eqType`.\r\n\r\nAlso, I observed that `homo_sorted_in` generalized in this PR was useful to prove the following lemma (I actually managed to prove it):\r\n```coq\r\nLemma sort_map_in\r\n      (T : Type) (T' : eqType) (P : {pred T}) (f : T -> T') leT leT' :\r\n  {in P &, antisymmetric (relpre f leT')} ->\r\n  {in P & &, transitive (relpre f leT')} -> {in P &, total leT} ->\r\n  {in P &, {homo f : x y / leT x y >-> leT' x y}} ->\r\n  {in all P, forall s : seq T,\r\n        sort leT' [seq f x | x <- s] = [seq f x | x <- sort leT s]}.\r\n```"}],"review_discussion":[{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2020-11-05T10:09:13Z","comment":"I would have expected this one (and `has_mask` above) to follow from the `subseq (mask m s) s` and monotonicity of `all`. However, this requires some shuffling, so maybe it can be done in a separate PR. "},{"author":"chdoc","file":"mathcomp/ssreflect/path.v","date":"2020-11-05T10:58:02Z","comment":"maybe move the hypothesis up?"},{"author":"chdoc","file":"mathcomp/ssreflect/path.v","date":"2020-11-05T11:08:40Z","comment":"I'm a bit surprised/sad that the lemmas in this section are proved after their more specific counterparts. On the other hand, all lemmas in the `HomoPath` section are already one-liners. So maybe we can keep it as is."},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-05T11:25:48Z","comment":"Unfortunately, it breaks `abelian.v`. The arguments `x` and `s` of `order_path_min` should come before `leT_tr`. https://github.com/math-comp/math-comp/pull/358#discussion_r295259267"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-05T12:15:28Z","comment":"~I'd rather spend one more character to get better insight into the case analysis.~\r\n```suggestion\r\nelim: m s sizeE => [|[|m] ih] [|x s] //= [sizeE] /andP[Px Ps].\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-05T12:17:16Z","comment":"Using general ones to prove specific ones does not help us much here, but we can place them in the opposite order (also in the same section). Let me do so."},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-05T12:18:12Z","comment":"@chdoc Can you open a new issue for this?"},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-05T12:21:08Z","comment":"`[]` is the case analysis for the first element of `m : bitseq` here. Your suggestion does not work."},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-05T12:33:36Z","comment":"Ahah right!"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-05T12:34:13Z","comment":"I got confused between the convention for natural numbers and masks."},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-05T12:40:18Z","comment":"New suggestion then:\r\n```suggestion\r\nelim: m s sizeE => [|[] m ih] [|x s] //= [sizeE] /andP[Px Ps].\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-05T12:45:01Z","comment":"Done."},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-09T20:52:41Z","comment":"Oh, but proving `has_mask` and `all_mask` using the `subseq` lemmas specializes `T` to an `eqType`. I don't think it is a good idea."},{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2020-11-09T22:53:14Z","comment":"I'm of two minds about this. On the one hand, I agree that one should not require an `eqType` where none is required. On the other hand, I find it deeply unsatisfying to resort to induction just because `mathcomp` defines list membership (and hence list inclusion) only for `eqType`. Using the `In` predicate, whose use I'm really not advocating here, it's not too hard to prove:\r\n```coq\r\nLemma In_mask x m s : In x (mask m s) -> In x s. \r\nLemma In_all a s s' : (forall x, In x s -> In x s') -> all a s' -> all a s.\r\n\r\nLemma all_mask a m s : all a s -> all a (mask m s).\r\nProof. by apply/In_all => ?; exact: In_mask. Qed.\r\n```\r\nAgain, this is not about this specific lemma, this is about the general principle about lists as \"sets\" or \"collections\" without equality and how to reason about them. @CohenCyril do you have an opinion on the matter? \r\n\r\n"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-10T09:38:20Z","comment":"I think we should open a new issue anyway then."},{"author":"chdoc","file":"mathcomp/ssreflect/path.v","date":"2020-11-10T10:18:49Z","comment":"I'm afraid, but the lemma you removed from this PR was not the only place where the lack of an `eqType` structure makes you resort to induction where one would expect monotonicity to be used. For instance, the last line could be:\r\n```\r\nby apply/(@allP _ _ (y::s)); rewrite /= ?mem_last ?Py.\r\n```\r\nif `T` was an `eqType`. \r\n\r\n@CohenCyril , what's your position on this?"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-10T11:29:55Z","comment":"Until mathcomp introduces support for non decidable membership*, it's perfectly ok not to rely on a lemma involving `mem` to show something that does not involve an `eqType`. If it really matters, it is suggested one goes through `mkseqP` or `mkseq_nth` lemmas to index the biggest list with natural numbers `iota 0 (size the_big_list)`, and hence reduce the reasoning to the `eqType` `nat`, (which is the best we can do when we are not able to distinguish one element from another).\r\n\r\n*supporting non decidable predicates (such as `In`) would be a radical modification of mathcomp and could introduce a lot of code duplication if not done properly. But on the other hand it would be extremely useful for mathcomp-analysis, and it could be a good topic of discussion for a mathcomp meeting or rather a working group on the topic."},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-10T11:33:07Z","comment":"It's ok to \"duplicate\" short proofs."},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-10T11:34:47Z","comment":"However, maybe this proof could start with \r\n```coq\r\ncase: s => [|x s]; first by rewrite mask0.\r\nhave [n f {x s}_] := mkseqP x (x :: s); rewrite all_map cycle_map -map_mask.\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-10T12:21:09Z","comment":"I realized the fact that `leT` relates all the elements of `s` if `leT` is transitive and `cycle leT s` holds. So `cycle_(filter|mask)_in` lemmas may not be that useful. Shouldn't we rather remove them for now?"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-10T12:41:18Z","comment":"BTW you could reuse old material with the following proof, but that would be counterproductive...\r\n```coq\r\nLemma all_mask T (a : pred T) m s : all a s -> all a (mask m s).\r\nProof.\r\ncase: s => [|x s]; first by rewrite mask0.\r\nhave [n f {x s}_] := mkseqP x (x :: s); rewrite -map_mask !all_map.\r\nby move=> /allP fan; apply/allP => x /mem_mask/fan.\r\nQed.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-10T12:43:24Z","comment":"Sure, maybe there should be a proof that `cycle leT s -> allrel leT s` ?"},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-10T12:58:58Z","comment":"Good. Let me do that in another PR since #630 seems useful for it."},{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2020-11-10T13:06:09Z","comment":"I opened issue #638 to organize the larger discussion on non-decidable membership and I will ignore the issue as it comes to this PR."},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-10T13:10:52Z","comment":"@chdoc Thanks!"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-10T13:18:08Z","comment":"Ah, I discovered another one-liner!\r\n```suggestion\r\nLemma all_mask a m s : all a s -> all a (mask m s).\r\nProof. by apply/contraTT; rewrite -!has_predC; apply: has_mask. Qed.\r\n```"},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-10T13:36:56Z","comment":"I decided to put `all_mask` before `has_mask` and shorten `has_mask` similarly so that we can save one more line."},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-10T15:28:37Z","comment":"```suggestion\r\nProof. by elim: s m => [|x s IHs] [|[] m]//= /andP[ax /IHs->]; rewrite ?ax. Qed.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-10T15:29:23Z","comment":"(the induction on `s` changes nothing but I have my own tastes :wink:)"}],"tags":[{"tag":"kind: enhancement","description":"Issue or PR about addition of features."}],"commits":[{"author":"pi8027","committer":"pi8027","hash":"126a1b7be3ab3ef3cb16887bc31d0011fb4b88d4","message":"Reorganize, generalize, and add lemmas about `path`, `cycle`, and `sorted`\n\n- Add `allss` and `all_mask` lemmas.\n- Since `path`, `cycle`, and `sorted` share similar properties, these lemmas\n  have been relocated in the same place to improve the visibility. Some missing\n  lemmas have also been discovered and added.\n- Generalize `sub_path_in`, `sub_sorted_in`, and `eq_path_in` for non-`eqType` T\n  by introducing a predicate `P : {pred T}`.","date":"2020-11-10T13:31:51Z"},{"author":"pi8027","committer":"pi8027","hash":"c312c678ac8af99d5c632285cbff5e1b55325478","message":"Apply suggestions from code review\n\nCo-authored-by: Cyril Cohen <CohenCyril@users.noreply.github.com>","date":"2020-11-10T15:46:15Z"},{"author":"pi8027","committer":"pi8027","hash":"88861b5dbd2803118222fe3a020317608c4c8500","message":"Remove `cycle_(mask|filter)` lemmas","date":"2020-11-10T15:46:20Z"}]}