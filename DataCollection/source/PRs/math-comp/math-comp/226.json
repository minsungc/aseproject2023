{"author":"ybertot","number":226,"diff_summary":[],"state":"closed","open_date":"2018-09-11T13:47:35Z","update_date":"2018-12-11T09:51:54Z","discussion":[{"author":"pi8027","date":"2018-09-11T14:53:50Z","comment":"Hello. I have used `fconnect` and related lemmas to reason about union-find. My situation is a bit different but this would be nice!\r\n\r\nI found that `fconnect_step_cycle_orbit` and `fconnect_step` can be a bit generalized like this:\r\n\r\n```coq\r\nLemma fconnect_step_cycle_orbit x : fconnect f (f x) x = fcycle f (orbit x).\r\nProof.\r\napply/idP/idP.\r\n- move => c; move: (c); rewrite fconnect_orbit; case/trajectP => k Hk kq.\r\n  have oeq : order x = order (f x).\r\n    apply: eq_card=> y; rewrite !inE; apply/idP/idP; apply/connect_trans => //.\r\n    by apply/fconnect1.\r\n  suff ko : k.+1 = order x.\r\n    rewrite /orbit -orderSpred /= rcons_path /= fpath_traject andTb.\r\n    by rewrite last_traject -ko -iterS iterSr -kq eqxx.\r\n  move: Hk (orbit_uniq x); rewrite -oeq leq_eqVlt => /predU1P [-> // |].\r\n  rewrite /orbit -orderSpred ltnS /= => Hk /andP [] /negP [].\r\n  by apply/trajectP; exists k.\r\n- move: (fconnect1 x); rewrite !fconnect_orbit => H cyco.\r\n  apply/trajectP; rewrite (cycle_orbit_order_eq cyco H) {H}.\r\n  rewrite -orderSpred; exists (order x).-1 => //.\r\n  by rewrite -iterSr orderSpred cycle_orbit_iter_order.\r\nQed.\r\n\r\nLemma fconnect_step x y : fconnect f x y = (x == y) || fconnect f (f x) y.\r\nProof.\r\napply/idP/idP => [/iter_findex <- | /predU1P [<- |] //].\r\n- by case: (findex x y) => [| i]; rewrite ?eqxx // iterSr fconnect_iter orbT.\r\n- by apply/connect_trans/fconnect1.\r\nQed.\r\n```"},{"author":"pi8027","date":"2018-09-12T05:36:07Z","comment":"The proof of `order_step` can be simplified as follows by using above `fconnect_step`:\r\n\r\n```coq\r\nLemma order_step x :\r\n  order x = order (f x) /\\ iter (order x) f x = x \\/\r\n  order x = (order (f x)).+1.\r\nProof.\r\nhave [| /negP noc] := boolP (fconnect f (f x) x); last first.\r\n  right; rewrite /order; set M := fconnect f (f x); set N := pred1 x.\r\n  have ->: #|fconnect f x| = #|[predU N & M]|\r\n    by apply: eq_card=> z; rewrite !inE fconnect_step eq_sym.\r\n  rewrite -[LHS]addn0 -add1n -(card1 x) -cardUI; congr addn.\r\n  by rewrite eq_card0 // => z; rewrite !inE; apply/negP => /andP [/eqP ->].\r\nrewrite fconnect_step_cycle_orbit.\r\nleft; split; last by apply: cycle_orbit_iter_order.\r\nby apply/esym/cycle_orbit_order_eq; rewrite // -fconnect_orbit fconnect1.\r\nQed.\r\n```"},{"author":"ybertot","date":"2018-09-12T12:26:57Z","comment":"@pi8027, can you package your two suggestions in a pull request to branch fingraph-complements of ybertot/math-comp?   This way your contribution will be attributed to you."},{"author":"pi8027","date":"2018-09-13T14:46:20Z","comment":"@ybertot Thanks for merging. I think that `fcycle f (orbit f x)` ---more intuitively, `x` is in the cyclic part of the \"lasso\" or not--- is a fundamental condition of vertices in the finite graphs generated by `frel`, and there are more useful equivalent conditions and theorems around it. But I have no time to write out and reorganize them now..."},{"author":"CohenCyril","date":"2018-10-31T16:26:14Z","comment":"@ybertot please rebase on top of master."},{"author":"CohenCyril","date":"2018-11-20T12:00:22Z","comment":"@ybertot do you have any plans on progressing on this PR in the near future?"},{"author":"ybertot","date":"2018-11-20T12:10:17Z","comment":"Expect an action by Nov. 28."},{"author":"CohenCyril","date":"2018-12-11T09:53:31Z","comment":"Accidentally closed"}],"review_discussion":[],"tags":[],"commits":[]}