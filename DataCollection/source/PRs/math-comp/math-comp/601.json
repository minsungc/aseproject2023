{"author":"pi8027","number":601,"diff_summary":[{"file":"CHANGELOG_UNRELEASED.md","status":"M","additions":290,"deletions":18},{"file":"mathcomp/ssreflect/path.v","status":"M","additions":290,"deletions":18},{"file":"mathcomp/ssreflect/seq.v","status":"M","additions":290,"deletions":18},{"file":"mathcomp/ssreflect/ssrbool.v","status":"M","additions":290,"deletions":18}],"state":"merged","open_date":"2020-09-30T11:19:29Z","update_date":"2020-11-25T09:34:25Z","discussion":[{"author":"pi8027","date":"2020-10-07T16:20:22Z","comment":"There are naming inconsistencies in `eq_(path|sorted)(_in)` lemmas. :(\r\n```coq\r\neq_path\r\n     : forall (T : Type) (e e' : T -> T -> bool), e =2 e' -> path e =2 path e'\r\n\r\neq_path_in\r\n     : forall (T : eqType) (e e' : rel T) (x : T) (s : seq T),\r\n       {in x :: s &, e =2 e'} -> path e x s = path e' x s\r\n\r\neq_sorted\r\n     : forall (T : eqType) (leT : rel T),\r\n       transitive leT ->\r\n       antisymmetric leT ->\r\n       forall s1 s2 : seq T,\r\n       sorted leT s1 -> sorted leT s2 -> perm_eq s1 s2 -> s1 = s2\r\n\r\neq_sorted_in\r\n     : forall (T : eqType) (leT : rel T) (s1 : seq_predType T) (s2 : seq T),\r\n       {in s1 & &, transitive leT} ->\r\n       {in s1 &, antisymmetric leT} ->\r\n       sorted leT s1 -> sorted leT s2 -> perm_eq s1 s2 -> s1 = s2\r\n```"},{"author":"pi8027","date":"2020-10-07T17:12:38Z","comment":"~Also `path`, `cycle`, and `sorted` share some similar properties but many of them are actually missing as lemmas, e.g., the `cycle` variant of `eq_path_in` and `(homo|mono)_path(_in)`, and the `sorted` variants of `eq_path(_in)`. I guess it would be nice to move `sorted` right after the definition of `cycle` to get a better view.~ Done."},{"author":"pi8027","date":"2020-10-10T08:08:06Z","comment":"I don't think I can make more progress without some feedback. May I have some comment on the above points (naming inconsistencies, a possible generalization of `sub_path_in`, and its naming convention)?"},{"author":"CohenCyril","date":"2020-10-30T19:49:36Z","comment":"> There are naming inconsistencies in `eq_(path|sorted)(_in)` lemmas. :(\r\n\r\nNevermind, yes there is an inconsistency... I guess  `eq_sorted` should be renamed `sorted_eq` then..."},{"author":"pi8027","date":"2020-10-30T19:56:37Z","comment":"> Nevermind, yes there is an inconsistency... I guess `eq_sorted` should be renamed `sorted_eq` then...\r\n\r\nSure. So we will be able to add `eq_sorted(_in)` consistent with `eq_path(_in)` in 1.13."},{"author":"pi8027","date":"2020-10-31T12:11:27Z","comment":"FTR, deprecating `eq_sorted_irr` breaks fcsl-pcm and lemma-overloading because the deprecation facility does not support the `(ident := term)` syntax for explicit applications. https://github.com/imdea-software/fcsl-pcm/blob/1d5b78248fb1d5bec3553d64f92656e973f2b6de/pcm/unionmap.v#L3573 https://github.com/coq-community/lemma-overloading/blob/05a9f467049822eb14b3784ddaa21ddc0252c92a/theories/heaps.v#L1199"},{"author":"pi8027","date":"2020-11-04T07:05:57Z","comment":"I will write CHANGELOG entries later today. This PR is ready for review except for that."},{"author":"pi8027","date":"2020-11-04T14:51:19Z","comment":"> I will write CHANGELOG entries later today. This PR is ready for review except for that.\r\n\r\nDone."},{"author":"pi8027","date":"2020-11-05T07:44:26Z","comment":"> Moreover, it looks to me that this PR changes (much) more than just generalize the sorting lemmas. I would advocate for splitting this PR into more focused (and hence smaller) PRs, so that each part can be given proper consideration.\r\n\r\n@chdoc Sure. I separated off the first part of this PR as #632."},{"author":"chdoc","date":"2020-11-12T15:00:32Z","comment":"@pi8027 , is this PR ready for review now?"},{"author":"pi8027","date":"2020-11-12T16:41:34Z","comment":"> @pi8027 , is this PR ready for review now?\r\n\r\n@chdoc Yes."},{"author":"pi8027","date":"2020-11-12T18:54:40Z","comment":"Now I think `perm_iota_sort` is not convenient enough to perform the `mkseq` technique for `sort`. I actually rather use `mkseq_nth` often. Let me investigate before review."},{"author":"CohenCyril","date":"2020-11-12T20:07:44Z","comment":"There are two ways to add the `_in` variants,\r\n- one way is exactly what you did: prove the `_in` versions first, and then apply them to the not `_in` counterparts.\r\n- the other one is to keep the original code as such and extend it to the `_in` variants, by applying the original lemmas to `sig P` and using parametricity results (such as `path_map`, `sorted_map`, `sort_map`, etc)\r\n\r\nI wonder if the second approach wouldn't be more compact, maybe at the cost of some reusable machinery... (like `inW` etc), @pi8027 did you try it?"},{"author":"pi8027","date":"2020-11-12T21:13:27Z","comment":"@CohenCyril I thought about the second possibility but did not try it yet. Let me try. Also, I intend to separate off the renaming of `eq_sorted` lemmas as another PR to make it easy to compare these two approaches."},{"author":"pi8027","date":"2020-11-12T21:53:40Z","comment":"CI fails since coq.inria.fr is down🤦‍♂️"},{"author":"pi8027","date":"2020-11-13T15:34:18Z","comment":"Progress report: before working on another approach to add the `_in` lemmas suggested by @CohenCyril, I'm discovering some possible simplifications and generalizations of existing proofs (namely the first commit of this PR). I will probably open it as another PR."},{"author":"pi8027","date":"2020-11-19T09:48:17Z","comment":">  the other one is to keep the original code as such and extend it to the `_in` variants, by applying the original lemmas to `sig P` and using parametricity results (such as `path_map`, `sorted_map`, `sort_map`, etc)\r\n\r\nThis one seems quite successful (see https://github.com/pi8027/math-comp/commit/4c794d28703abe14c60fce540374a8ad7a5808af). Since these lemmas will not likely to be used frequently and their proofs are reasonably short, we probably don't have to add them in `path.v`. But, at least, I would like to document this proof technique somewhere. Would `sort_map(_in)` be a good example?"},{"author":"CohenCyril","date":"2020-11-19T09:55:07Z","comment":"> This one seems quite successful (see [pi8027@4c794d2](https://github.com/pi8027/math-comp/commit/4c794d28703abe14c60fce540374a8ad7a5808af)). Since these lemmas will not likely to be used frequently and their proofs are reasonably short, we probably don't have to add them in `path.v`. But, at least, I would like to document this proof technique somewhere. Would `sort_map(_in)` be a good example?\r\n\r\nActually, I think the best documentation would come from factoring out the proofs that transitivity, totality, reflexivity, irreflexivity, antisymmetry (and the ones I maybe forgot) \"in\" `P`, propagate to `sig P` and documenting the proof technique there and pointing to `sort_map(_in)` for an example of usage.\r\n\r\n(e.g. in https://github.com/pi8027/math-comp/commit/4c794d28703abe14c60fce540374a8ad7a5808af#diff-6905d3e9b2a18e19466feaed83bec790025fdc134ccc5ebba787bf9d63653544R891 and https://github.com/pi8027/math-comp/commit/4c794d28703abe14c60fce540374a8ad7a5808af#diff-6905d3e9b2a18e19466feaed83bec790025fdc134ccc5ebba787bf9d63653544R1103 the end of the line is the same and could be factored using a lemma `in_sig3 : {in A & B & C, P T1 T2 T3} -> P (sig A) (sig B) (sig C)` or something like that)"},{"author":"CohenCyril","date":"2020-11-19T17:04:19Z","comment":"cf https://github.com/CohenCyril/math-comp/commit/12ead9c5db6694d75db8a123f5a6c600cc58be99\r\n"},{"author":"CohenCyril","date":"2020-11-20T10:05:48Z","comment":"My impression is that in previous versions of this, you had many more `_in` variants. I cannot find the previous changelog anymore to compare, but is that right?"},{"author":"pi8027","date":"2020-11-20T10:22:41Z","comment":"> My impression is that in previous versions of this, you had many more `_in` variants. I cannot find the previous changelog anymore to compare, but is that right?\r\n\r\nRight. Here I have a previous version: https://github.com/pi8027/math-comp/commit/024cb1b6455fa40ea7cb902909a311033fb30108. I will put some of them back, but I'm not sure if we need all of them."},{"author":"CohenCyril","date":"2020-11-24T16:49:30Z","comment":"@chdoc I'm happy with the current state of this PR, if you are too, I will merge."}],"review_discussion":[{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-10-08T07:51:08Z","comment":"Since my previous comment has become outdated, I repeat it. I think that the following generalization of `sub_path_in` is useful:\r\n```coq\r\nLemma sub_path_in (T T' : Type) (P : {pred T}) (e e' : rel T) x s :\r\n  P x -> all P x -> {in P &, subrel e e'} -> path e x s -> path e' x s.\r\n```\r\nThis generalization may apply to all the lemmas in this section. Does it make sense? What should be the naming convention for these two variants of the `_in` lemmas? (I have the same issue in the new lemmas, e.g., `sort_sorted_in`.)"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-10-30T19:45:45Z","comment":"Yes!"},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-10-30T20:03:47Z","comment":"Also, I had a hard time to generalize this lemma. The point is that the current proof uses `perm_eq` of `seq T'`, so `T'` is currently required to be an `eqType` but it shouldn't. `T` can also be generalized to a `Type` by introducing a predicate `P : {pred T}`."},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-10-30T20:05:42Z","comment":"I think I'd state it as \r\n```coq\r\nLemma sub_path_in (T T' : Type) (P : {pred T}) (e e' : rel T) x s :\r\n  all P (x :: s) -> {in P &, subrel e e'} -> path e x s -> path e' x s.\r\n```\r\nso that we can apply it to\r\n```coq\r\nLemma all_seq {T : eqType} {s : seq T} : all (mem s) s. Proof. exact/allP. Qed.\r\n```\r\nand get back the previous behaviour..."},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-10-30T20:07:14Z","comment":"On second thought, I'm wondering whether the more general versions should be in a separate module, because applying `all_seq` by hand all the time seems a little bit... costly :confused: "},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-10-31T09:58:46Z","comment":"It seems that both `all (mem s) s` and `all (pred_of_seq s) s` appear in goals, and then the above `all_seq` can be problematic. :(\r\n```coq\r\nRequire Import all_ssreflect.\r\n\r\nLemma allss (T : eqType) (s : seq T) : all (mem s) s. Proof. exact/allP. Qed.\r\n\r\nGoal forall (T : eqType) (x : T) s, all (pred_of_seq (x :: s)) (x :: s).\r\nProof.\r\nmove=> T x s.\r\nFail apply: allss. (* ! *)\r\nexact: (allss _ (x :: s)).\r\nQed.\r\n```\r\nI think that the above `Fail apply:` reduces `pred_of_seq (x :: s)` to `(fun y => (y == x) || pred_of_seq s y)` first and then fails to unify it with `@mem _ (seq_predType _) _`."},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-10-31T12:07:47Z","comment":"I found a solution to make `allss` work both for `all (mem s) s` and `all (pred_of_seq s) s` and declared it as a hint. See `seq.v`."},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-03T15:33:47Z","comment":"Except for this point, this PR seems to be almost good enough to merge. So I would remove this lemma for now and try to add it later in another PR if there is no immediate solution."},{"author":"chdoc","file":"mathcomp/ssreflect/order.v","date":"2020-11-04T14:53:19Z","comment":"What's the rationale for `sorted_eq_lt` vs `sorted_lt_eq`? "},{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2020-11-04T15:09:17Z","comment":"Is it really necessary to add a global external hint for this? "},{"author":"pi8027","file":"mathcomp/ssreflect/order.v","date":"2020-11-05T10:51:03Z","comment":"I replaced `eq_sorted` with `sorted_eq` blindly, but `sorted_(le|lt)_eq` seems to make much sense here because they state properties of lists sorted by `<=%O` and `<%O`. So should we also rename `sorted_eq_irr(_in)` to `sorted_irr_eq(_in)`? What do you think, @CohenCyril?"},{"author":"CohenCyril","file":"mathcomp/ssreflect/order.v","date":"2020-11-11T20:41:01Z","comment":"These names do not make sense to me, `sorted` and `lt`/`le` must be next to each other.\r\nI liked `eq_sorted_(le|lt)`, but I would be fine with `sorted_(le|lt)_eq` too."},{"author":"CohenCyril","file":"mathcomp/ssreflect/order.v","date":"2020-11-11T20:41:43Z","comment":"(and same rationale with `sorted_eq_irr`)"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-11T21:34:55Z","comment":"I guess it follows from a problem from @pi8027 encountered and that I cannot find on github :disappointed: \r\nHowever, it is forbidden to use `exact:` in a `Hint Extern`, since `exact` might call `ssrdone` which calls use of level 0 hints, potentially causing a loop in some weird cases. You may use `solve [apply: stuff]` instead.\r\n(BTW I notice `exact:` is used in `ssrnum.v` which I accidentally let through...)"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-11-11T21:36:26Z","comment":"It should probably be documented as a comment in the code though..."},{"author":"pi8027","file":"mathcomp/ssreflect/seq.v","date":"2020-11-12T00:45:27Z","comment":"> I guess it follows from a problem from @pi8027 encountered and that I cannot find on github \r\n\r\nThe problem I observed in the discussion following from https://github.com/math-comp/math-comp/pull/601#discussion_r501516139 was that both `all (mem s) s` and `all (pred_of_seq s) s` appear in goals and do not reduce to each other. So stating `allss` in the form of one of them makes `apply: allss` failing for the other case. Since both `mem` and `pred_of_seq` reduce to `mem_seq`, I had to put this explicit type annotation here. Since the `Hint` facility lets us use syntactic matching to find the rules to apply, I had also to use `Hint Extern` to give that pattern explicitly (see #319).\r\n\r\n> However, it is forbidden to use `exact:` in a `Hint Extern`, since `exact` might call `ssrdone` which calls use of level 0 hints, potentially causing a loop in some weird cases. You may use `solve [apply: stuff]` instead.\r\n> (BTW I notice `exact:` is used in `ssrnum.v` which I accidentally let through...)\r\n\r\n~Sure. I will fix them.~ Done."},{"author":"pi8027","file":"mathcomp/ssreflect/order.v","date":"2020-11-12T09:45:32Z","comment":"Fixed."},{"author":"chdoc","file":"mathcomp/ssreflect/path.v","date":"2020-11-12T14:59:08Z","comment":"This is another instance where it would be really useful to be able to use the fact that `sort s` and `s` have the same elements, even if one does not have a decidable equality (#638). This isn't a blocker, I'm merely collecting examples for the aforementioned issue."},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-12T18:43:03Z","comment":"As in https://github.com/math-comp/math-comp/pull/632#discussion_r520492284, `mkseq_nth` is useful to avoid induction here.\r\n```coq\r\nLemma all_sort (T : Type) (P : {pred T}) (leT : rel T) s :\r\n  all P (sort leT s) = all P s.\r\nProof.\r\ncase: s => // x s; move: (x :: s) => {s} s.\r\nrewrite -(mkseq_nth x s) sort_map !all_map.\r\nby apply: perm_all; rewrite perm_sort.\r\nQed.\r\n```"},{"author":"chdoc","file":"mathcomp/ssreflect/path.v","date":"2020-11-12T19:28:29Z","comment":"3 (short) lines rather than 6, that's much better. Also, the use of `mkseq_nth` makes it easier to find this should there ever be list membership without decidable equality in mathcomp. Great! "},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-13T18:00:14Z","comment":"The names of these lemmas `(ltn|leq)_index` are too short in my opinion. Shouldn't we rename them to `sorted_(ltn|leq)_index`, so that these properties specialized to a `porderType` can be called `(le|lt)_sorted_(ltn|leq)_index`?"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-13T18:21:02Z","comment":"Yes indeed, note that `lt_sorted_` versions, or more generally either \"irreflexive versions\" or \"reflexive + uniq versions\" should be stronger, i.e. we should get an equality i.e. a `mono`, (and also `mono` for `sorted_le_nth` variants which should be named e.g. `uniq_sorted_nth` and `sorted_irr_nth`) under the same conditions). I was planning to add it one day, and I will do it in another PR (unless you desire to do it instead, if so please tell me), and from this perspective the renaming you suggest is a nice anticipation and maybe it should even go further renaming the current `sorted_lt_nth` to `sorted_ltn_nth` (so that `sorted_lt_nth` becomes available for the specialization of `sorted_irr_nth` to `<%O`)."},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-13T18:30:27Z","comment":"Sure. I will rename them, but will not add the irreflexive versions of them by myself (at least for now). I'm also preparing a PR to address #622 at the same time, but I will not touch this part (including `sorted_(le|lt)_nth` lemmas)."},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-13T19:35:05Z","comment":"> ... from this perspective the renaming you suggest is a nice anticipation and maybe it should even go further renaming the current `sorted_lt_nth` to `sorted_ltn_nth` (so that `sorted_lt_nth` becomes available for the specialization of `sorted_irr_nth` to `<%O`).\r\n\r\n`lt`/`le` of `sorted_(lt|le)_nth` is about indices, not about elements of `s`. So I think `irr` should come before `sorted` (e.g., `irr_sorted_lt_nth`), but it would still be nice to replace these `lt` and `le` with `ltn` and `leq` respectively."},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-18T21:45:50Z","comment":"Addressed in #650."},{"author":"pi8027","file":"mathcomp/ssreflect/path.v","date":"2020-11-23T02:38:46Z","comment":"FTR, the behavior of this intro pattern has been changed between Coq 8.11 and Coq 8.12.🙁\r\n\r\nIn Coq 8.11:\r\n```\r\n  perm_s12 : perm_eq s1 s2\r\n  ============================\r\n  sorted leT s1 -> sorted leT s2 -> perm_eq s1 s2 -> s1 = s2\r\n```\r\n\r\nIn Coq 8.12:\r\n```\r\n  perm_s12 : perm_eq s1 s2\r\n  ============================\r\n  perm_eq s1 s2 -> sorted leT s1 -> sorted leT s2 -> s1 = s2\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-23T09:12:31Z","comment":"CC @gares "},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-23T09:13:17Z","comment":"The behaviour in 8.12 is not the right one... This kind of calls for a backport..."},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-23T11:10:48Z","comment":"```suggestion\r\nmove=> /in3_sig leT_tr /in2_sig/(_ _ _ _)/val_inj leT_anti ss1 ss2 s1s2.\r\nmove: ss1 ss2 (s1s2); have /all_sigP[s1' ->] := allss s1.\r\nhave /all_sigP[{s1s2}s2 ->] : all (mem s1) s2 by rewrite -(perm_all _ s1s2).\r\nby rewrite !sorted_map => ss1' ss2 /(perm_map_inj val_inj)/(sorted_eq leT_tr)->.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-23T11:27:12Z","comment":"Even if it is slightly longer, this documents the proof in a better way.\r\n```suggestion\r\nmove=> /in3_sig leT_tr /in1_sig leT_irr + + s1s2; move: (s1s2).\r\nhave /all_sigP[s1' ->] := allss s1.\r\nhave /all_sigP[s2' ->] : all (mem s1) s2 by rewrite -(eq_all_r s1s2).\r\nrewrite !sorted_map => {}s1s2 s1_sorted s2_sorted; congr map.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-23T11:27:51Z","comment":"```suggestion\r\n  by move=> _ js _; apply/all_nthP/js/order_path_min_in.\r\nby apply/ihs/path_sorted/path_xs; case/andP: Pxs.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/path.v","date":"2020-11-23T11:29:09Z","comment":"I'd rather keep `perm_sortP` untouched, and add\r\n```coq\r\nLemma perm_sort_inP (T : eqType) (leT : rel T) (s1 s2 : seq T) :\r\n  {in s1 &, total leT} -> {in s1 & &, transitive leT} ->\r\n  {in s1 &, antisymmetric leT} ->\r\n  reflect (sort leT s1 = sort leT s2) (perm_eq s1 s2).\r\nProof.\r\nmove=> /in2_sig leT_total /in3_sig leT_tr /in2_sig/(_ _ _ _)/val_inj leT_asym.\r\napply: (iffP idP) => s1s2; last by rewrite -(perm_sort leT) s1s2 perm_sort.\r\nmove: (s1s2); have /all_sigP[s1' ->] := allss s1.\r\nhave /all_sigP[{s1s2}s2 ->] : all (mem s1) s2 by rewrite -(perm_all _ s1s2).\r\nby rewrite !sort_map => /(perm_map_inj val_inj) /(perm_sortP leT_total)->.\r\nQed.\r\n```\r\nafter the end of the section."}],"tags":[{"tag":"kind: enhancement","description":"Issue or PR about addition of features."}],"commits":[{"author":"pi8027","committer":"CohenCyril","hash":"a18a03452a84e1f54716ce20accca4e16715e382","message":"Add `_in` lemmas for `sort`","date":"2020-11-24T01:14:20Z"},{"author":"CohenCyril","committer":"CohenCyril","hash":"a0f3506f41b038d8a9935afa1e587b1ac10f7fe4","message":"factoring out in_sig","date":"2020-11-24T01:14:20Z"},{"author":"pi8027","committer":"CohenCyril","hash":"c42c0678c5de1db9f3e747a7e3b553242719d82c","message":"`in11(1)_sig` subsumes `in(2|3)_sig`","date":"2020-11-24T01:14:20Z"},{"author":"pi8027","committer":"CohenCyril","hash":"95cbf3b00c2d3709b2db9cff16c321012ff4fe62","message":"Add more `_in` lemmas and CHANGELOG entries","date":"2020-11-24T01:14:20Z"},{"author":"pi8027","committer":"CohenCyril","hash":"84d3168ae3436acec2df0b6f83e85ae7c5310ce1","message":"Apply suggestions from code review\n\nCo-authored-by: Cyril Cohen <CohenCyril@users.noreply.github.com>","date":"2020-11-24T01:14:20Z"},{"author":"CohenCyril","committer":"CohenCyril","hash":"ac30dae7377f9762ceba1c5553f0542831a0bb5c","message":"Using [dup] in path","date":"2020-11-24T01:15:48Z"}]}