{"author":"CohenCyril","number":270,"diff_summary":[{"file":".gitlab-ci.yml","status":"A","additions":8656,"deletions":1873},{"file":"CHANGELOG_UNRELEASED.md","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/Make","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/algebra/intdiv.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/algebra/interval.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/algebra/rat.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/algebra/ssralg.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/algebra/ssrint.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/algebra/ssrnum.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/character/character.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/character/classfun.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/character/inertia.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/character/integral_char.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/character/vcharacter.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/field/algC.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/field/algebraics_fundamentals.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/field/algnum.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/field/finfield.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/ssreflect/Make","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/ssreflect/all_ssreflect.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/ssreflect/fintype.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/ssreflect/order.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/ssreflect/prime.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/ssreflect/ssrnat.v","status":"A","additions":8656,"deletions":1873},{"file":"mathcomp/ssreflect/tuple.v","status":"A","additions":8656,"deletions":1873}],"state":"merged","open_date":"2019-01-18T17:08:16Z","update_date":"2019-12-11T15:46:11Z","discussion":[{"author":"Zimmi48","date":"2019-01-18T19:11:23Z","comment":"@erikmd or @CohenCyril to avoid the duplicate status checks, you can disable the GitHub integration in \"Settings\" / \"Integration\" in the GitLab repo."},{"author":"erikmd","date":"2019-01-18T19:13:02Z","comment":"Hi @Zimmi48, indeed I realized a couple of minutes ago that I had forgotten to disable the \"native GitLab/GitHub integration\" for branches reporting as it is now unnecessary given @coqbot's help. This is now done.\r\nThanks!"},{"author":"erikmd","date":"2019-01-18T19:34:35Z","comment":"Finally regarding Travis, [the script run by Travis CI](https://github.com/math-comp/math-comp/blob/b0ef24be9fe47abbcc2c82e668091d4b32283c8b/.travis.yml#L41-L43) is very similar as [the one](https://github.com/math-comp/math-comp/blob/b0ef24be9fe47abbcc2c82e668091d4b32283c8b/Dockerfile.make#L26-L29) run by [this GitLab CI job](https://github.com/math-comp/math-comp/blob/b0ef24be9fe47abbcc2c82e668091d4b32283c8b/.gitlab-ci.yml#L85), so maybe it's not worth it to also rely on Travis for each CI build?  @CohenCyril what do you think?\r\nâˆ’ I guess the URL to configure this is [that one](https://travis-ci.org/math-comp/math-comp/settings).\r\nKind regards, Erik"},{"author":"pi8027","date":"2019-01-22T18:05:04Z","comment":"Hi @CohenCyril, I had some progress on this PR. I need your help to fix `realDomainType`. Is `real_axiom` equivalent to the totality of `ler` for any `numDomainType`? If it is, should `realDomainType` be coercible to `orderType`? https://github.com/math-comp/math-comp/compare/experiment/order...pi8027:b7ff2ca"},{"author":"CohenCyril","date":"2019-01-23T10:19:13Z","comment":"Hi @pi8027, yes, this is equivalent to totality of the order relation. So there is a bit of restructuring to do.\r\nSo the class of `realDomainType` should include a mixin of totality from `order.v`. And the axiom `real_axiom` should not, but there should be a coercion from real_axiom to totality (which might require a repackaging of totality in its own record)."},{"author":"pi8027","date":"2019-01-24T15:48:53Z","comment":"Progress report: I have fixed all the structures in `ssrnum` and added all the missing coercions and canonical projections if my understanding is correct. I haven't ported `normedModType` and `NumDomain.pack` is still broken. https://github.com/math-comp/math-comp/compare/experiment/order...pi8027:978f25a"},{"author":"pi8027","date":"2019-01-31T16:15:48Z","comment":"@CohenCyril I finished to port `normedModType` but the following statement doesn't seem to be held.\r\n```\r\nLemma normr0 (R : numDomainType) (V : normedModType R) : `|0 : V| = 0.\r\n```\r\n\r\nA change for the 3rd axiom of `NormedModule.mixin_of` as follows would be needed. How do you think? https://github.com/math-comp/math-comp/compare/experiment/order...70250a5\r\n\r\n```\r\n  _ : forall x : T, (norm x == 0) = (x == 0)}.\r\n```"},{"author":"CohenCyril","date":"2019-02-01T01:09:40Z","comment":"@pi8027 no, unless I'm mistaken, since `0 <= 0`, we have that `'|0 : R| = 0` (by the last axiom of `numDomainType`) and then `'|0 : V| = '|0 *: 0| = '|0 : R| * '|0 : V|` using the 2nd axiom of `normedModType` and you should be done."},{"author":"pi8027","date":"2019-02-01T09:46:37Z","comment":"@CohenCyril I did it. Thank you!"},{"author":"pi8027","date":"2019-02-02T22:08:07Z","comment":"@CohenCyril I have a problem with canonical structures. I think that `F : numFieldType` should be coercible to `normedModType F` but it isn't. So `rewrite normr_eq0` and `rewrite (@normr_eq0 F F)` fail for `numFieldType`s. https://github.com/pi8027/math-comp/blob/ecb6dc515f9e0def5d541738270c1ba0c79d0afb/mathcomp/algebra/ssrnum.v#L3453\r\n\r\nI might have made a mistake on the definition of the canonical `normedModtype` instance of `numDomainType`. https://github.com/pi8027/math-comp/blob/ecb6dc515f9e0def5d541738270c1ba0c79d0afb/mathcomp/algebra/ssrnum.v#L1071"},{"author":"CohenCyril","date":"2019-02-04T10:18:48Z","comment":"@pi8027 In fact, there should be both coercions and canonical structures for each of the following structures: `numDomainType`, `numFieldType`, `realDomainType`, `realFieldType`, `archiRealType`, `rcfType` and `numClosedFieldType`."},{"author":"pi8027","date":"2019-02-06T17:02:26Z","comment":"I have written a compatibility module for `ssrnum` and attempted to fix `ssrint` with use of that module, but failed at [here](https://github.com/pi8027/math-comp/blob/1a89b19fd8ba5719c8a0563c616f32d5b08b89f4/mathcomp/algebra/ssrint.v#L1556) with the following error message:\r\n```\r\nError:\r\nIn nested Ltac calls to \"by (ssrhintarg)\", \"case (ssrcasearg) (ssrclauses)\" and\r\n\"(normrN m)\", last term evaluation failed.\r\nIn environment\r\nm : int\r\nThe term \"m\" has type \"int\" while it is expected to have type \"Num.NormedModule.sort ?V\".\r\n```\r\n\r\nThe type of `normrN` is:\r\n```\r\nnormrN\r\n     : forall (R : numDomainType) (V : normedModType R) (v : V), `|- v|%R = `|v|%R\r\n```\r\n\r\nIs this kind of rewriting by `normedModType` related lemmas for concrete instances succeed in the analysis library? I didn't find examples..."},{"author":"thery","date":"2019-02-06T17:39:09Z","comment":"@pi8027  \r\nLooks like the canonical mechanism is not able to lift an int into a Num.NormedModule.sort\r\nIf you  do \r\nPrint Canonical Projections.\r\ncan you see your int_normedModType?"},{"author":"pi8027","date":"2019-02-06T18:49:21Z","comment":"@thery You seem to be right. I saw the following line in the result of `Print Canonical Projections`. There is no other line including `int_normedModType`.\r\n```\r\nNum.NumDomain.sort <- Num.NormedModule.sort ( int_normedModType )\r\n```\r\n\r\nI have not understood how to fix this yet."},{"author":"CohenCyril","date":"2019-02-07T00:27:57Z","comment":"@pi8027 you need to use the `NormedModType` packager with explicit argument `int`, otherwise you won't get the right head symbol for the projection `Num.NormedModule.sort`. (Btw you need canonicals for `normedType` and `lmodType` as well)"},{"author":"thery","date":"2019-02-07T08:12:30Z","comment":"@pi8027 canonical structures are some kind of black magic. It would be nice to automate in some way all this boilerplate."},{"author":"pi8027","date":"2019-02-07T08:12:53Z","comment":"@CohenCyril Thank you. It was solved!"},{"author":"pi8027","date":"2019-02-07T09:34:23Z","comment":"@thery Yes, indeed. I need such the mechanism. :D"},{"author":"pi8027","date":"2019-02-11T14:39:53Z","comment":"I found the following problem:\r\n\r\nThe lemma `normr_ge0` is added to the hint database `core`. But it was sometimes not applied by `done` tactic when I need it because the goal doesn't syntactically match to the conclusion of the hint. This has appeared in #283.\r\n```\r\nnormr_ge0 : forall (R : numDomainType) (V : normedModType R) (v : V), 0 <= `|v|\r\n```\r\n"},{"author":"CohenCyril","date":"2019-02-12T17:23:33Z","comment":"> The lemma `normr_ge0` is added to the hint database `core`. But it was sometimes not applied by `done` tactic when I need it because the goal doesn't syntactically match to the conclusion of the hint. This has appeared in #283.\r\n\r\nHi! do you still have this problem?"},{"author":"pi8027","date":"2019-02-12T18:12:41Z","comment":"@CohenCyril Yes. Sometimes I need to put `?normr_ge0` before `//` in rewrite tactic."},{"author":"CohenCyril","date":"2019-02-14T09:59:10Z","comment":"> @CohenCyril Yes. Sometimes I need to put `?normr_ge0` before `//` in rewrite tactic.\r\n\r\nTry `Hint Extern 0 (is_true (0%R <= _)%O) => now (apply: normr_ge0) : core`"},{"author":"pi8027","date":"2019-02-14T10:33:54Z","comment":"@CohenCyril It does work well. Thank you!"},{"author":"CohenCyril","date":"2019-02-14T14:53:27Z","comment":"Could you export the compatibility module, just to check whether it suffices to make fourcolor and odd-order compile?"},{"author":"pi8027","date":"2019-02-14T15:45:37Z","comment":"@CohenCyril OK. I'm checking it in #286."},{"author":"pi8027","date":"2019-02-14T17:03:41Z","comment":"We have almost finished this PR and so is it time to check some missing things and TODOs? My concern is as follows:\r\n- `min` and `max` notations for `orderType`s would be needed (`meet` and `join` is a bit confusing in this case...),\r\n- naming of the following lemmas needs review: `(le|lt|lte)(xI|Ix|xU|Ux)`, `leIx_total`, and `lexU_total` in order.v,\r\n- the subterm selection problem in rewriting (see also #280),\r\n- I haven't understood the intents of some comments in ssrnum."},{"author":"CohenCyril","date":"2019-02-15T14:49:40Z","comment":"> * `min` and `max` notations for `orderType`s would be needed (`meet` and `join` is a bit confusing in this case...),\r\n\r\nI totally agree! Let us put them both in the `total_display` (to be defined)\r\n\r\n> * naming of the following lemmas needs review: `(le|lt|lte)(xI|Ix|xU|Ux)`, `leIx_total`, and `lexU_total` in order.v,\r\n\r\nI suggest:\r\n```coq\r\nLemma gel_leIx x y z : y <= x -> y `&` z <= x.\r\nLemma ger_leIx x y z : z <= x -> y `&` z <= x.\r\nLemma ge_leIx x y z : (y <= x) || (z <= x) -> y `&` z <= x.\r\nLemma leIx x y z : (y `&` z <= x) = (y <= x) || (z <= x).\r\n```\r\nand the \"same\" for `U`\r\n\r\n"},{"author":"CohenCyril","date":"2019-02-15T14:50:58Z","comment":"> I suggest:\r\n> \r\n> ```coq\r\n> Lemma gel_leIx x y z : y <= x -> y `&` z <= x.\r\n> Lemma ger_leIx x y z : z <= x -> y `&` z <= x.\r\n> Lemma ge_leIx x y z : (y <= x) || (z <= x) -> y `&` z <= x.\r\n> ```\r\n\r\nor maybe \r\n\r\n```coq\r\nLemma leIxl x y z : y <= x -> y `&` z <= x.\r\nLemma leIxr x y z : z <= x -> y `&` z <= x.\r\nLemma leIx2 x y z : (y <= x) || (z <= x) -> y `&` z <= x.\r\n```\r\n\r\n"},{"author":"pi8027","date":"2019-02-15T14:53:36Z","comment":"@CohenCyril I prefer `leIx(l|r|2)`. Thanks!"},{"author":"pi8027","date":"2019-02-15T16:18:28Z","comment":"@CohenCyril `fin*Type`s in order.v are undocumented. Should `finLatticeType`s have canonical `tblatticeType` instances? (top = join of all the elements, bottom = meet of all the elements. I'm not sure.)"},{"author":"pi8027","date":"2019-02-19T10:16:43Z","comment":"The remaining work would be only min and max notations if PR #288 is successfully merged."},{"author":"pi8027","date":"2019-02-25T17:42:22Z","comment":"The problem mentioned in the above review breaks my tool for drawing the hierarchy diagram (#290). But somehow I succeed to generate the correct hierarchy diagram. This diagram would be useful to make this development comprehensible: [hierarchy.pdf](https://github.com/math-comp/math-comp/files/2904785/hierarchy.pdf) (updated on Feb. 26).\r\n\r\n"},{"author":"pi8027","date":"2019-03-06T11:36:31Z","comment":"I'm trying to update the documentation of order and ssrnum. Why `NumClosedField` appears twice in the documentation of ssrnum? Which one is correct?"},{"author":"CohenCyril","date":"2019-03-06T14:48:12Z","comment":"> I'm trying to update the documentation of order and ssrnum. Why `NumClosedField` appears twice in the documentation of ssrnum? Which one is correct?\r\n\r\n:laughing: the one line 31 is incorrect."},{"author":"pi8027","date":"2019-03-18T14:53:48Z","comment":"I have no more things to do on this PR now; it is ready for review. CI failure of lemma-overloading seems irrelevant."},{"author":"pi8027","date":"2019-04-08T16:18:38Z","comment":"I will rebase this tomorrow. Some inheritance bugs might be found. (see #318)"},{"author":"pi8027","date":"2019-04-11T15:03:15Z","comment":"I have attempted to add an inheritance from `numDomainType` to `unitAlgType` by following some discussions with @CohenCyril . Now `algC.v` has a performance problem (compilation is very slow), and the join of `algType` and `comRingType` isn't unique: `numDomainType` and `fieldExtType`. [hierarchy.pdf](https://github.com/math-comp/math-comp/files/3069257/hierarchy.pdf)\r\n\r\nRedefining `idomainType` as the join of `comUnitRing` and `unitAlgType` might solve the second issue."},{"author":"CohenCyril","date":"2019-04-11T15:15:17Z","comment":"> Redefining `idomainType` as the join of `comUnitRing` and `unitAlgType` might solve the second issue.\r\n\r\nthis is option is not desirable"},{"author":"ggonthier","date":"2019-04-11T15:33:50Z","comment":"None of these are desirable; there's a reason the regular module structure on rings is only inferred for a specific tag, and the linear structure does _not_ require a module structure on its codomain."},{"author":"CohenCyril","date":"2019-04-12T18:28:44Z","comment":"@ggonthier \r\n> None of these are desirable; there's a reason the regular module structure on rings is only inferred for a specific tag, and the linear structure does _not_ require a module structure on its codomain.\r\n\r\nYes, yes, we decided to backtrack on that, and @pi8027 is now removing the inheritance of Lmodules everywhere. The common superstructure of `numDomainType` and `normedModule` (required in `math-comp/analysis`, but not anymore in `math-comp/math-comp`) will be a `NormedDomain`.\r\n\r\nBtw @pi8027, I believe that with `NormedDomain` there is no more need for the axiomless `Norm` structure, so you may remove it."},{"author":"CohenCyril","date":"2019-04-12T18:35:13Z","comment":"@thery \r\n> @pi8027 canonical structures are some kind of black magic. It would be nice to automate in some way all this boilerplate.\r\n\r\nwe are on it, and we have some ideas to make sure our users are less impacted by hierarchy refactorings than before, by providing systematic higher level blocks (factories, independent of the hierarchy, **public**) that are independent of basic blocks (mixins, dependent on the specific way the hierarchy is generated, **private**)."},{"author":"pi8027","date":"2019-04-16T13:38:38Z","comment":"Removing the `norm_scale` axiom from `NormedDomain` breaks some properties (e.g., `normr0`, `normrN`, `normr_id`). The following axioms might be needed.\r\n```\r\n  _ : forall n x, norm (x *+ n) = norm x *+ n;\r\n  _ : forall x, norm (- x) = norm x;\r\n```"},{"author":"CohenCyril","date":"2019-04-16T14:04:09Z","comment":"> Removing the `norm_scale` axiom from `NormedDomain` breaks some properties (e.g., `normr0`, `normrN`, `normr_id`). The following axioms might be needed.\r\n> \r\n> ```\r\n>   _ : forall n x, norm (x *+ n) = norm x *+ n;\r\n>   _ : forall x, norm (- x) = norm x;\r\n> ```\r\n\r\nyes!"},{"author":"pi8027","date":"2019-04-23T11:40:11Z","comment":"Remarks:\r\n- Now `[arg min_( i < n | P ) F]` and `[arg max_( i < n | P ) F]` notations are duplicated in `fintype.v` and `order.v`. We would need to make `fintype.v` and `bigop.v` depend on `order.v` and reshuffle some definitions and theorems to solve this duplication. This probably should be done in a separate PR.\r\n- Applying order related theorems (including `arg_minP` and `arg_maxP`) for `nat` requires rewriting by `leEnat` and `ltEnat`. Using overloaded ordering relation everywhere would solve this, but this may cause another difficulty because many proofs depend on that `(_ <= _)%N` and `(_ < _)%N` have the same head symbol `leq`...\r\n  ```coq\r\n  Lemma leEnat: le = leq.\r\n  Lemma ltEnat (n m : nat): (n < m) = (n < m)%N.\r\n  ```\r\n  I prefer to keep this as it is and to use `leEnat` and `ltEnat`."},{"author":"CohenCyril","date":"2019-04-23T15:59:28Z","comment":"> Remarks:\r\n> \r\n> * Now `[arg min_( i < n | P ) F]` and `[arg max_( i < n | P ) F]` notations are duplicated in `fintype.v` and `order.v`. We would need to make `fintype.v` and `bigop.v` depend on `order.v` and reshuffle some definitions and theorems to solve this duplication. This probably should be done in a separate PR.\r\n> * Applying order related theorems (including `arg_minP` and `arg_maxP`) for `nat` requires rewriting by `leEnat` and `ltEnat`. Using overloaded ordering relation everywhere would solve this, but this may cause another difficulty because many proofs depend on that `(_ <= _)%N` and `(_ < _)%N` have the same head symbol `leq`...\r\n>   ```coq\r\n>   Lemma leEnat: le = leq.\r\n>   Lemma ltEnat (n m : nat): (n < m) = (n < m)%N.\r\n>   ```\r\n>   \r\n>   \r\n>   I prefer to keep this as it is and to use `leEnat` and `ltEnat`.\r\n\r\n@pi8027 I think the theories of generic order on one side and `leq` on the other should be kept separate anyway. Hence we should/must have all the necessary duplicates, in the right scopes so as never to obtain a generic `le` or `lt` instead of a `leq` or `_ < _` by using the appropriate theorem in the library."},{"author":"pi8027","date":"2019-04-23T16:16:51Z","comment":"@CohenCyril Both polymorphic and monomorphic `arg_min`/`arg_max` notations should be defined in the `form_scope` (isn't it?). So it's not possible to use both notations selectively unless defining them with different keywords."},{"author":"pi8027","date":"2019-04-24T09:17:36Z","comment":"Using the polymorphic definitions and notations of `arg_min`/`arg_max` in both cases, deprecating monomorphic ones, and using the following lemmas in the case of `nat` might be a satisfactory solution.\r\n\r\n```coq\r\narg_minnP\r\n     : forall (I : finType) (i0 : I) (P : pred I) (F : I -> nat),\r\n       P i0 -> extremum_spec leq P F [arg min_(i < i0 | P i) F i]\r\narg_maxnP\r\n     : forall (I : finType) (i0 : I) (P : pred I) (F : I -> nat),\r\n       P i0 -> extremum_spec geq P F [arg max_(i > i0 | P i) F i]\r\n```"},{"author":"CohenCyril","date":"2019-05-15T08:54:51Z","comment":"@ggonthier do you see any objection for us to put `[arg min_(i < i0 | P i) F i]` both in the `nat_scope` and `order_scope` (depending on whether it is a `leq` or generic `le`), rather than only once in `form_scope`? The alternative is to rename the one for nat like this: `[arg minn_(i < i0 | P i) F i]`."},{"author":"ggonthier","date":"2019-05-15T10:02:51Z","comment":"No objections, @CohenCyril  - that seems a fairly natural overloading."},{"author":"pi8027","date":"2019-05-16T09:06:52Z","comment":"OK. So I will put `[arg (min|max)_...]` notations in `nat_scope`, `order_scope`, and `ring_scope`."},{"author":"pi8027","date":"2019-05-16T10:00:31Z","comment":"@CohenCyril Is this change fine? If it is, I will rebase and squash this and make use of `deprecate` notation in the compatibility module. https://github.com/pi8027/math-comp/commit/68c697174082268bbfe9c81d7bcdc9752c5fd088"},{"author":"CohenCyril","date":"2019-05-16T12:16:14Z","comment":"> @CohenCyril Is this change fine? If it is, I will rebase and squash this and make use of `deprecate` notation in the compatibility module. [pi8027@68c6971](https://github.com/pi8027/math-comp/commit/68c697174082268bbfe9c81d7bcdc9752c5fd088)\r\n\r\nLooks good to me."},{"author":"CohenCyril","date":"2019-06-13T17:19:14Z","comment":"@amahboubi @ggonthier @gares this PR is ready for review."},{"author":"CohenCyril","date":"2019-06-17T13:02:08Z","comment":"@amahboubi @ggonthier @gares I am currently fixing several issues in `order`, it should be finished by tomorrow."},{"author":"CohenCyril","date":"2019-06-18T08:20:28Z","comment":"Ok I fixed almost everything I spotted.\r\n\r\nBut, @ggonthier, @amahboubi, @thery, @gares, @LaurenceRideau, @pi8027  there is an issue for which I cannot take a light decision: `ltgtP` and `ltrgtP` do not follow the same structure as the `ltngtP` lemma from ssrnat:\r\nin `ltgtP` (and `ltrgtP`) lemma, the operators come in the following order `==`, `<=`, `<` while in `ltngtP` it is `<=`, `<` and `==`. For consistency they should be ordered in the same way, and thus there are now two options:\r\n1. For (more) backward compatibility they should be in the order  [`<=`, `<`, `==`] (as in `ltngtP`),\r\n2. but for the sake of intuition as noted by @thery and @gares in #233 it should rather be [`==`, `<=`, `<`] everywhere (as in `ltgtP`) because the last item is matched first. I think I a missing a part of the history of the lemma in order to take a decision.\r\n\r\nWhich of 1. and 2. would be best?\r\n\r\nAlso, in `leqP`, `leP` ..., operators are in the order `<=` first, and `<` while the same intuition as in the paragraph above would lead to think it should be the converse."},{"author":"gares","date":"2019-06-18T08:26:34Z","comment":"IMO 2 is best"},{"author":"pi8027","date":"2019-06-18T19:35:40Z","comment":"@CohenCyril It's worth trying the option 2."},{"author":"pi8027","date":"2019-08-28T08:48:27Z","comment":"I found that option 2 (reordering the type arguments of `ltngtP` to `[==, <=, <]`) doesn't break any libraries in CI other than fourcolor. We can provide a compatibility module so this is not so hard thing to do. (see #378)"},{"author":"pi8027","date":"2019-09-09T18:40:02Z","comment":"@amahboubi @ggonthier @gares @CohenCyril I think all the problems we found have been addressed. I have also patched fourcolor (math-comp/fourcolor#19), odd-order (math-comp/odd-order#17), and real-closed (math-comp/real-closed#16) without any use of the compatibility module. CI checks with these overlays have passed. So this PR is ready for review."},{"author":"CohenCyril","date":"2019-09-10T08:51:01Z","comment":"@amahboubi @ggonthier @gares @thery @LaurenceRideau @strub because of the size of the PR, the time it took to develop and the potential impact on the analysis library and other users, I would suggest of all mathcomp PR we give this one the highest priority for reviewing and integration. What do you think? If you have any question on how to proceed, you can tag, mail or call me to discuss it.\r\nBest wishes!"},{"author":"amahboubi","date":"2019-09-10T08:56:20Z","comment":"Hi @CohenCyril @pi8027! It is great to see this PR converging. In order to ease review and subsequent usage/documentation of the library, I suggest to have this PR as an item of our first mathcomp dev meeting of the year (I will send the message+poll today). It would be great to have a short presentation summarizing the previous issues and the solutions."},{"author":"amahboubi","date":"2019-09-16T08:50:29Z","comment":"@CohenCyril, I have unassigned you this PR, as it's no good practice to be at the same time main author and assignee."},{"author":"pi8027","date":"2019-09-25T11:52:09Z","comment":"There are two name conflicts of lemmas in `order.v`.\r\n```coq\r\nLocate lexUl.\r\nLocate lexUr.\r\n```\r\n```\r\nConstant mathcomp.ssreflect.order.Order.BLatticeTheory.lexUl\r\nConstant mathcomp.ssreflect.order.Order.LatticeTheoryJoin.lexUl\r\n  (shorter name to refer to it in current context is Order.LatticeTheoryJoin.lexUl)\r\n\r\nConstant mathcomp.ssreflect.order.Order.BLatticeTheory.lexUr\r\nConstant mathcomp.ssreflect.order.Order.LatticeTheoryJoin.lexUr\r\n  (shorter name to refer to it in current context is Order.LatticeTheoryJoin.lexUr)\r\n```\r\n~Symmetric ones of `Order.LatticeTheoryJoin.lexU(l|r)` are named `leIx(l|r)` so we probably should rename them to `leUx(l|r)`.~ Lemmas `Order.TBLatticeTheory.lexI(l|r)` are also wrongly named and should be `leIx(l|r)` by following the naming convention. But this change will introduce two more name conflicts. I think that lemmas `Order.BLatticeTheory.lexU(l|r)` and `Order.TBLatticeTheory.lexI(l|r)` should be renamed. I also wish to have a Coq plugin to detect name conflicts of imported unqualified names."},{"author":"affeldt-aist","date":"2019-10-02T12:22:05Z","comment":"TODO: in minr_l, minr_r, maxr_r, maxr_l (ssrnum.v), introduce lemmas to avoid (elimT ???) definitions"},{"author":"pi8027","date":"2019-10-04T15:31:00Z","comment":"[Note] I will do the following renamings to avoid the name conflicts of https://github.com/math-comp/math-comp/pull/270#issuecomment-534985132:\r\n- `Order.BLatticeTheory.lexUl` -> `disjoint_lexUl`,\r\n- `Order.BLatticeTheory.lexUr` -> `disjoint_lexUr`,\r\n- `Order.TBLatticeTheory.lexIl` -> `cover_leIxl`,\r\n- `Order.TBLatticeTheory.lexIr` -> `cover_leIxr`.\r\n\r\nIn a discussion happened today, I discovered that it would be nice to have the canonical `fin(C?)latticeType` instance of finsets ~(or fsets?)~. The above lemmas are lacking in `finset.v`. `set.v` seems to already implemented in this way, but I don't understand entirely yet."},{"author":"pi8027","date":"2019-10-16T08:43:11Z","comment":"> Hi @CohenCyril @pi8027! It is great to see this PR converging. In order to ease review and subsequent usage/documentation of the library, I suggest to have this PR as an item of our first mathcomp dev meeting of the year (I will send the message+poll today). It would be great to have a short presentation summarizing the previous issues and the solutions.\r\n\r\nHere is a summary of issues on the user side:\r\n- The subterm selection problem (typically in rewriting).\r\n  - Currently, we sometimes need to write patterns explicitly.\r\n- Since the type of norm function is now `forall (R : numDomainType) (V : normedZmodType R), V -> R`,\r\n  sometimes the type `V` cannot be inferred from context, e.g., `|0| = 0 :> R`.\r\n  - We need to put type annotations differently, e.g., `|0 : R| = 0`.\r\n\r\nIssues on the library side:\r\n- Hierarchy related issues\r\n  - Nonempty finite lattices always have bottom and top.\r\n    So we equated `fin(C)LatticeType`, `fin(C)BLatticeType`, and `fin(C)TBLatticeType`.\r\n  - Defining `normedModType` to inherit `lmodType` introduces an ambiguous join.\r\n    Now we redefined it as `normedZmodType` that inherit `zmodType` and is parameterized by `numDomainType`.\r\n    We cannot state some interactions between the norm and scale functions on that structure.\r\n  - Other several inheritance issues are solved by `hierarchy.ml`, which is now a part of CI.\r\n- Arguments ordering problem of comparison predicates, e.g., `ltngtP`.\r\n  - Will be separately addressed by #378.\r\n- `Hint Resolve` doesn't work to declare `normr_ge0` as a hint.\r\n  - Use `Hint Extern` instead.\r\n- Defining factories sometimes requires explicit record-eta expansion.\r\n\r\n(EDIT Oct 17)"},{"author":"CohenCyril","date":"2019-10-16T13:49:17Z","comment":"In addition, I edited the orignal post to try and input more high level explanations."},{"author":"amahboubi","date":"2019-10-16T14:16:46Z","comment":"@CohenCyril @pi8027 Thanks a lot, I think that what you added is very useful. "},{"author":"amahboubi","date":"2019-10-16T14:19:03Z","comment":"Can you elaborate on what\r\n> (which could be avoided by importing the compatibility module ssrnum.mc_1_9).\r\n\r\nmeans? Where is this compatibility module?"},{"author":"CohenCyril","date":"2019-10-16T14:27:17Z","comment":"> means? Where is this compatibility module?\r\n\r\nThe compatibility module is in `ssrnum.v` and may be used to recover part of an old set of  theorems, in order to facilitate migrations. The compatiblity module is not complete (especially wrt canonical instances) because it is technically impossible to my knowledge."},{"author":"amahboubi","date":"2019-10-18T09:04:46Z","comment":"> This work started by @CohenCyril and continued by @pi8027.\r\n\r\nI suggest removing this line. This is not fair to the other contributors, in locs or in discussions. E.g. the finmap math-comp repo acknowledges several influences, and in that repo, a file like [order.v](https://github.com/math-comp/finmap/blob/master/order.v) has received commits from more contributors."},{"author":"CohenCyril","date":"2019-10-18T09:28:26Z","comment":"> I suggest removing this line. This is not fair to the other contributors, in locs or in discussions. E.g. the finmap math-comp repo acknowledges several influences, and in that repo, a file like [order.v](https://github.com/math-comp/finmap/blob/master/order.v) has received commits from more contributors.\r\n\r\ndone"},{"author":"affeldt-aist","date":"2019-10-19T17:29:03Z","comment":"For information, it was possible to use this PR to rebase mathcomp-analysis on top of it, which means essentially to use the norm provided by ssrnum.v to subsume the several notions of norms that were used in the current version of mathcomp-analysis. This went well except for problems that have been reported and could be quickly fixed. This rebasing led to substantial simplifications in mathcomp-analysis. See https://github.com/math-comp/analysis/tree/analysis_270."},{"author":"amahboubi","date":"2019-10-23T09:00:26Z","comment":"TODO list on order.v:\r\n- header:  remove misleading sentences, list the notations and definitions introduced by the library\r\n- header: document better the tagging mechanism allowing to work with different order structures on a same type. This could be in the header and/or in later in the file\r\n- remove the no-op last Import\r\n- header: improve the documentation of what you get by importing selected of sub-modules \r\n- BTW do we need Order.Def?\r\n- What about importing Order.Syntax in all of the subsequent Order.LTheory, Order.TTheory, etc. Note: a Syntax module is only useful to solve potential grammar conflicts. Which does not seem to be the case here.\r\n- ensure all notations do have a scope\r\n- declare instances for division on nat inside this file, and use this as a documentation/template \r\n"},{"author":"amahboubi","date":"2019-10-23T09:25:16Z","comment":"Timline:\r\n- TODO list addressed for Oct. 25th\r\n- Merge <= Oct. 31st."},{"author":"pi8027","date":"2019-10-23T17:52:20Z","comment":"I found one more TODO. Factories in `ssrnum` are undocumented."},{"author":"pi8027","date":"2019-10-23T20:16:10Z","comment":"> * BTW do we need Order.Def?\r\n\r\nI think `Order.Def` is used only for this kind of explicit application: https://github.com/math-comp/math-comp/blob/8c8a9225479b72bc00252ca24eb4338bd06e9751/mathcomp/algebra/ssrnum.v#L371-L394 Having only *qualified* names such as `Order.le`, `Order.lt`, `Order.ge`, `Order.gt` might be enough for this.\r\n\r\n> * What about importing Order.Syntax in all of the subsequent Order.LTheory, Order.TTheory, etc. Note: a Syntax module is only useful to solve potential grammar conflicts. Which does not seem to be the case here.\r\n\r\nSince `Num.Syntax` is exported by default, doing the same for `Order.Syntax` might be better. Actually it works."},{"author":"CohenCyril","date":"2019-10-24T07:41:55Z","comment":"> I think `Order.Def` is used only for this kind of explicit application:\r\n\r\nThis can be done using scopes rather than modules and it should...\r\nAll of these notations should be in ring_scope."},{"author":"CohenCyril","date":"2019-10-24T07:47:22Z","comment":"> > I think `Order.Def` is used only for this kind of explicit application:\r\n> \r\n> This can be done using scopes rather than modules and it should...\r\n> All of these notations should be in ring_scope.\r\n\r\nOh no, it cannot... but simple notations are prefixed with their module and we maybe can \"hack\" the other ones to include it `\"@ 'Num.le' R\"` "},{"author":"pi8027","date":"2019-10-24T11:33:07Z","comment":"> Oh no, it cannot... but simple notations are prefixed with their module and we maybe can \"hack\" the other ones to include it `\"@ 'Num.le' R\"`\r\n\r\nAnyway, we need to make symbols like `Order.Def.lt` qualified or disambiguated with a suffix. Just making them qualified can be done by turning `Def` modules such as `Order.POrderDef` to sections and removing the `Order.Def` module. In this way, we don't need that hack."},{"author":"amahboubi","date":"2019-10-24T12:33:17Z","comment":"Naive question : what is this block of notation without a scope?"},{"author":"pi8027","date":"2019-10-24T13:30:55Z","comment":"@amahboubi `Num.Def.(ler|ltr|...)` were `Definition`s before this change. We need to redefine them to make the new `ssrnum` library compatible to a degree with the old one.\r\nhttps://github.com/math-comp/math-comp/blob/3ad8a9418dc5d39ef553033f5c8f581525a3aae3/mathcomp/algebra/ssrnum.v#L241-L263 In order to use order theories to reason about num structures, `<=%R` (`Num.Def.ler`) should have the same head symbol as `<=%O` without any reduction; thus, `Num.Def.(ler|ltr|...)` should be redefined as notations rather than definitions. Indeed `Notation ler := ...` things cannot be defined in a specific scope. `Notation \"@ 'ler' R\" := ...` things are declared for explicit application but their displays are fixed to `ring_display` (see https://github.com/math-comp/math-comp/pull/270#discussion_r259755442)."},{"author":"hivert","date":"2019-10-29T22:38:39Z","comment":"@CohenCyril asked me offline to comment here the naming convention. Currently `latticeType` are actually distributive lattice. It would be very uncommon in my community (combinatorics) to assume that all lattice are distributive.  So I'd rather have them called `distrLatticeType` or maybe `dlatticeType`. Note: since it's not something you'll write every line, my vote goes for the long name."},{"author":"pi8027","date":"2019-10-30T09:18:12Z","comment":"@hivert Could you confirm this renaming? Currently we don't have complemented non-distributive lattice structures in #388 and I'm not sure how interesting they are and that we should add them later.\r\n```\r\n(*           porderType == the type of partially ordered types                *)\r\n(*     distrLatticeType == the type of distributive lattices                  *)\r\n(*    bDistrLatticeType == distrLatticeType with a bottom element             *)\r\n(*   tbDistrLatticeType == distrLatticeType with both a top and a bottom      *)\r\n(*   cbDistrLatticeType == the type of sectionally complemented distributive  *)\r\n(*                         lattices                                           *)\r\n(*                         (lattices with bottom and a difference operation)  *)\r\n(*  ctbDistrLatticeType == the type of complemented distributive lattices     *)\r\n(*                         (lattices with top, bottom, difference, complement)*)\r\n(*            orderType == the type of totally ordered types                  *)\r\n(*        finPOrderType == the type of partially ordered finite types         *)\r\n(*  finDistrLatticeType == the type of nonempty finite distributive lattices  *)\r\n(* finCDistrLatticeType == the type of nonempty finite complemented           *)\r\n(*                         distributive lattices                              *)\r\n(*         finOrderType == the type of nonempty totally ordered finite types  *)\r\n```"},{"author":"hivert","date":"2019-10-30T10:41:15Z","comment":"That would be indeed my favorite naming convention. Note that I'm note sure that `sectionally complemented lattice` is a standard name. It looks that it the same as `relatively complemented distributive lattice` according to wikipedia. It moreover mention that \"A distributive lattice is complemented if and only if it is bounded and relatively complemented.\"..."},{"author":"pi8027","date":"2019-10-30T12:48:17Z","comment":"@hivert Sure. But currently, we don't have the relative complement operation \"the complement of `x` in the interval `[y, z]`\" in the library, which can easily be constructed from the sectional complement operation \"the complement of `x` in the interval `[0, y]`\"."},{"author":"pi8027","date":"2019-10-31T20:26:11Z","comment":"@CohenCyril I think you lost my last commit during the last rebasing: https://github.com/pi8027/math-comp/commit/1a2998ff78007bb508d216024864559d9882fc32. I rebased math-comp/fourcolor#19 so the CI failure on fourcolor will be disappeared."},{"author":"pi8027","date":"2019-11-04T13:05:40Z","comment":"I think we fixed all the problems discovered recently. I hope we can merge this after the next MathComp meeting!"},{"author":"amahboubi","date":"2019-11-14T09:53:00Z","comment":"This had been written long ago, but somehow I forgot to publish my review, sorry..."},{"author":"CohenCyril","date":"2019-11-27T13:25:16Z","comment":"@amahboubi are you happy with the rephrasings?"},{"author":"CohenCyril","date":"2019-12-11T13:28:37Z","comment":"@amahboubi I straightened the history. You can merge using \"Create a merge commit\" after the CI passes."}],"review_discussion":[{"author":"pi8027","file":"mathcomp/character/character.v","date":"2019-02-20T12:08:29Z","comment":"I needed to put a space here to distinguish from `@max` notation defined in order.v. It looks so bad, but I have no solution for this."},{"author":"ggonthier","file":"mathcomp/character/character.v","date":"2019-02-25T10:13:07Z","comment":"I object to this. The `@` symbol is reserved in the Coq syntax to mean explicit application, and the MathComp library should respect this and never create tokens of the form `@ident`. The only acceptable use of this kind of notation is to provide an explicit variant of an abbreviation, and it should be given as `\"@ 'ident'\"` at level 0 or `\"@ 'ident' X Y...\"` at level 10 so as to factor with the Coq grammar - see `ssrfun.v` for example. Caveat: I can't tell what the notation was meant for since it's not in the PR version of `order.v`."},{"author":"pi8027","file":"mathcomp/character/character.v","date":"2019-02-25T10:29:48Z","comment":"`@max` and `@min` are the explicit variants of overloaded max/min operators for totally ordered sets (`orderType`). Therefore as you pointed out they should be given as `\"@ 'max'\"` and `\"@ 'min'\"`. I didn't know this fact. Thank you so much."},{"author":"pi8027","file":"mathcomp/character/character.v","date":"2019-02-25T12:01:24Z","comment":"Fixed in #288"},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-02-25T17:33:14Z","comment":"To export the contents of the `ssrnum.Num` module in the `ssrnum.mc_1_7.Num` compatibility module without disabling interactive edit in PG and CoqIDE (see https://github.com/coq/coq/issues/8388), I have putted an alias of `ssrnum.Num` here. But this alias sometimes pollutes Coq responses. For example:\r\n```\r\nCoq < Check (0 <= 1)%R.\r\n0 <= 1\r\n     : bool\r\nwhere\r\n?t : [ |- mc_1_7.OrigNum.NumDomain.Exports.numDomainType]\r\n```\r\n\r\n```\r\nCoq < Print Canonical Projections.\r\n...\r\nint <- mc_1_7.OrigNum.NumDomain.sort ( int_numDomainType )\r\n...\r\n```\r\n\r\nRemoving this line and replacing all the `OrigNum` with `ssrnum.Num` solve this problem but disable interactive edit."},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-02-26T09:44:43Z","comment":"I found that some solutions have been provided for https://github.com/coq/coq/issues/8388, but we need to wait for the release of Coq 8.10 for making everything working well..."},{"author":"CohenCyril","file":"mathcomp/algebra/ssrnum.v","date":"2019-03-01T13:07:33Z","comment":"@ggonthier suggestion: package on the fly to use nice symbols."},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-03-04T15:23:34Z","comment":"Is that really possible? There are no structure sharing ring operations, order, and norm before this declaration."},{"author":"CohenCyril","file":"mathcomp/algebra/ssrnum.v","date":"2019-03-04T17:40:53Z","comment":"Yes, one could create a section with a variable `R : ringType` and axioms `pom : porderMixin R` and `norm_op : R -> R` do a `Let T := (R : Type)` and provide T with eq, zmod, ring, order and norm canonical structures."},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-03-13T16:41:46Z","comment":"I attempted this, but failed because of this issue: https://github.com/coq/coq/issues/9764. Types of `x` and `y` in the 5th axiom `{morph norm : x y / x * y}` cannot be inferred from implicit types declaration. (workaround: `{morph norm : x y / (x : T) * y}`)\r\n\r\nI also needed to put `Notation \"0\" := (0 : T)` because `@lt _ _ 0%R` cannot be typed before declaring a join structure of `porderType` and `zmodType`. As a conclusion, I prefer to keep this as it is and improve later."},{"author":"pi8027","file":"mathcomp/ssreflect/order.v","date":"2019-03-18T14:50:40Z","comment":"One may need to change this header because 1. order.v is not a draft anymore and 2. MathComp is distributed under CeCILL-B. @CohenCyril Could you please correct this as you wish?"},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-03-19T08:28:17Z","comment":"This `Export` command should be removed before merging."},{"author":"amahboubi","file":"mathcomp/ssreflect/order.v","date":"2019-11-04T13:24:37Z","comment":"I suggest cutting the block l.8-13 and postpone it after the list of structures introduced by the present library."},{"author":"amahboubi","file":"mathcomp/ssreflect/order.v","date":"2019-11-04T13:26:27Z","comment":"It is good practice in the doc to provide the complete list of arguments. You can still postpone the explanation of the display argument to the next paragraph."},{"author":"amahboubi","file":"mathcomp/ssreflect/order.v","date":"2019-11-04T13:27:44Z","comment":"\"over these structures\" is not clear. Something like \"For x, y : <appropriate type annotation>\" would be more informative."},{"author":"amahboubi","file":"mathcomp/ssreflect/order.v","date":"2019-11-04T13:28:32Z","comment":"Misleading or ambiguous semi-colon at the end of the line."},{"author":"amahboubi","file":"mathcomp/ssreflect/order.v","date":"2019-11-04T13:30:14Z","comment":"Explain which structure introduces these constants, and what they mean (in particular for comparable and incomparable)."},{"author":"amahboubi","file":"mathcomp/ssreflect/order.v","date":"2019-11-04T13:32:30Z","comment":"\"different structures defined on copies of one\" is not clear. On a same type?"},{"author":"amahboubi","file":"mathcomp/ssreflect/order.v","date":"2019-11-04T13:34:23Z","comment":"I suggest: \"If T holds a structure of partially ordered type (e.g. if T : porderType d, for some display d)\"."},{"author":"amahboubi","file":"mathcomp/ssreflect/order.v","date":"2019-11-04T13:36:06Z","comment":"I find \"copy of T\" ambiguous. The underlying type is not copied, only the structure isn't it?"},{"author":"CohenCyril","file":"mathcomp/ssreflect/order.v","date":"2019-11-27T02:41:17Z","comment":"addressed"},{"author":"CohenCyril","file":"mathcomp/ssreflect/order.v","date":"2019-11-27T02:41:36Z","comment":"fixed"},{"author":"CohenCyril","file":"mathcomp/ssreflect/order.v","date":"2019-11-27T02:42:08Z","comment":"I tried to address this."},{"author":"CohenCyril","file":"mathcomp/ssreflect/order.v","date":"2019-11-27T02:42:54Z","comment":"The suggestion was not the right explanation. I tried to rephrase."},{"author":"CohenCyril","file":"mathcomp/ssreflect/order.v","date":"2019-11-27T02:43:04Z","comment":"I tried to explain better."},{"author":"CohenCyril","file":"mathcomp/ssreflect/order.v","date":"2019-11-27T02:53:29Z","comment":"fixed"},{"author":"pi8027","file":"CHANGELOG_UNRELEASED.md","date":"2019-12-03T14:04:23Z","comment":"`1.9` and `mc_1_9.Num` should be `1.10` and `mc_1_10.Num`. I fix them now."},{"author":"amahboubi","file":"mathcomp/algebra/ssrnum.v","date":"2019-12-04T13:04:58Z","comment":"`hierarchy.ml` really?"},{"author":"CohenCyril","file":"mathcomp/algebra/ssrnum.v","date":"2019-12-04T16:04:31Z","comment":"Yes cf etc/utils/hierarchy.ml (do you wish there were more explainations here?)"},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-12-06T09:07:42Z","comment":"This is because of `hierarchy.ml` constructs the inheritance graph from the output of `Print Canonical Projections` and filters out all the join of A and B where A and B do not inherit each other. If A inherits B, we usually declare the join of A and B in the `Exports` module of A, so `hierarchy.ml` filters out all the join of A and B that is not declared in the `Exports` module of A or B. However, this does not apply to `numDomainType` and `normedZmodType` if we get rid of this workaround.\r\n\r\nAnother possible solution is recognizing constants as inheritances that are declared as both canonical projections and coercions, but this does not apply to `finGroupType`."}],"tags":[{"tag":"kind: enhancement","description":"Issue or PR about addition of features."},{"tag":"kind: refactoring","description":"Issue or PR about a refactoring. (reorganizing the code, reusing theorems, simplifications...)"}],"commits":[{"author":"CohenCyril","committer":"CohenCyril","hash":"80bf757ad263efd615d517b68e155aaa4e68aa89","message":"Initial import of order.v into mathcomp","date":"2019-12-11T13:18:15Z"},{"author":"pi8027","committer":"CohenCyril","hash":"fbf0b7568b8d6231671954cba8bcae4120e591cc","message":"Make an appropriate use of the order library everywhere (#278, #280, #282, #283, #285, #286, #288, #296, #330, #334, and #341)\n\nssrnum related changes:\n- Redefine the intermediate structure between `idomainType` and `numDomainType`,\n  which is `normedDomainType` (normed integral domain without an order).\n- Generalize (by using `normedDomainType` or the order structures), relocate\n  (to order.v), and rename ssrnum related definitions and lemmas.\n- Add a compatibility module `Num.mc_1_9` and export it to check compilation.\n- Remove the use of the deprecated definitions and lemmas from entire theories.\n- Implement factories mechanism to construct several ordered and num structures\n  from fewer axioms.\n\norder related changes:\n- Reorganize the hierarchy of finite lattice structures. Finite lattices have\n  top and bottom elements except for empty set. Therefore we removed finite\n  lattice structures without top and bottom.\n- Reorganize the theory modules in order.v:\n  + `LTheory` (lattice and partial order, without complement and totality)\n  + `CTheory` (`LTheory` + complement)\n  + `Theory` (all)\n- Give a unique head symbol for `Total.mixin_of`.\n- Replace reverse and `^r` with converse and `^c` respectively.\n- Fix packing and cloning functions and notations.\n- Provide more ordered type instances:\n  Products and lists can be ordered in two different ways: the lexicographical\n  ordering and the pointwise ordering. Now their canonical instances are not\n  exported to make the users choose them.\n- Export `Order.*.Exports` modules by default.\n- Specify the core hint database explicitly in order.v. (see #252)\n- Apply 80 chars per line restriction.\n\nGeneral changes:\n- Give consistency to shape of formulae and namings of `lt_def` and `lt_neqAle`\n  like lemmas:\n  lt_def    x y : (x < y) = (y != x) && (x <= y),\n  lt_neqAle x y : (x < y) = (x != y) && (x <= y).\n- Enable notation overloading by using scopes and displays:\n  + Define `min` and `max` notations (`minr` and `maxr` for `ring_display`) as\n    aliases of `meet` and `join` specialized for `total_display`.\n  + Provide the `ring_display` version of `le`, `lt`, `ge`, `gt`, `leif`, and\n    `comparable` notations and their explicit variants in `Num.Def`.\n  + Define 3 variants of `[arg min_(i < n | P) F]` and `[arg max_(i < n | P) F]`\n    notations in `nat_scope` (specialized for nat), `order_scope` (general\n    version), and `ring_scope` (specialized for `ring_display`).\n- Update documents and put CHANGELOG entries.","date":"2019-12-11T13:18:23Z"},{"author":"CohenCyril","committer":"CohenCyril","hash":"6d34f29cf906b6672925ee3abd4e54b59eea784f","message":"Changing license","date":"2019-12-11T13:25:52Z"},{"author":"pi8027","committer":"CohenCyril","hash":"ebd828b4939f105d7ea7d7bb950b5dcfd6887981","message":"Use `deprecate` notation in ssrnum","date":"2019-12-11T13:26:52Z"},{"author":"CohenCyril","committer":"CohenCyril","hash":"f0e9ca0a160fd11716cc759cab8c6cbcbf20a32d","message":"Fixes in naming, mixins, doc and canonical ordering\n\n- comparer -> compare (in order.v)\n- eq constructor of compare goes last\n- \"x < y\" is matched before \"x > y\"\n- \"x <= y\" is matched before \"x >= y\"\n- adding prod and lexi ordering on tuple\n- adding missing CS\n- edit CHANGELOG","date":"2019-12-11T13:26:52Z"},{"author":"pi8027","committer":"CohenCyril","hash":"581c08d1b045dbf51418df17350c84fda4eada93","message":"Reorder the arguments of the comparison predicates in order.v\n\nThe comparison predicates (for nat, ordered types, ordered integral domains)\nmust have the following order of arguments:\n- leP   x y : le_xor_gt x y ... (x <= y) (y < x) ... .\n- ltP   x y : lt_xor_ge x y ... (y <= x) (x < y) ... .\n- ltgtP x y : compare   x y ... (y == x) (x == y) (x >= y) (x <= y) (x > y) (x < y) ... .","date":"2019-12-11T13:26:52Z"},{"author":"pi8027","committer":"CohenCyril","hash":"b0a01acd904cbfcaf47d821b3b5e72098b9efb07","message":"Add (meet|join)_(l|r), some renamings, and small cleanups\n\nNew lemmas:\n- meet_l, meet_r, join_l, join_r.\n\nRenamings:\n- Order.BLatticeTheory.lexUl -> disjoint_lexUl,\n- Order.BLatticeTheory.lexUr -> disjoint_lexUr,\n- Order.TBLatticeTheory.lexIl -> cover_leIxl,\n- Order.TBLatticeTheory.lexIr -> cover_leIxr.\n\nUse `Order.TTheory` instead of `Order.Theory` if applicable","date":"2019-12-11T13:26:52Z"},{"author":"pi8027","committer":"CohenCyril","hash":"f8d7a9f1090785a61dd81d745a0f46a24515f3d8","message":"Rename `totalLatticeMixin` to `totalPOrderMixin` and several refactor\n\n- Rename `totalLatticeMixin` to `totalPOrderMixin`.\n- Refactor num mixins.\n- Use `Num.min` and `Num.max` rather than lattice notations if applicable.","date":"2019-12-11T13:26:52Z"},{"author":"pi8027","committer":"CohenCyril","hash":"e7df10a74264f52a17f54f87b8a89c9360a46926","message":"Redefine `normedDomainType` (now `normedZmodType`) (#392)\n\n* Redefine `normedDomainType` (now `normedZmodType`)\r\n\r\n- Redefine `normedDomainType` to drop ring and integral domain axioms.\r\n- Add canonical instance of `normedZmodType` for `prod`.","date":"2019-12-11T13:26:52Z"},{"author":"pi8027","committer":"CohenCyril","hash":"843e345d5d8217a02de9e7fe20406b83074e807d","message":"order.v: remove Order.Def, export Order.Syntax by default, and put missing scopes","date":"2019-12-11T13:26:52Z"},{"author":"affeldt-aist","committer":"CohenCyril","hash":"81a3634d0b72262fd8e6299bc94d9a7ab31ce3c0","message":"editing documentation in order.v and ssrnum.v","date":"2019-12-11T13:26:52Z"},{"author":"CohenCyril","committer":"CohenCyril","hash":"d913820cc104a43117604469dc47fca7114a98bd","message":"Adding nat lattice under the name natdvd","date":"2019-12-11T13:26:52Z"},{"author":"pi8027","committer":"CohenCyril","hash":"44e8df83ad4e4394a96c15c787405cdea8931074","message":"Rename: (l|L)attice -> (d|D)istrLattice","date":"2019-12-11T13:26:52Z"},{"author":"CohenCyril","committer":"CohenCyril","hash":"1a3b42a0cd96ff448f8dc686711d8b2b5d3b0a6c","message":"Comparability in a numDomainType\n\namounts to the difference being real, and consequences","date":"2019-12-11T13:26:52Z"},{"author":"CohenCyril","committer":"CohenCyril","hash":"696cd421b27ff2bee821c053c3c3d5926e9d68d3","message":"Doc, comments, changelog and better proofs\n\n- adding a doc paragraph on displays\n- Changelog\n- better proofs for new logn, gcdn, lcmn, partn facts\n- Putting comments in the example of nat","date":"2019-12-11T13:26:52Z"},{"author":"pi8027","committer":"CohenCyril","hash":"050ad8395fb250e9396b7a376a75c523567e177c","message":"Fix notation modifiers and scopes","date":"2019-12-11T13:26:52Z"},{"author":"affeldt-aist","committer":"CohenCyril","hash":"b3261c9020105f3c6667697b22ca8a542271bc4c","message":"renaming NormedZmoduleType and NormedZmoduleMixin (#416)\n\n* renaming\r\nNormedZmoduleType -> NormedZmodType\r\nNormedZmoduleMixin -> NormedZmodMixin\r\nthat looks more homogeneous with regard to naming conventions used so far\r\n\r\n* update .gitlab-ci.yml\r\n\r\n* typo","date":"2019-12-11T13:26:52Z"},{"author":"affeldt-aist","committer":"CohenCyril","hash":"ab2b7de07c7236531bc08a0b9f53046593e47051","message":"remove ProdNormedZmodule (#419)\n\n* remove ProdNormedZmodule from ssrnum.v, it made its way to mathcomp-analysis in a generalized form (branch analysis_270) at the time of this writing\r\n\r\n* update gitlab-ci","date":"2019-12-11T13:26:52Z"},{"author":"CohenCyril","committer":"CohenCyril","hash":"0d7ffe8610da33bdce2cf7f612eef7e5a777cd8e","message":"Rephrasing the doc","date":"2019-12-11T13:26:52Z"},{"author":"pi8027","committer":"CohenCyril","hash":"3f6aa286677f6cb0659300afd2b612b7bce20e73","message":"The compatibility module in ssrnum should now be for version 1.10","date":"2019-12-11T13:26:52Z"}]}