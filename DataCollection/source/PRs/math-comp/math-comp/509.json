{"author":"chdoc","number":509,"diff_summary":[{"file":"CHANGELOG_UNRELEASED.md","status":"M","additions":100,"deletions":6},{"file":"mathcomp/ssreflect/fingraph.v","status":"M","additions":100,"deletions":6},{"file":"mathcomp/ssreflect/finset.v","status":"M","additions":100,"deletions":6},{"file":"mathcomp/ssreflect/fintype.v","status":"M","additions":100,"deletions":6},{"file":"mathcomp/ssreflect/seq.v","status":"M","additions":100,"deletions":6}],"state":"merged","open_date":"2020-05-14T18:11:59Z","update_date":"2020-06-19T02:59:41Z","discussion":[{"author":"chdoc","date":"2020-05-26T10:14:05Z","comment":"I tried to incorporate the feedback from @CohenCyril , and I found two more lemmas `fcard_gt0P` and `fcard_gt1P`. The proof of the latter naturally makes use of `card_gt1P`. These are adapted/simplified from the `fourcolor` development, where one can find a specific instance for each of them (`fcard0P` and `fcard1P`)."},{"author":"chdoc","date":"2020-06-17T12:21:23Z","comment":"I wasn't sure about this, because the line already had 82 characters, now it gained another 6. And yes, I want a linter, too. :smile: "},{"author":"CohenCyril","date":"2020-06-17T12:25:43Z","comment":"> I wasn't sure about this, because the line already had 82 characters, now it gained another 6. And yes, I want a linter, too.\r\n\r\nOh ok, I should really checkout locally.\r\nIn the core mathcomp repo there is a strict rule about the 80 characters per line limit. So this line should be split anyway."},{"author":"chdoc","date":"2020-06-17T12:31:18Z","comment":"Well, running a `grep -n '.\\{81\\}' ssreflect/*.v` made me believe that the rule is not _that_ strict."},{"author":"CohenCyril","date":"2020-06-17T12:33:42Z","comment":"> Well, running a `grep -n '.\\{81\\}' ssreflect/*.v` made me believe that the rule is not _that_ strict.\r\n\r\nIt used to be, this is outrageous :wink:\r\nI will revive #163 ASAP."}],"review_discussion":[{"author":"CohenCyril","file":"mathcomp/ssreflect/fintype.v","date":"2020-05-14T20:22:03Z","comment":"In thought I did that one when I added `fintype_le1P` tomorrow. :laughing: I will double check tomorrow, if I forgot to push something."},{"author":"CohenCyril","file":"mathcomp/ssreflect/finset.v","date":"2020-05-14T20:28:17Z","comment":"Nice one to have indeed, I think there is a lot of refactoring to do with all the `card_*` lemma you added, through `enum` (which is `uniq` which size is the cardinal of the considered set). Indeed, I think `card_eqP` would be almost a one liner and `card_geqP`, and `cards2P` is a simple twice case analysis (the main step being something like `case: (enum A) (enum_uniq A) (size_enum A) => [|x [|y []]//; exists x; exists y`).\r\nI also think it would be nice to have le/lt variants and `pred` variants."},{"author":"chdoc","file":"mathcomp/ssreflect/finset.v","date":"2020-05-15T08:33:29Z","comment":"I'm not sure I follow. There is no `card_eqP` (yet) and indeed I'm not sure that would be useful, since `enum A` has already good lemma support. And `card_geqP` is about encapsulating the picking of a subsequence of `enum A`, if one only has a lower bound. \r\nAdmittedly, using the `_gt?P` lemmas to prove `cards2P` may be overkill. "},{"author":"CohenCyril","file":"mathcomp/ssreflect/finset.v","date":"2020-05-15T13:10:35Z","comment":"Here is an elaboration of what I had in mind:\r\n```coq\r\nLemma set_enum A : [set x | x \\in enum A] = A.\r\nProof. by apply/setP => x; rewrite inE mem_enum. Qed.\r\n\r\nVariant cards_eq_spec A : seq T -> {set T} -> nat -> Type :=\r\n| CardEq (s : seq T) & uniq s : cards_eq_spec A s [set x | x \\in s] (size s).\r\n\r\nLemma cards_eqP A : cards_eq_spec A (enum A) A #|A|.\r\nProof.\r\nby move: (enum A) (cardE A) (set_enum A) (enum_uniq A) => s -> <-; constructor.\r\nQed.\r\n\r\nLemma cards1P A : reflect (exists x, A = [set x]) (#|A| == 1).\r\nProof.\r\napply: (iffP idP) => [|[x ->]]; last by rewrite cards1.\r\nby have [[|x []]// _] := cards_eqP; exists x; apply/setP => y; rewrite !inE.\r\nQed.\r\n\r\nLemma cards2P A : reflect (exists x y : T, x != y /\\ A = [set x; y]) (#|A| == 2).\r\nProof.\r\napply: (iffP idP) => [|[x] [y] [xy ->]]; last by rewrite cards2 xy.\r\nhave [[|x [|y []]]//=] := cards_eqP; rewrite !inE andbT => neq_xy.\r\nby exists x, y; split=> //; apply/setP => z; rewrite !inE.\r\nQed.\r\n```\r\nand something like this for fintype..."},{"author":"CohenCyril","file":"mathcomp/ssreflect/finset.v","date":"2020-05-15T13:16:16Z","comment":"> And `card_geqP` is about encapsulating the picking of a subsequence of `enum A`, if one only has a lower bound.\r\n\r\nIndeed, I missed that..."},{"author":"chdoc","file":"mathcomp/ssreflect/finset.v","date":"2020-05-19T16:14:28Z","comment":"Okay, for `{set _}` what you propose is indeed more general and more direct than what I had proposed. However, I'm not sure it transfers all that well to predicates: due to the lack of extensionality, one cannot pull the `[set x | x \\in enum A]` trick. One could instead generate `s =i A` as an assumption, but I'm not sure this view would be all that useful. \r\n\r\nThe same goes for lower bounds, albeit for a different reason: there one doesn't even want to replace the original predicate/set. "},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2020-06-07T02:09:05Z","comment":"if you are going to add `take_uniq`, also add `drop_uniq`"},{"author":"CohenCyril","file":"mathcomp/ssreflect/fintype.v","date":"2020-06-07T02:09:19Z","comment":"```suggestion\r\n  by exists x, y, z; rewrite xDy yDz eq_sym xDz !subA ?inE ?eqxx ?orbT.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/fintype.v","date":"2020-06-07T02:09:37Z","comment":"```suggestion\r\nexists [:: x; y; z]; rewrite /= !inE negb_or xDy xDz eq_sym yDz; split=> // u.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/fintype.v","date":"2020-06-07T02:10:04Z","comment":"```suggestion\r\n  by exists a, b; rewrite aDb !subD ?inE ?eqxx ?orbT.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/fintype.v","date":"2020-06-07T02:10:16Z","comment":"```suggestion\r\nby exists [:: x; y]; rewrite /= !inE xDy ; split=> // z; rewrite !inE => /pred2P[]->.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/fintype.v","date":"2020-06-07T02:10:57Z","comment":"```suggestion\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/fintype.v","date":"2020-06-07T02:12:27Z","comment":"```suggestion\r\nProof. apply: (iffP (card_le1_eqP {:T})); [exact: in2T | exact: in2W]. Qed.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/fintype.v","date":"2020-06-07T02:12:46Z","comment":"```suggestion\r\n  reflect {in A &, forall x, all_equal_to x} (#|A| <= 1).\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/fingraph.v","date":"2020-06-07T02:14:20Z","comment":"```suggestion\r\n  move=> [x] [y] [/andP [/= rfx xA]] [/andP[/= rfy yA] xDy].\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/fingraph.v","date":"2020-06-07T02:15:05Z","comment":"```suggestion\r\n  by exists x; do 1?exists y; rewrite // -root_connect // (eqP rfx) (eqP rfy).\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/fintype.v","date":"2020-06-07T02:15:46Z","comment":"```suggestion\r\n  case: s => [|x [|y [|z []]]]//=; rewrite !inE !andbT negb_or -andbA.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/fintype.v","date":"2020-06-07T02:16:33Z","comment":"```suggestion\r\nby rewrite !inE => /or3P [] /eqP->.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/fintype.v","date":"2020-06-07T02:17:45Z","comment":"```suggestion\r\n  case: s => [|a [|b []]]//=; rewrite inE andbT => aDb _ subD.\r\n```"},{"author":"chdoc","file":"mathcomp/ssreflect/seq.v","date":"2020-06-07T09:08:25Z","comment":"Will do."},{"author":"CohenCyril","file":"mathcomp/ssreflect/fingraph.v","date":"2020-06-08T12:08:30Z","comment":"this is not resolved..."},{"author":"CohenCyril","file":"mathcomp/ssreflect/fingraph.v","date":"2020-06-08T12:09:04Z","comment":"```suggestion\r\nmove=> clfA; apply: (iffP card_gt0P) => [[x /andP[]]|[x xA]]; first by exists x.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/fintype.v","date":"2020-06-08T12:10:19Z","comment":"This change I suggested apparently causes an overflow of the 80 character liimit, I suggest splitting the line as follows:\r\n```suggestion\r\nexists [:: x; y]; rewrite /= !inE xDy.\r\nby split=> // z; rewrite !inE => /pred2P[]->.\r\n```"},{"author":"CohenCyril","file":"mathcomp/ssreflect/fintype.v","date":"2020-06-17T12:08:42Z","comment":"One last nitpicking that I did not see (we should really have a linter):\r\n```suggestion\r\n  reflect (exists x y z, [/\\ x \\in A, y \\in A & z \\in A] /\\ [/\\ x != y, y != z & z != x])\r\n```"}],"tags":[{"tag":"kind: enhancement","description":"Issue or PR about addition of features."},{"tag":"kind: refactoring","description":"Issue or PR about a refactoring. (reorganizing the code, reusing theorems, simplifications...)"}],"commits":[{"author":"chdoc","committer":"chdoc","hash":"18edd0a87f8cc8bfd3a7c7aaaafa3d2cfdf5d165","message":"cardinality lemmas for #|A| <= 1 and n <= #|A|","date":"2020-06-18T14:45:03Z"},{"author":"chdoc","committer":"chdoc","hash":"1ac0240534077301fa837233b2a8e4bbeef119a8","message":"cards_eqP and cards2P","date":"2020-06-18T14:45:03Z"},{"author":"chdoc","committer":"chdoc","hash":"5b4b9ad71794cc68f9c94520e91fd8ab56a5b577","message":"add fcard_gt?P lemmas found in fourcolor","date":"2020-06-18T14:45:03Z"},{"author":"chdoc","committer":"chdoc","hash":"96efc4fa2a3b643c6c4ea19047c3e633c5af145f","message":"drop_uniq / CHANGELOG","date":"2020-06-18T14:46:23Z"},{"author":"chdoc","committer":"chdoc","hash":"555655f227c4d154f72b352b3437a1c275be2920","message":"Apply suggestions from code review\n\nCo-authored-by: Cyril Cohen <CohenCyril@users.noreply.github.com>","date":"2020-06-18T14:46:23Z"},{"author":"CohenCyril","committer":"chdoc","hash":"c5008933e4f17c122a0b23e6e6cfe8d198423214","message":"fixup spacing","date":"2020-06-18T14:46:23Z"},{"author":"chdoc","committer":"chdoc","hash":"7fd6f9ba051ecc7be7bd95ca3e31bb1a798598ba","message":"conform to 80 chars limit","date":"2020-06-18T14:46:23Z"}]}