{"author":"affeldt-aist","number":417,"diff_summary":[{"file":".gitlab-ci.yml","status":"M","additions":166,"deletions":21},{"file":"mathcomp/algebra/ssrnum.v","status":"M","additions":166,"deletions":21}],"state":"closed","open_date":"2019-11-13T11:17:44Z","update_date":"2019-11-25T14:34:19Z","discussion":[{"author":"affeldt-aist","date":"2019-11-13T11:26:28Z","comment":"A first version appeared in PR #416 from which it has been removed. "},{"author":"affeldt-aist","date":"2019-11-14T01:21:46Z","comment":"@pi8027 Thanks. I hope to be able to address all comments by tomorrow."},{"author":"pi8027","date":"2019-11-14T02:45:00Z","comment":"The type of non-negative numbers may allow us to use the bigop theory to reason about bigmaxr in mathcomp-analysis. This requires some more work."},{"author":"affeldt-aist","date":"2019-11-14T08:03:01Z","comment":"> The type of non-negative numbers may allow us to use the bigop theory to reason about bigmaxr in mathcomp-analysis. \r\n\r\nIt is already used in mathcomp-analysis to define a norm on matrices (see https://github.com/math-comp/analysis/tree/analysis_270, WIP).\r\n"},{"author":"pi8027","date":"2019-11-14T08:04:46Z","comment":"@affeldt-aist Great! I hope that will be integrated into mathcomp."},{"author":"affeldt-aist","date":"2019-11-14T11:40:01Z","comment":"I organize a migration of this PR to mathcomp-analysis, so that in the end it will simply turn into a removal of ProdNormedZmodule."},{"author":"CohenCyril","date":"2019-11-25T14:28:18Z","comment":"@affeldt-aist can this PR be closed?"},{"author":"affeldt-aist","date":"2019-11-25T14:34:19Z","comment":"PR closed. Contents moves to PR #270."}],"review_discussion":[{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-13T22:59:28Z","comment":"Since this is a canonical instance declaration, the argument `x` of `NngNum` should probably not be implicit. Additionally, `add_nng_ge0` may not be needed: `Canonical addr_nngnum x y := @NngNum _ (x%:nngnum + y%:nngnum) (addr_ge0 x y).`"},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-13T23:20:04Z","comment":"```coq\r\ncase: (leP x y)=> ?.\r\nrewrite andb_idl //; exact/le_trans.\r\nrewrite andb_idr //; exact/le_trans/ltW.\r\n```"},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-13T23:28:46Z","comment":"```coq\r\ncase: leP=> ?.\r\nrewrite andb_idl //; exact/le_lt_trans.\r\nrewrite andb_idr //; exact/lt_trans.\r\n```"},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-13T23:32:18Z","comment":"This can be generalized for any `normedZmodType R`:\r\n`Canonical normr_nngnum (V : normedZmodType R) (x : V) := NngNum (normr_ge0 x).`"},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-13T23:33:33Z","comment":"```coq\r\ncase: (leP x y)=> ?.\r\nrewrite orb_idl // => /le_trans; exact.\r\nrewrite orb_idr // => /le_trans; apply; exact/ltW.\r\n```"},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-13T23:47:09Z","comment":"These two notations seem to be redundant (probably because of my bad suggestion...). I think `[ge0 of x]` should have `ring_scope` or `form_scope`."},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-13T23:47:34Z","comment":"Missing scope (`type_scope`?)."},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-14T00:20:42Z","comment":"`K` is not needed to be a field. The hypothesis `a != 0` can be dropped.\r\n\r\n```coq\r\nLemma nonneg_maxr (R : numDomainType) (V : normedZmodType R)\r\n                  (x : V) (y z : {nonneg R}) :\r\n  `|x| * (maxr y z)%:nngnum =\r\n  (maxr (`|x| * y%:nngnum)%:nng (`|x| * z%:nngnum)%:nng)%:nngnum.\r\nProof.\r\nmove: y z; apply: wlog_le => y z hyz; first by rewrite joinC hyz joinC.\r\nrewrite !join_r //; apply/ler_wpmul2l => //; exact/normr_ge0.\r\nQed.\r\n```\r\nor\r\n```coq\r\nLemma nonneg_maxr (R : numDomainType) (x y z : {nonneg R}) :\r\n  x%:nngnum * (maxr y z)%:nngnum =\r\n  (maxr (x%:nngnum * y%:nngnum)%:nng (x%:nngnum * z%:nngnum)%:nng)%:nngnum.\r\nProof.\r\nmove: y z; apply: wlog_le => y z hyz; first by rewrite joinC hyz joinC.\r\nrewrite !join_r //; apply/ler_wpmul2l => //; exact/nngnum_ge0.\r\nQed.\r\n```"},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-14T01:28:44Z","comment":"Could you declare an `Arguments` command specifying that the second argument of `NngNum` is a non-implicit argument so that we don't need to use an explicit application here?"},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-14T01:29:31Z","comment":"`Canonical mulrn_nngnum x n := @NngNum _ (x%:nngnum *+ n) (mulrn_wge0 n x).`"},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-14T01:31:58Z","comment":"Now you may put this lemma to the `NngNum` section. Additionally, there is a simpler proof:\r\n```\r\nmove: y z; apply: wlog_le => y z hyz; first by rewrite joinC hyz joinC.\r\nrewrite !join_r //; exact/ler_wpmul2l.\r\n```"},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-14T02:01:45Z","comment":"The theory part (the `NngNum` section) has not been exported yet. The `NngNum` section should probably be moved after closing the `Nonneg` module."},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-14T02:01:59Z","comment":"`Export Nonneg.Exports`."},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-14T02:03:41Z","comment":"```coq\r\nCanonical zeror_nngnum := @NngNum R 0 (lexx 0).\r\nCanonical oner_nngnum := @NngNum R 1 ler01.\r\n```"},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-14T02:20:06Z","comment":"- `Import Nonneg Nonneg.Exports` is not necessary anymore.\r\n- I don't get why there are `norm` and `norm'`.\r\n- There are simpler proofs as follows:\r\n```coq\r\nSection ProdNormedZmodule.\r\nContext {R : numDomainType} {U V : normedZmodType R}.\r\n\r\nDefinition norm (x : U * V) : R :=\r\n  (Num.max (`| x.1 |%:nng) (`| x.2 |%:nng))%:nngnum.\r\n\r\nLemma normD x y : norm (x + y) <= norm x + norm y.\r\nProof.\r\nrewrite /norm nng_leUx /=; apply/andP; split;\r\n  case: leP => [|/ltW] Hx; case: leP => [|/ltW] Hy;\r\n  exact/(le_trans (ler_norm_add _ _))/ler_add.\r\nQed.\r\n\r\nLemma norm_eq0 x : norm x = 0 -> x = 0.\r\nProof.\r\ncase: x=> x1 x2 /eqP; rewrite eq_le nng_leUx 2!normr_le0 -andbA /=.\r\nby case/and3P => /eqP -> /eqP ->.\r\nQed.\r\n\r\nLemma normMn x n : norm (x *+ n) = norm x *+ n.\r\nProof.\r\nby rewrite /norm pairMnE /=; case: leP => [|/ltW];\r\n  rewrite nng_le /= !normrMn ler_muln2r => /predU1P [->|];\r\n  rewrite ?mulr0n // -nng_le; [case: leP | case: ltP].\r\nQed.\r\n\r\nLemma normrN x : norm (- x) = norm x.\r\nProof.\r\nby rewrite /norm /=; case: leP => [|/ltW];\r\n  rewrite nng_le /= !normrN -nng_le; [case: leP | case: ltP].\r\nQed.\r\n\r\nDefinition normedZmodMixin :\r\n  @Num.normed_mixin_of R [zmodType of U * V] (Num.NumDomain.class R) :=\r\n  @Num.NormedMixin _ _ _ norm normD norm_eq0 normMn normrN.\r\n\r\nCanonical normedZmodType := NormedZmoduleType R (U * V) normedZmodMixin.\r\n\r\nLemma prod_normE (x : normedZmodType) :\r\n  `|x| = (Num.max `|x.1|%:nng `|x.2|%:nng)%:nngnum.\r\nProof. by []. Qed.\r\n\r\nEnd ProdNormedZmodule.\r\n```"},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-14T08:13:29Z","comment":"The above simplification may require to generalize `absr_nngnum`. See https://github.com/math-comp/math-comp/pull/417#discussion_r346058855."},{"author":"affeldt-aist","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-14T08:20:12Z","comment":"Yes, it does work, but the generalization of absr_nngnum breaks inference in mathcomp-analysis. I am investigating it, that's why I have not yet marked it as resolved."},{"author":"pi8027","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-14T08:26:44Z","comment":"With the absolute value function of type `froall (R : numDomainType), R -> R`, pretyping understands that the type of `0` in `|0| : R` is `R`. However, since the norm function has type `forall (R : numDomainType) (V : normedZmodType), V -> R`, `|0| : R` cannot be typed anymore. You probably should put a type annotation like `|0 : R|` in this case."},{"author":"affeldt-aist","file":"mathcomp/algebra/ssrnum.v","date":"2019-11-14T08:55:15Z","comment":"I solved my problem with a type annotation (^o actually)."}],"tags":[],"commits":[{"author":"affeldt-aist","committer":"affeldt-aist","hash":"fb87a49b4a538fefca33fad2b699dfebe72c00f8","message":"add non-negative numbers to generalize the type of ProdNormedZmodule","date":"2019-11-13T11:11:10Z"},{"author":"affeldt-aist","committer":"affeldt-aist","hash":"aa0311d120174e2b5380c1464dca79ca135f5497","message":"update .gitlab-ci.yml","date":"2019-11-13T11:27:39Z"},{"author":"affeldt-aist","committer":"affeldt-aist","hash":"2c3c494b7b662ef10f8151ee896f5bc22a4e9b15","message":"apply comments by @pi8027","date":"2019-11-14T08:50:06Z"}]}