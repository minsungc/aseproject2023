{"author":"CohenCyril","number":661,"diff_summary":[{"file":"CHANGELOG_UNRELEASED.md","status":"M","additions":26,"deletions":0},{"file":"mathcomp/field/closed_field.v","status":"M","additions":26,"deletions":0},{"file":"mathcomp/ssreflect/binomial.v","status":"M","additions":26,"deletions":0},{"file":"mathcomp/ssreflect/choice.v","status":"M","additions":26,"deletions":0},{"file":"mathcomp/ssreflect/prime.v","status":"M","additions":26,"deletions":0},{"file":"mathcomp/ssreflect/seq.v","status":"M","additions":26,"deletions":0},{"file":"mathcomp/ssreflect/ssrnat.v","status":"M","additions":26,"deletions":0}],"state":"merged","open_date":"2020-11-20T01:34:57Z","update_date":"2020-11-22T10:31:23Z","discussion":[{"author":"gares","date":"2020-11-20T13:38:18Z","comment":"Can you tell me why ! was not ok?"},{"author":"CohenCyril","date":"2020-11-20T13:52:05Z","comment":"@gares\r\n> Can you tell me why ! was not ok?\r\n\r\nAlmost all definitions (except for `eqseq`) which are involved in this tuning have at least one \"default\" case, where one argument does not need to be a constructor for a ground value to be output. e.g. in `take` if the list is `[::]`, then whatever the natural number, the output is `[::]`. The \"right\" criterion is that no match should be exposed by doing so.\r\n\r\nExcept for `mask` where there is an extra match on a boolean that we would like to expose. So I sacrificed expansion when the mask is `[::]` and not the list `s`, for the sake of still having a form of controlled expansion, which would still expose the match on the boolean.\r\n\r\nThis hints at the fact that both `!` and `nomatch` are too restrictive in different fashion. Somehow, we would like to say which `match` are allowed/forbidden instead. e.g. (wishful thinking) `Arguments mask _ !m !s : simpl nomatch`, *should* simplify iff it does not (directly) expose a match on `m` or `s`.\r\n\r\nMoreover, in the current state, `nomatch` will prevent expansion even if the appearance of the match has nothing to do with the unfolding of the constant itself. e.g.\r\n```coq\r\nDefinition mask_if mask b (x : T) m' s' :=  if b then x :: mask m' s' else mask m' s'\r\nFixpoint mask m s {struct m} :=\r\n  match m, s with\r\n  | b :: m', x :: s' => mask_if mask b x m' s'\r\n  | _, _ => [::]\r\n  end.\r\nArguments mask : simpl nomatch.\r\nArguments mask_if /.\r\n```\r\nwill still not simplify `mask (b :: m) (x :: s)` because doing one loop of the fixpoint and then expanding `mask_if` will result in a match :cry: :cry: :cry:"},{"author":"CohenCyril","date":"2020-11-20T19:51:43Z","comment":"@affeldt-aist the CI passed, I rebased once more, when it passes again, you can merge, unless @gares is opposed to this?"},{"author":"gares","date":"2020-11-22T08:13:15Z","comment":"I'm OK and aware that \"if\" is problematic with no match."}],"review_discussion":[],"tags":[{"tag":"kind: enhancement","description":"Issue or PR about addition of features."},{"tag":"kind: fix","description":"PR that fixes a bug. Please refer to the appropriate issue(s) if relevant."}],"commits":[{"author":"CohenCyril","committer":"CohenCyril","hash":"c55acd1fefa970cc4ed3a8a53b05fd77008a7cdf","message":"Tuning simplifications using Arguments simpl nomatch","date":"2020-11-20T19:50:44Z"}]}