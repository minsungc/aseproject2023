{"author":"ggonthier","number":262,"diff_summary":[{"file":"ChangeLog","status":"M","additions":296,"deletions":178},{"file":"mathcomp/algebra/intdiv.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/algebra/matrix.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/algebra/mxpoly.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/algebra/poly.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/algebra/ssralg.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/algebra/ssrint.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/algebra/ssrnum.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/algebra/vector.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/algebra/zmodp.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/character/character.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/character/classfun.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/character/mxabelem.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/character/mxrepresentation.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/character/vcharacter.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/field/algC.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/field/algnum.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/field/closed_field.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/field/fieldext.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/field/galois.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/fingroup/action.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/fingroup/fingroup.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/fingroup/morphism.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/fingroup/perm.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/fingroup/quotient.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/solvable/alt.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/solvable/finmodule.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/ssreflect/choice.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/ssreflect/eqtype.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/ssreflect/finfun.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/ssreflect/finset.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/ssreflect/fintype.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/ssreflect/generic_quotient.v","status":"M","additions":296,"deletions":178},{"file":"mathcomp/ssreflect/tuple.v","status":"M","additions":296,"deletions":178}],"state":"merged","open_date":"2018-12-11T14:25:01Z","update_date":"2018-12-13T14:05:07Z","discussion":[{"author":"CohenCyril","date":"2018-12-11T16:29:49Z","comment":"Hi @ggonthier thanks, that's a change I had in mind for a while.\r\nI am a bit surprised not to see any line with `canLR` (or similar) in this PR, do you reserve it for the next one?\r\nAlso, can you squash and rebase on top of master, please?\r\n\r\n(Indeed, it is preferred to rebase on top of master rather than to merge master into a branch, for the sake of cleaning the history and not confusing github)"},{"author":"anton-trunov","date":"2018-12-12T10:17:28Z","comment":"Would it make sense to add an entry to ChangeLog in this PR to fix #258? Or should I open a new one?\r\nI guess the proposed entry \r\n```\r\n\t* Documented argument names for functions and lemmas. Renamed some\r\n\t  of the arguments for consistency reasons. Changed implicit status from\r\n\t  non-maximal to maximal for a number of arguments.\r\n```\r\nshould be changed anyways."},{"author":"ggonthier","date":"2018-12-12T10:31:52Z","comment":"@anton-trunov , yes, one entry should suffice to cover both PRs, and it should be a little more precise than the on proposed. I'm working on extending slightly the PR to cover uses of the lemmas  as suggested by @CohenCyril, and also to include partial function cancellation lemmas."},{"author":"ggonthier","date":"2018-12-13T12:21:24Z","comment":"Added usage, partial function cancel (`pcancel` / `ocancel`), and some residual `injective` / `cancel` lemmas.\r\nRebased, documented (in Changes, also covering #255), and squashed."},{"author":"gares","date":"2018-12-13T18:09:55Z","comment":"odd order is now part of Coq's CI and runs on each PR, so breaking it is not nice.\r\n\r\nWhat I do for elpi is to have Coq CI track a branch other than master that I synchronize with master when I'm sure (it is called coq-master).\r\n\r\nWe could also improve CI here, so that we test odd-order too before merging."},{"author":"ggonthier","date":"2018-12-14T16:59:38Z","comment":"I've corrected the issue in odd-order,  and also submitted #264 to correct related issues in `mxrepresentation.v`."}],"review_discussion":[],"tags":[{"tag":"kind: refactoring","description":"Issue or PR about a refactoring. (reorganizing the code, reusing theorems, simplifications...)"}],"commits":[{"author":"ggonthier","committer":"ggonthier","hash":"0b1ea03dafcf36880657ba910eec28ab78ccd018","message":"Adjust implicits of cancellation lemmas\n\nLike injectivity lemmas, instances of cancellation lemmas (whose\nconclusion is `cancel ? ?`, `{in ?, cancel ? ?}`, `pcancel`, or\n`ocancel`) are passed to\ngeneric lemmas such as `canRL` or `canLR_in`. Thus such lemmas should\nnot have trailing on-demand implicits _just before_ the `cancel`\nconclusion, as these would be inconvenient to insert (requiring\nessentially an explicit eta-expansion).\nWe therefore use `Arguments` or `Prenex Implicits` directives to make\nall such arguments maximally inserted implicits. We donâ€™t, however make\nother arguments implicit, so as not to spoil direct instantiation of\nthe lemmas (in, e.g., `rewrite -[y](invmK injf)`).\nWe have also tried to do this with lemmas whose statement matches a\n`cancel`, i.e., ending in `forall x, g (E[x]) = x` (where pattern\nunification will pick up `f = fun x => E[x]`).\nWe also adjusted implicits of a few stray injectivity\nlemmas, and defined constants.\nWe provide a shorthand for reindexing a bigop with a permutation.\nFinally we used the new implicit signatures to simplify proofs that\nuse injectivity or cancellation lemmas.","date":"2018-12-13T11:55:43Z"}]}