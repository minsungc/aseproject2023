{"author":"hivert","number":41,"diff_summary":[{"file":"mathcomp/ssreflect/seq.v","status":"M","additions":215,"deletions":11}],"state":"closed","open_date":"2016-05-05T22:37:18Z","update_date":"2017-12-11T22:43:23Z","discussion":[{"author":"hivert","date":"2016-05-05T23:50:05Z","comment":"Thanks for rereading my proofs. It's certainly a good way for me to improve my Coq/SSReflect skills. I Implemented your suggestions and pushed.\n"},{"author":"hivert","date":"2016-05-06T07:35:09Z","comment":"Updated pull request according to your comment.\n"},{"author":"hivert","date":"2016-05-10T15:24:47Z","comment":"Dear Georges,\n\nThanks for the careful rereading of my pull request ! I'll soon propose a new patch taking care of all your remarks.\n\nFlorent\n"},{"author":"hivert","date":"2016-11-17T00:32:06Z","comment":"First of all, I'm sorry that I took me so long to answer your suggestions. I should have addressed all of them including the remark on the reshape/flatten index theory  up there (the one with 5 comments). It a pity there is no numbering on the comment in Github, becaus there is no way to point so some comment. \n"},{"author":"hivert","date":"2017-12-04T00:03:10Z","comment":"Why github is still complaining about the conflict which is resolved in my branch ?"},{"author":"hivert","date":"2017-12-04T20:09:04Z","comment":"On Mon, Dec 04, 2017 at 04:36:17AM -0800, Cyril Cohen wrote:\n> The best practice would have been to open a new branch on your side to prepare the pull request, and then change the content of this branch each time you update your pull request, or each time you rebase your branch on top of master.\n> \n> Since you did not do it, you will have to force your branch master : I think you should remove your merge commit, then add a new commit on your master branch and rebase it on top of our master. Then github will update your pull request accordingly and state it has no conflicts. Does what I say make sense?\n\nIt's very strange, since I did only use github web interface. I haven't been\ndoing any Coq for a few months so that I need to update it together with\nMathcomp. Since It takes some times I tried to do everything online. I what\nyou said is true, I don't understand why they gives all these cliquodrome\nstuff online. Anyway, Sorry for the mess.\n\nA++\n\nFlorent\n"},{"author":"CohenCyril","date":"2017-12-11T10:20:37Z","comment":"Hi Florent, I agree it's a bit annoying that github allows you to click in ways that makes it enter an inconsistent state... Do you want me do handle this for you? If you are ok with it, I may rework your existing pull request to make it consistent with github and then merge."},{"author":"amahboubi","date":"2017-12-11T10:32:18Z","comment":"Indeed, it's a pain. BTW I think it would be good, to add something about the expected shape of history in ready-to-merge PRs in the [checklist](https://github.com/math-comp/math-comp/wiki/checklist-pr). Any wording suggestion @maximedenes ?\r\n"},{"author":"amahboubi","date":"2017-12-11T10:35:19Z","comment":"@CohenCyril, you self-assigned the review: what's the status of your review here as of today? Is it only a matter of cleaning the commits or is there anything more semantic to be done?"},{"author":"CohenCyril","date":"2017-12-11T10:40:29Z","comment":"@amahboubi, I guess now it should be ok with regard to the extensive review @ggonthier did a while ago. However, now, with the inconsitent state in github, it is very difficult to make a last review before merging, because github won't show me the correct diff!"},{"author":"hivert","date":"2017-12-11T10:41:54Z","comment":"      Dear Cyril,\n\nOn Mon, Dec 11, 2017 at 10:20:38AM +0000, Cyril Cohen wrote:\n> Hi Florent, I agree it's a bit annoying that github allows you to click in\n> ways that makes it enter an inconsistent state... Do you want me do handle\n> this for you? If you are ok with it, I may rework your existing pull request\n> to make it consistent with github and then merge.\n\nPlease do ! My fork is public <https://github.com/hivert/math-comp> so don't\nhesitate to refork it and finish the merge. Thanks !\n\nFlorent\n\n"},{"author":"hivert","date":"2017-12-11T10:49:59Z","comment":"On Mon, Dec 11, 2017 at 02:40:30AM -0800, Cyril Cohen wrote:\n> However, now, with the inconsitent state in github, it is very difficult to\n> make a last review before merging, because github won't show me the correct\n> diff!\n\nSorry for the mess ! I've been doing code review for years (mostly in the\nSagemath project), but it's the first time I'm using github interface for\nit. I didn't expect thing to go west that way in a few click. It scares me a\nlittle about github interface.\n\nBest,\n\nFlorent\n"},{"author":"hivert","date":"2017-12-11T11:02:02Z","comment":"@CohenCyril: I actually had a repo ready to be forked, So I made a new branch and resubmitted a new PR See https://github.com/math-comp/math-comp/pull/166"},{"author":"CohenCyril","date":"2017-12-11T22:43:23Z","comment":"merged as #166 "}],"review_discussion":[{"author":"ejgallego","file":"mathcomp/ssreflect/seq.v","date":"2016-05-05T23:26:27Z","comment":"May I suggest:\nProof. by apply/perm_eqP=> i; rewrite count_rev. Qed.\n"},{"author":"ejgallego","file":"mathcomp/ssreflect/seq.v","date":"2016-05-05T23:37:08Z","comment":"May I suggest:\nby elim: n2 s => [s|n2 IHn1 [|x s]]; rewrite ?drop0 ?addn0 ?addnS /=.\n"},{"author":"ejgallego","file":"mathcomp/ssreflect/seq.v","date":"2016-05-06T00:42:31Z","comment":"Umm, I'm not sure what would be the best theory for uniqP. For the proof, I'd try something more on the lines of:\n\n```\nProof.\nelim: s => [|x s IHs].\n  by constructor; case=> i [j [/andP[]]]; rewrite ltn0.\nrewrite /= negb_and negbK; case: (x \\in s) / boolP => [/(nthP d) hs|hs].\n  by constructor; case: hs => j hj hnj; exists 0, j.+1.\napply/(equivP IHs); split; case=> [i [j [hj hnj]]]; first by exists i.+1, j.+1.\ncase: i j hj hnj => [|i] [|j] //= hj hnj; last by exists i, j.\nby case/(nthP d): hs; exists j.\nQed.\n```\n\nBut surely that should be improved too.\n"},{"author":"ejgallego","file":"mathcomp/ssreflect/seq.v","date":"2016-05-06T00:44:44Z","comment":"I think this style is preferred (thought I'm not sure):\nby move/perm_eqP=> uv_count; apply/perm_eqP=> Q; rewrite !count_filter.\n"},{"author":"ejgallego","file":"mathcomp/ssreflect/seq.v","date":"2016-05-06T00:48:09Z","comment":"I'd suggest this stronger lemma:\n\nLemma all_perm_eq (u v : seq T) P : perm_eq u v -> all P u = all P v.\nProof. by move/perm_eq_mem/eq_all_r. Qed.\n"},{"author":"hivert","file":"mathcomp/ssreflect/seq.v","date":"2016-05-06T12:00:20Z","comment":"Do you want me to remove this lemma from the patch, and keep it for another pull request ? Should I open a discussion about the statement on the mailing list ?\n"},{"author":"ejgallego","file":"mathcomp/ssreflect/seq.v","date":"2016-05-06T23:31:36Z","comment":"Regarding the patch, I'd wait from feedback from the developers.\n\nI was just surprised the lemma didn't easily follow from the current theory.\n\nIt seems to me that the uniq theory in math-comp is optimized towards\nderiving facts from `uniq` assumptions and not the other way around.\n\nSo maybe it would be good to think a bit what should the \"reverse\" `uniq` theory be. `notuniq_witnessP` seems certainly spot on.\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T11:07:35Z","comment":"These are refinements of the `rev_rotr` lemma that appears further down, and whose proof should be adapted.\nAlso, both these have shorter equational proofs:\n\n```\nLemma take_rev s n : take n (rev s) = rev (drop (size s - n) s).  \nProof.\nhave /orP[le_s_n | le_n_s] := leq_total (size s) n.\n  by rewrite (eqnP le_s_n) drop0 take_oversize ?size_rev.\nrewrite -[s in LHS](cat_take_drop (size s - n)).\nby rewrite rev_cat take_size_cat // size_rev size_drop subKn.\nQed.\n\nLemma drop_rev s n : drop n (rev s) = rev (take (size s - n) s).  \nProof.\nrewrite -[s]revK take_rev !revK size_rev -minnE /minn.\nby case: ifP => // /ltnW-le_s_n; rewrite !drop_oversize ?size_rev.\nQed.\n\n```\n\n...( in RotrLemmas )\n\n```\nLemma rev_rotr s : rev (rotr n0 s) = rot n0 (rev s).\nProof. by rewrite rev_cat -take_rev -drop_rev. Qed.\n\nLemma rev_rot s : rev (rot n0 s) = rotr n0 (rev s).\nProof. by rewrite (canRL revK (rev_rotr _)) revK. Qed.\n\n\n```\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T11:31:37Z","comment":"This should so right after `nth_uniq`, and logically be called `uniqPn`(negative reflection characterization of `uniq`).\nWhile using the `i < j < size s` notation is tempting, it's likely to lead to annoying complications in intro patterns, so it is best merged into a ternary and.\nFinally the proof can be made a bit shorter by splitting the equivalence to make use of nth_uniq:\n\n```\nLemma uniqPn s :\n  reflect (exists i j, [/\\ i < j, j < size s & nth s i = nth s j]) (~~ uniq s).\nProof.\napply: (iffP idP) => [|[i [j [ltij ltjs]]]]; last first.\n  by apply: contra_eqN => Us; rewrite nth_uniq ?ltn_eqF // (ltn_trans ltij).\nelim: s => // x s IHs /nandP[/negbNE | /IHs[i [j]]]; last by exists i.+1, j.+1.\nby exists 0, (index x s).+1; rewrite !ltnS index_mem /= nth_index.\nQed.\n```\n\nFinal note: while this is a reasonable low-level lemma, the library prefers to rely on `injectivePn` as in practice s is a function range, and this avoids the pesky range conditions associated with nth. Of course, any sequence s is the codomain of `tnth (in_tuple s)`, via `map_tnth_enum`.\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T12:16:31Z","comment":"likewise, this should be called `perm_filter` (and appear just above `perm_filterC`). Also, u & v should be s1 & s2 to fit with the section conventions.\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T12:18:48Z","comment":"This should be called `perm_eq_all` (perm_eq precedes the set property), u & v should be s1 & s2, without the redundant type annotation. This should more logically appear just after `perm_eq_mem`.\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T12:27:21Z","comment":"T does not need the `eqType` annotation; in fact only `P : pred T` is required. It is preferable to express a coercion using a cast, rather than quoting it explicitly:\n\n```\nLemma sumn_count T (P : pred T) s :  \n  sumn [seq (P i : nat) | i <- s] = count P s.  \n\n```\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T12:31:05Z","comment":"It is useful (see below in `reshape_rcons`) to spin off a `sumn_rcons` intermediate lemma:\n\n```\nLemma sumn_rcons s n : sumn (rcons s n) = sumn s + n.\nProof. by rewrite -cats1 sumn_cat /= addn0. Qed.\n\nLemma sumn_rev s : sumn (rev s) = sumn s.\nProof. by elim: s => //= x s <-; rewrite rev_cons sumn_rcons addnC. Qed.\n\n```\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T12:34:59Z","comment":"The `eqType` structure is never used in this section, which would be better merged into the `Flatten`section (except for`map_flatten`/`map_reshape`/`sumn_flatten`, which must go after since they apply `flatten`/`reshape`to different types).\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T12:36:59Z","comment":"Section naming convention: t should be ss. There is a straightforward equational proof:\n\n```\nLemma flatten_rcons ss s : flatten (rcons ss s) = flatten ss ++ s. \nProof. by rewrite -cats1 flatten_cat /= cats0. Qed.\n\n```\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T12:43:02Z","comment":"The scripting convention is to start all one-line scripts with by (unless they're of the form exact ....), and not to have a redundant trailing exact: at the end of a b, e.g.,\n`Proof. elim: ss => // s ss /= <-; apply: map_cat. Qed.`\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T12:44:43Z","comment":"`exact: map_rev` proves this.\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T12:46:57Z","comment":"I don't think the equivalence serves much purpose here: better state the forward direction with separate assumptions.\n\n```\nLemma eq_from_flatten_shape ss1 ss2 :  \n  flatten ss1 = flatten ss2 -> shape ss1 = shape ss2 -> ss1 = ss2.\nProof. by move=> Eflat Esh; rewrite -[LHS]flattenK Eflat Esh flattenK. Qed.\n\n```\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T12:52:37Z","comment":"From its name, this lemma should have a `rev (reshape _ _)` LHS - you can use `canRL revK` to get back your statement.\nI prefer to put in an explicit forward \"transitive\" step to avoid excessive imperative folding/unfolding.\n\n```\nLemma rev_reshape sh s :  \n size s = sumn sh -> rev (reshape sh s) = map rev (reshape (rev sh) (rev s)). \nProof.\nmove=> sz_s; apply/(canLR revK)/eq_from_flatten_shape.\n  rewrite reshapeKr ?sz_s // -rev_flatten reshapeKr ?revK //. \n  by rewrite size_rev sumn_rev sz_s.\ntransitivity (rev (shape (reshape (rev sh) (rev s)))).\n  by rewrite !reshapeKl ?revK ?size_rev ?sz_s ?sumn_rev.\nrewrite shape_rev; congr (rev _); rewrite -[RHS]map_comp.\nby apply: eq_map => t /=; rewrite size_rev.\nQed.\n\n```\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T12:55:16Z","comment":"Should come before flattenK, and use parameter named sh s I instead of s l n.\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T12:56:13Z","comment":"Should go before nth_reshape.\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T12:59:57Z","comment":"I suggest using `n`for the trailing block size, abbreviating `m := sumn sh` to fit the conclusion on a single line, and using `rev_reshape` in the proof.\n\n```\nLemma reshape_rcons s sh n (m := sumn sh) :  \n    m + n = size s ->  \n  reshape (rcons sh n) s = rcons (reshape sh (take m s)) (drop m s).\nProof.\nmove=> Dmn; apply/(can_inj revK); rewrite rev_reshape ?rev_rcons ?sumn_rcons //.\nrewrite /= take_rev drop_rev -Dmn addnK revK -rev_reshape //.\nby rewrite size_takel // -Dmn leq_addr.\nQed.\n```\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T13:25:13Z","comment":"These functions should go at the beginning of the `Flatten`section, where the other related functions are also defined.\nThey _must_ be documented in the file header. They also should be added to the `Prenex Implicits` line at the end of the section.\nI am wary of pair-returning functions, which can be cumbersome to handle, with almost systematic destructuring or projecting. In fact I'd definitely advise against destructuring a pair in the conclusion of a lemma, and recommend using projections instead (see below).\nAn alternative here would be to expose two different functions to return the index and offset parts of your `reshape_index`. Both can be defined by one-liners, but somewhat at the expense of the following theory that becomes longer due to separate lemmas and more explicit unfolding of constants with long names. Perhaps you can try out both variants and see which one works best in your use cases.\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T13:37:10Z","comment":"(Revised) theory for a pair-returning `reshape_index`:\n\n```\nDefinition flatten_index sh r c := sumn (take r sh) + c.  \nFixpoint reshape_index sh i :=\n  if sh isn't s0 :: s then (0, i) else \n  if i < s0 then (0, i) else \n  let (r, c) := reshape_index s (i - s0) in (r.+1, c).\n\nLemma reshape_indexP sh i (rc := reshape_index sh i) :  \n  i < sumn sh -> rc.1 < size sh /\\ rc.2 < nth 0 sh rc.1.  \nProof.\nelim: sh i @rc => //= n sh IHsh i; have [// | le_n_i] := ltnP i n.\nby rewrite -leq_subLR subSn // => /IHsh; case: reshape_index.\nQed.  \n\nLemma reshape_indexK sh i (rc := reshape_index sh i):  \n  flatten_index sh rc.1 rc.2 = i.\nProof.  \n  elim: sh i @rc => //= n sh IHsh i; have [// | le_n_i] := ltnP.\ncase: reshape_index {IHsh}(IHsh (i - n)) => r c /= Drc.\nby rewrite -(subnKC le_n_i) -Drc addnA.\nQed.  \n\nLemma flatten_indexK sh r c :  \n   c < nth 0 sh r -> reshape_index sh (flatten_index sh r c) = (r, c).  \nProof.\nelim: sh r => [|n sh IHsh] [| r] //= => [-> // | /IHsh-Drc].\nby rewrite /flatten_index /= -addnA addKn Drc ifN // -leqNgt leq_addr.\nQed.\n\nLemma nth_flatten x0 ss i (rc := reshape_index (shape ss) i) :  \n  nth x0 (flatten ss) i = nth x0 (nth [::] ss rc.1) rc.2.  \nProof.\nelim: ss i @rc => //= s ss IHss i; rewrite nth_cat.\nby have [// | le_s_i] := ltnP; rewrite /= IHss; case: reshape_index.\nQed.  \n\n```\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T13:41:04Z","comment":"Some shorter proofs, using views, contrapositives, and the associativity of `maxn`\n\n```\nLemma incr_nth_inj v : injective (incr_nth v).  \nProof.\nmove=> i j /(congr1 (nth 0 ^~ i)); apply: contra_eq => neq_ij.\nby rewrite !nth_incr_nth eqn_add2r eqxx /nat_of_bool ifN_eqC.\nQed.\n\nLemma incr_nthC v i j : incr_nth (incr_nth v i) j = incr_nth (incr_nth v j) i.\nProof.\napply: (@eq_from_nth _ 0) => [|k _]; last by rewrite !nth_incr_nth addnCA.\nby do !rewrite size_incr_nth leqNgt if_neg -/(maxn _ _); apply: maxnAC.\nQed.\n\n```\n"},{"author":"ggonthier","file":"mathcomp/ssreflect/seq.v","date":"2016-05-10T13:52:22Z","comment":"Theory with separate `reshape_index` and `reshape_offset` functions:\n\n```\nDefinition flatten_index sh r c := sumn (take r sh) + c.  \nDefinition reshape_index sh i := find (pred1 0) (scanl subn i.+1 sh).\nDefinition reshape_offset sh i := i - sumn (take (reshape_index sh i) sh).\n\nLemma flatten_indexP sh r c :\n  c < nth 0 sh r -> flatten_index sh r c < sumn sh.  \nProof.  \nmove=> lt_c_sh; rewrite -[sh in sumn sh](cat_take_drop r) sumn_cat ltn_add2l.\nsuffices lt_r_sh: r < size sh by rewrite (drop_nth 0 lt_r_sh) ltn_addr.\nby case: ltnP => // le_sh_r; rewrite nth_default in lt_c_sh.\nQed.\n\nLemma reshape_indexP sh i : i < sumn sh -> reshape_index sh i < size sh.\nProof.  \nrewrite /reshape_index; elim: sh => //= n sh IHsh in i *; rewrite subn_eq0.\nby have [// | le_n_i] := ltnP i n; rewrite -leq_subLR subSn // => /IHsh.\nQed.\n\nLemma reshape_offsetP sh i :\n  i < sumn sh -> reshape_offset sh i < nth 0 sh (reshape_index sh i).\nProof.  \nrewrite /reshape_offset /reshape_index; elim: sh => //= n sh IHsh in i *.\nrewrite subn_eq0; have [| le_n_i] := ltnP i n; first by rewrite subn0.\nby rewrite -leq_subLR /= subnDA subSn // => /IHsh.\nQed.\n\nLemma reshape_indexK sh i :  \n  flatten_index sh (reshape_index sh i) (reshape_offset sh i) = i.\nProof.\nrewrite /reshape_offset /reshape_index /flatten_index -subSKn.\nelim: sh => //= n sh IHsh in i *; rewrite subn_eq0; have [//|le_n_i] := ltnP.\nby rewrite /= subnDA subSn // -addnA IHsh subnKC.\nQed.\n\nLemma flatten_indexKl sh r c :  \n  c < nth 0 sh r -> reshape_index sh (flatten_index sh r c) = r.  \nProof.  \nrewrite /reshape_index /flatten_index.\nelim: sh r => [|n sh IHsh] [|r] //= lt_c_sh; first by rewrite ifT.\nby rewrite -addnA -addnS addKn IHsh.\nQed.\n\nLemma flatten_indexKr sh r c :  \n  c < nth 0 sh r -> reshape_offset sh (flatten_index sh r c) = c.  \nProof.  \nrewrite /reshape_offset /reshape_index /flatten_index.\nelim: sh r => [|n sh IHsh] [|r] //= lt_c_sh; first by rewrite ifT ?subn0.\nby rewrite -addnA -addnS addKn /= subnDl IHsh.\nQed.\n\nLemma nth_flatten x0 ss i (r := reshape_index (shape ss) i) :  \n  nth x0 (flatten ss) i = nth x0 (nth [::] ss r) (reshape_offset (shape ss) i).\nProof.\nrewrite /reshape_offset -subSKn {}/r /reshape_index.\nelim: ss => //= s ss IHss in i *; rewrite subn_eq0 nth_cat.\nby have [//|le_s_i] := ltnP; rewrite subnDA subSn /=.\nQed.  \n\n```\n"},{"author":"hivert","file":"mathcomp/ssreflect/seq.v","date":"2016-11-17T00:05:29Z","comment":"First of all, I'm sorry that I took me so long to answer your suggestions. I just gave a try to both theories through my development. I've four quite different use cases so that they probably are altogether representative. It seems that \n- Version 1 gives more convoluted proofs where one needs to states facts before destructuring the pair\n- Version 2 gives simpler proof but with less readable statements. Actually, in two cases I had to write some equivalent of destructuring as \n\n```\nset r := reshape_index s i; set c := reshape_offset s i` \n```\n\njust to keep thing readable. At the end of the day, I think the second version is better. \nIf you want to have a look, the diff between my two attempts is at  https://github.com/hivert/Coq-Combi/commit/9538004053d58ab1f7ed06c41bbef43af0fe86de\nUnless you have some more comment I'll submit version 2 with separate functions.\n\nFinally I needed the following extra lemma so I'm adding it to the pull request:\n\n```\nLemma reshape_index_leq sh i1 i2 :\n  i1 <= i2 -> i2 < sumn sh ->\n  (reshape_index sh i1) < (reshape_index sh i2) \\/\n  ((reshape_index sh i1) = (reshape_index sh i2) /\\\n   (reshape_offset sh i1) <= (reshape_offset sh i2)).\n```\n"},{"author":"hivert","file":"mathcomp/ssreflect/seq.v","date":"2016-11-17T08:11:42Z","comment":"Note: I can't add them to the Prenex Implicits line at the end of the section. because they are no implicit arguments.\n"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2017-09-07T15:26:09Z","comment":"Hi! The statement of this lemma `reshape_index` looks weird to me (i.e. using `\\/` and `/\\`), could you tell me how it is used?"},{"author":"hivert","file":"mathcomp/ssreflect/seq.v","date":"2017-09-07T16:19:14Z","comment":"I'm just writing that under the assumption, the pairs (index1, offset1) is lexicographically smaller than (index2, offset2). The form of the statement looked natural to me. How would you write that ? \r\n\r\nNow, to answer your question: Actually, I've only used it once, that is in the file https://github.com/hivert/Coq-Combi/blob/master/theories/MPoly/homogsym.v\r\nin the middle of the proof of lemma monEP.  There, I actually only need that \r\n\r\n    `reshape_index m i <= reshape_index m j` \r\n\r\nI prove it performing a case analysis on the disjunction.\r\n"},{"author":"LaurenceRideau","file":"mathcomp/ssreflect/seq.v","date":"2017-11-30T13:19:26Z","comment":"Hi Florent, could you remove this last theorem ( reshape_index_leq ) from your request, so that we can merge it,. Then, please  do a new pull request for that specific theorem.\r\n"},{"author":"hivert","file":"mathcomp/ssreflect/seq.v","date":"2017-12-03T23:58:27Z","comment":"Done and merged on my repo. However I'm not sure if my changes are resubmitted. To you see them ?"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2017-12-04T12:29:34Z","comment":"Dear Florent, I think the problem is that you merged with master instead of rebasing your branch on top of master and adding a commit, but I'm no github expert. Maybe @maximedenes can explain this behavior to us?"},{"author":"CohenCyril","file":"mathcomp/ssreflect/seq.v","date":"2017-12-04T12:36:16Z","comment":"Github might be unable to handle this practice.\r\n\r\nThe best practice would have been to open a new branch on your side to prepare the pull request, and then change the content of this branch each time you update your pull request, or each time you rebase your branch on top of master. And never merge this branch with anything.\r\n\r\nSince you did not do it, you will have to force your branch master : I think you should remove your merge commit, then add a new commit on your master branch and rebase it on top of our master. Then github will update your pull request accordingly and state it has no conflicts. Does what I say make sense?"}],"tags":[],"commits":[{"author":"hivert","committer":"hivert","hash":"91e441ff120057657f61930bf8b97113311e8378","message":"Missing lemmas in seq","date":"2016-05-05T22:31:00Z"},{"author":"hivert","committer":"hivert","hash":"ae32703f67eb90738197c9641066a5f1c6d60896","message":"Emilio's improvements","date":"2016-05-05T23:44:43Z"},{"author":"hivert","committer":"hivert","hash":"f7b92d0e9e5d073f6f12b5c0da1bbaacef7eff64","message":"Emilio's improvements on Florent's seq lemmas (2)","date":"2016-05-06T07:29:48Z"},{"author":"hivert","committer":"hivert","hash":"38e95390c526a4b96cd5ba42bfdee50fdfc69d17","message":"Merge remote-tracking branch 'upstream/master'","date":"2016-05-06T11:55:02Z"},{"author":"hivert","committer":"hivert","hash":"fe120ba390f36367b1b799950c4fc7a847f924fe","message":"Merge branch 'master' of github.com:math-comp/math-comp","date":"2016-11-16T20:42:59Z"},{"author":"hivert","committer":"hivert","hash":"0d31d714b86bf9c16fff56c95d305b7fe6d7bd60","message":"All ggonthier improvements on the pull request, except reshape_index theory","date":"2016-11-16T21:24:48Z"},{"author":"hivert","committer":"hivert","hash":"67933b2acd5ddd6835e9bfcd5b2525466856de3c","message":"Script conventions (by | exact)","date":"2016-11-16T21:36:29Z"},{"author":"hivert","committer":"hivert","hash":"3b6c7864ee8b703be1e898a15bfa74c5864074a7","message":"flatten and reshape indexes","date":"2016-11-17T00:26:41Z"},{"author":"hivert","committer":"web-flow","hash":"6a9e263fb0be33475ab62d90876e2781b01cda66","message":"Merge branch 'master' into master","date":"2017-12-03T23:43:03Z"}]}